# Daily Retrospective  
**작성자**: [이지은]  
**작성일시**: [2024-12-16]  

## 1. 오늘 배운 내용 (필수)  

### TypeScript란?
- 프로그램을 실행시키지 않으면서 코드의 오류를 검출하는 것을 정적 검사라고 한다. 그리고 사용되는 값의 타입에 따라 오류를 판단하는 것을 정적 타입 검사라고 한다. TypeScript는 정적 타입 언어이다.
- JavaScript는 동적 타입으로 프로그램을 실행시키기 전까지 소스의 오류를 파악하기 어렵지만 TypeScript는 JavaScript의 정적 타입 검사기로써 컴파일 단계에서 오류를 검출해준다.

### 왜 항상 참이 될까?
```
if ("" == 0) {
  // 참이다.
}
```
- 자바스크립트의 동일 연산자(==)는 인수를 강제로 변환하여, 예기치 않은 동작을 유발한다.
- 자바스크립트는 비교 연산을 할 때 숫자 연산을 우선시 하기 때문에 ""는 0으로 변환된다.
- 조건이 0 == 0이 되기 때문에 참이 된다.
```
if (1 < x < 3) {
  // *어떤* x 값이던 참이 된다.
}
```
- 이때 1 < x가 먼저 진행된다. true 또는 false의 결과가 나오고 그 값과 3을 비교하게 된다.
- true와 false는 숫자와 비교 연산을 할 때 각각 1과 0이 된다. 그래서 3과 비교했을 때 항상 3보다 작다. - 따라서 항상 참이 된다.

### 자바스크립트에서 타입스크립트로?
- 프로그램을 실행시키지 않으면서 코드의 오류를 검출하는 것을 정적 검사라고 한다. 그리고 사용되는 값의 -타입에 따라 오류를 판단하는 것을 정적 타입 검사라고 한다. - TypeScript는 정적 타입 언어이다.
- JavaScript는 동적 타입으로 프로그램을 실행시키기 전(런타임 전)까지 소스의 오류를 파악하기 어렵지만 - - TypeScript는 JavaScript의 정적 타입 검사기로써 컴파일 단계에서 오류를 검출해준다.
- 즉, TypeScript는 컴파일-타임 타입 검사자가 있는 JavaScript의 런타임이다.

### TypeScript에서의 this
- 타입스크립트는 this를 더 안전하게 사용할 수 있도록 타입 검사를 제공한다.
this를 사용하지 않는 함수라면 this를 void로 설정한다. this를 사용할 수 없음을 명시적으로 나타낼 수 있다.
- 콜백 함수와 this 문제 해결: 콜백 함수에서는 this가 기대와 다를 수 있다. 이를 해결하기 위해 화살표 함수를 사용한다.
- 화살표 함수는 this를 고정하므로, 이벤트 핸들러로 넘길 때 this 문제가 발생하지 않는다

### 자바스크립트의 오버라이딩은?
- 자바스크립트에서 오버라이딩은 부모 클래스의 메서드를 자식 클래스에서 재정의하는 것을 말한다.
- 오버라이딩된 자식 클래스는 부모 클래스의 메서드와 자신의 메서드를 모두 가지고 있다. 그렇지만 이때의 우선순위는 자신의 메서드가 더 높다.
- 자식 클래스에서 해당 메서드를 오버라이드하면 자식 클래스에 새로운 메서드가 추가되지만, 부모 클래스의 메서드는 사라지지 않고 자식 클래스의 프로토타입에 여전히 남아있다. (=> 6번 참조)
- 상속을 했지만 자식 클래스에 오버라이딩된 메서드가 없다면 부모 클래스의 메서드가 호출된다.

### 타입스크립트에서 제너릭을 사용하는 이유는?
- 제너릭은 TypeScript에서 타입을 동적으로 설정할 수 있게 해주는 기능으로, 코드의 재사용을 높이고 타입 안정성을 제공하는 개념이다.
- 제너릭을 사용하면 타입을 함수나 클래스, 인터페이스 등의 선언 시에 미리 정의하지 않고, 해당 코드가 실행될 때 실제 타입을 매개변수로 지정할 수 있다. 이를 통해 코드의 유연성 및 확장성이 향상된다.

### 클래스의 스태틱과 인스턴스 차이점
    클래스는 스태틱 영역과 인스턴스 영역이 나뉜다.

- 스태틱 영역: 클래스 자체에 속하는 부분.
-> 클래스 이름으로 접근이 가능하다. (className)
- 인스턴스 영역: 클래스의 인스턴스에 속하는 부분.
-> 객체를 생성해야 접근이 가능하다. (new className())

=> 인터페이스가 클래스에 implements 될 때 인스턴스 부분만 검사한다. 따라서 클래스의 스태틱 영역(생성자)는 인터페이스 검사에 포함되지 않는다.

```
interface ClockConstructor {
    new (hour: number, minute: number); // 생성자 타입 정의 (스태틱 영역)
}

class Clock implements ClockConstructor {
    currentTime: Date;
    constructor(h: number, m: number) { } 
}
```
- ClockConstructor 인터페이스는 생성자 시그니처를 정의하고 있다.
- Clock 클래스는 인터페이스를 implements하려 하지만, ClockConstructor의 생성자 시그니처와 Clock 클래스의 생성자가 서로 일치하는지 검사할 수 없다.
- 왜냐하면 생성자는 스태틱 영역에 속하지만 implements는 인스턴스 영역만 검사하기 때문이다.
```
interface ClockConstructor { // 생성자 (스태틱 영역)
    new (hour: number, minute: number): ClockInterface;
}
interface ClockInterface { // 인스턴스 영역
    tick(): void;
}

function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {
    return new ctor(hour, minute);
}

class DigitalClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log("beep beep");
    }
}
class AnalogClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log("tick tock");
    }
}

let digital = createClock(DigitalClock, 12, 17);
let analog = createClock(AnalogClock, 7, 32);
```
- 이 문제를 해결하기 위해 클래스의 생성자(스태틱 영역)와 인스턴스 메서드(인스턴스 영역)를 별도의 인터페이스로 나누어 정의한다.

```
interface ClockConstructor {
  new (hour: number, minute: number);
}

interface ClockInterface {
  tick();
}

const Clock: ClockConstructor = class Clock implements ClockInterface {
  constructor(h: number, m: number) {}
  tick() {
      console.log("beep beep");
  }
}
```
- 또 다른 방법은 클래스 표현을 사용하는 것이다.

### 타입스크립트의 인터페이스가 자바스크립트로 빌드되면서 인터페이스가 어떻게 변하는지?
#### 타입스크립트 예시
```
interface LabeledValue {
    label: string;
}

function printLabel(labeledObj: LabeledValue) {
    console.log(labeledObj.label);
}

let myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);
```

#### 위의 코드를 빌드한 자바스크립트
````
"use strict";
function printLabel(labeledObj) {
    console.log(labeledObj.label);
}
let myObj = { size: 10, label: "Size 10 Object" };
printLabel(myObj);
````

타입스크립트에서 자바스크립트로 빌드되었을 때 눈에 와닿게 보이는 변화
1) "use strict" (엄격 모드) 선언이 되어있음
=> 엄격 모드가 활성화되면서 일부 안정성 검사나 예외 처리가 자바스크립트 코드에도 적용된다.
2) 타입을 명시해둔 정보가 모두 사라짐
=> 자바스크립트는 타입 검사를 진행하지 않기 때문이다.
3) 인터페이스도 타입스크립트에만 존재하는 개념이기 때문에 타입과 함께 사라짐

#### 프로토타입?
- 자바스크립트에서 함수는 속성을 가질 수 있다.
- 각 객체에는 prototype이라는 다른 객체에 대한 링크를 보유하는 비공개 속성이 있다.
- 그 프로토타입 객체도 자신만의 프로토타입을 가지고 있으며, 프로토타입으로 null을 가진 객체에 도달할 때까지 이 연결은 계속된다.
- null은 프로토타입이 없으며, 이 프로토타입 체인에서 최종 링크 역할을 한다.

#### 자바스크립트의 클래스 작동 방식
- 자바스크립트의 클래스는 사실 내부적으로 프로토타입을 기반으로 객체를 생성하는 방식으로 구현된다.
- 자바스크립트에서는 객체가 생성될 때 각 객체는 프로토타입을 가진다. 프로토타입은 객체의 부모 역할을 하며, 객체가 메서드나 속성에 접근할 때 해당 속성이나 메서드가 객체 자체에 없으면 프로토타입에서 찾아가게 된다.
- 객체의 프로토타입은 그 객체의 __proto__ 속성에 존재하며, 이 프로토타입도 또 다른 객체를 가질 수 있다. 이런 방식으로 체인 형식의 상속이 이루어진다.
- 클래스 내부의 프로토타입 작동 방식
    1. 클래스 생성: class 키워드로 클래스를 정의하면, 자바스크립트는 해당 클래스를 생성자 함수로 변환한다.
    2. constructor 메서드: 클래스에서 constructor는 객체를 생성할 때 호출되는 함수이다. 클래스의 인스턴스를 초기화하는 역할을 한다.
    3. 프로토타입 메서드: 클래스 내부에서 정의한 메서드는 사실 프로토타입 객체에 추가된다. 자바스크립트에서 메서드는 프로토타입 객체의 속성으로 등록된다.
- 프로토타입을 이용한 객체 확장도 가능하다.
    ```
    Animal.prototype.eat = function() {
        console.log(`${this.name} is eating`);
    };

    const cat = new Animal('Cat');
    cat.eat(); // "Cat is eating"
    ```

## 2. 동기에게 도움 받은 내용 (필수)

1. 성철님이 일찍 오셔서 이메일 로그인 방법을 알려주셨어요!
2. 다은님도 출근 조회 관련 꿀팁을 알려주셨어요. 실수로 출근 전체 조회해서 전직원 출근 명단이 조회됐는데 앞으로는 제 출석만 확인할 수 있는 메뉴를 만들었습니다~

---

## 3. 오늘 느낀 개선점이 있다면? (선택)  

    오늘은 타입스크립트 핸드북을 타이핑하며 전체적으로 읽어보는 시간을 가졌다. 자바스크립트 문법도 함께 공부했다. 그런데 끝나기 약 두 시간 전부터는 질문을 몇 가지 적어둔 뒤, 그에 대한 답변을 작성하는 방식으로 공부법을 바꿨다. 읽기에 집중할 때는 지엽적인 내용들까지 함께 보게 되었는데, 답변을 작성하는 방식으로 공부하니 확실히 필요한 정보에 집중할 수 있었다. 궁금한 것을 잊지 않고 꼬리 물면서 공부하는 습관을 들여야겠다. 모든 것을 챙기려고 하기보다는 확실히 알아갈 수 있는 시간을 보내도록 해야겠다. 
    
    그리고 당장 타입스크립트를 마스터하려는 생각보다 개인적인 공부로 자바스크립트 문법에 시간을 투자해야 할 것 같다.
 
---

## 4. 해결하지 못한 문제 및 의문점 (선택)  

- 타입스크립트의 인터페이스가 자바스크립트로 빌드되면서 생기는 변화에 대해 찾아보는 것도 좋을 것 같다 말씀해주셔서 여기저기 검색을 해서 찾아봤다.
- 내가 코드를 비교해보면서 찾은 변화는

        - "use strict" (엄격 모드) 선언이 되어있음
        => 엄격 모드가 활성화되면서 일부 안정성 검사나 예외 처리가 자바스크립트 코드에도 적용된다.
        => 인터페이스가 아니어도 해당된다.

        - 타입을 명시해둔 정보가 모두 사라짐
        => 자바스크립트는 타입 검사를 진행하지 않기 때문이다.
        => 인터페이스가 아니어도 해당된다.

        - 인터페이스도 타입스크립트에만 존재하는 개념이기 때문에 타입과 함께 사라짐

    이정도였다. 

- 인터페이스가 사라지는 것 외에 타입스크립트의 인터페이스가 빌드되면서 생기는 변화가 또 있는지 궁금하다.