# Daily Retrospective  
**작성자**: 고건호
**작성일시**: 2024-12-17

## 1. 오늘 배운 내용

- TypeScript의 기본 문법
- JavaScript의 프로토타입
    JavaScript는 객체 기반의 프로그래밍 언어
    프로토타입을 기반으로 상속을 구현하여 불필요한 중복 제거
    중복 제거 방법 = 기존의 코드를 적극적으로 재사용
    프로토타입 = OOP의 근간을 이루는 객체 간 상속을 구현하기 위해 사용
    ``` javascript
    // 간단한 예제 코드

    // 생성자 함수
    function Circle(radius) {
        this.radius = radius;
    }

    /**
     * Circle 생성자 함수가 생성한 모든 인스턴스가 getArea 메서드를
     * 공유해서 사용할 수 있도록 프로토타입에 추가
     * 프로토타입은 Circle 생성자 함수의 prototype 프로퍼티에 바인딩
     */
    Circle.prototype.getArea = function () {
        return Math.PI * this.radius ** 2;
    };

    // 인스턴스 생성
    const circle1 = new Circle(1);
    const circle2 = new Circle(2);

    /**
     * Circle 생성자 함수가 생성한 모든 인스턴스는 부모 객체의 역할을 하는
     * 프로토타입 Circle.prototype으로부터 getArea 메서드를 상속 받음
     * 즉, Circle 생성자 함수가 생성하는 모든 인스턴스는 하나의 getArea 메서드 공유
     */
    console.log(circle1.getArea === circle2.getArea); // true

    console.log(circle1.getArea());
    console.log(circle2.getArea());
    ```
    Circle 생성자 함수가 생성한 모든 인스턴스는 자신의 프로토타입, 즉 상위(부모) 객체 역할을 하는 Circle.prototype의 모든 프로퍼티와 메서드를 상속 받음
    getArea 메서드는 단 하나만 생성되어 프로토타입인 Circle.prototype의 메서드로 할당되어 있음
    따라서 Circle 생성자 함수가 생성하는 모든 인스턴스 = getArea 메서드를 상속 받아 사용할 수 있음
    자신의 상태를 나타내는 radius 프로퍼티만 개별적으로 소유
    내용이 동일한 메서드 = 상속을 통해 공유하여 사용
- JavaScript의 스코프
    함수의 매개변수 = 함수 내부에서만 참조 가능, 외부에서는 참조 불가능
    매개변수를 참조할 수 있는 스코프(유효범위)가 함수 내부로 한정되기 때문
    ``` javascript
    function add(x, y) {
        /**
         * 매개변수는 함수 내부에서만 참조 가능
         * 즉, 매개변수의 스코프(유효범위)는 함수 내부
         */
        console.log(x, y); // 2, 5
        return x + y;
    }

    add(2, 5);

    // 매개변수는 함수 내부에서만 참조 가능
    console.log(x, y); // ReferenceError: x is not defined
    ```
    변수는 자신이 선언된 위치에 의해 자신이 유효한 범위가 결정됨
- JavaScript의 호이스팅
- JavaScript의 생성자 함수에 의한 객체 생성

---

## 2. 동기에게 도움 받은 내용

VSC를 본격적으로 다루는게 처음이기도 하고 항상 git이 꼬이는 것에 대해 막연한 불안감을 가지고 있었는데 강민님이 친절하게 필요한 플러그인을 알려줘서 원활하게 회고록을 push할 수 있었습니다.
현철 선임님께 법인 카드 관련해서 궁금한 부분을 여쭤봤는데 친절히 설명해주셔서 부담 없이 저녁을 법인 카드로 먹을 수 있었습니다.

---
## 3. 추가적인 궁금증

- 5.0 내부 로직들이 TypeScript로 어떻게 작성되어 있을까?

---

## 4. 도전 과제

- JavaScript의 프로토타입에 대한 확실한 이해
- TypeScript의 인터페이스에 대한 확실한 이해
- TypeScript를 이용하여 PS

---

## 5. 해결 방안 및 배운 점

- **이재희 선임님께 질의**:
    - TypeScript가 아무래도 기존에 다루던 언어인 Java와 다른 부분이 많아서 Java에 대한 지식들을 비우고 학습을 해야겠다고 최초에 말씀드렸습니다. 하지만 그런 접근 방식은 오히려 TypeScript를 학습하는 데 있어서 더 어렵게 작용할 수 있으니, Java와 어떤 부분이 다르고 어떻게 다른지를 위주로 학습을 해보라는 대답을 듣고 이를 토대로 앞으로의 학습 방식에 대한 틀을 잡을 수 있었습니다.
    - TypeScript의 원활한 이해를 위해서는 JavaScript에 대한 이해가 선행돼야 하는데, 현재 상황에서는 JavaScript의 프로토타입과 같은 굵직한 개념들 위주의 학습을 권장하셨습니다.

---

## 6. 오늘 느낀 개선점이 있다면?

항상 느끼는 부분이지만, 질문을 할 때 질문에 대한 깊이 있는 고찰이 선행되어야만 대답을 들었을 때 완벽히 소화할 수 있다는 생각이 듭니다. 이재희 선임님께 질의를 할 수 있는 기회가 있었음에도 불구하고, 질문을 어떻게 해야할지를 고민하다가 좋은 기회를 놓친 것 같아 기분이 안 좋습니다.
내일부터 듣게 될 자료구조 수업에서는 오늘 같은 일을 다시 겪지 않기 위해 맞닥뜨린 문제를 확실히 인지하고 어떤 부분이 이해가 되지 않는건지를 파악한 뒤에 질문하도록 해야겠습니다.

---

## 7. 오늘의 교육을 더 좋게 만들 수 있는 방법이 있었을까?

오늘 짚어주신 학습 키워드도 중요한 것들이었고, 스스로 학습한 시간이 더 많았어서 따로 없습니다!

---

## 8. 해결하지 못한 문제 및 의문점

- JavaScript의 함수가 1급 객체라고 불릴 수 있는 이유
- JavaScript의 this 키워드의 바인딩이 상황에 따라 달라지는 이유