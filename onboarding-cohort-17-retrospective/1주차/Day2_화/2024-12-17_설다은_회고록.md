
# **2024.12.17 회고록**
## 📝 **오늘 공부한 내용**  
## 🗂️ **기본타입**  
1. **타입스크립트에서 사용하는 타입의 종류**
 - boolean
 - number
 - string
 - array
 - tuple

    요소의 타입과 개수가 고정된 배열 표현
	let x:[string, number];
	x = ['banana', 20] // 타입이 일치하여 오류 안남.
	x = [20, 'banana'] // 타입 불일치로 오류남.
 - enum
 
    값의 집합
	기본적으로 이넘은 0부터 시작하여 멤버의 번호를 매김 (수동으로 번호 변경 가능)
	매겨진 값을 사용해 멤버의 이름을 알 수 있음
	enum Color {Red = 1, Green, Blue}
	let colorName: string = Color[2];
	console.log(colorName); // 값이 2인 'Green'이 출력
 - any

    사용자로부터 받은 데이터 or 서드 파티 라이브러리와 같은 동적 컨텐츠
	검사를 하지 않고 컴파일을 통과되길 원하는 경우 사용함.
 - void

    어떤 타입도 존재할 수 없음을 나타냄
	any와 반대타임
	보통 함수에서 반환 값이 없을 때 사용
 - null
 - undefined
 - never

    절대 반환되지 않는 값을 가질때 사용
 - object


## 🗂️ **인터페이스**  
	 : 어떤 객체의 모양(형태,구조)를 정해놓은 것으로 실제 동작하는 코드가 아닌 규칙 (ex. 계약서 폼)
	 
1. **프로퍼티**
	1) **Optional 프로퍼티**

		인터페이스의 모든 프로퍼티가 필요한 상황이 아닌 경우 >> 프로퍼티 이름 끝에 '?'를 붙힘.
	
	2) **ReadOnly 프로퍼티**

		한번 할당하면 다음부터는 바뀌지 않음. 바꾸려고하면 오류남. >> 프로퍼티 앞에 readonly를 붙힘.
		
2. **Types**
	1) **function Types**

		인터페이스는 자바스크립트 객체가 가질 수 있는 넓은 범위의 형태를 기술할 수 있음
		프로퍼티를 객체로 기술하는 것 외에 함수로도 설명 가능함.
	
	2) **indexable Types**

		타입을 '인덱스'로 기술함.
		인덱스서명 지원 타입 : 문자열, 숫자
		모두 지원가능하지만 숫자 인덱서에서 반환된 타입은 반드시 문자열 인덱서에서 반환된 타입의 하위타입이어야함.
		nunber로 인덱싱할 때 JS는 실제 객체를 인덱싱하기 전 string으로 변환함.
		(100(number) = "100"(string)가 괕음)

	3) **class Types**

		클래스에 구현된 메서드를 인터페이스 안에서도 기술할 수 있음
		* class : 설계도를 만들고 이 설계도로 실제 동작하는 객체를 생성하는 것 (ex. 붕어빵  틀)

3. **인터페이스 확장**
	1) 문법 : interface A(새로운 인터페이스) extends B (기존의 인터페이스)

4. **추가적으로 공부하기**
	ES6부터 class문법이 추가되기 시작함. 그 전에는 prototype으로 동작한 것 같은데 어떻게 다른지 알아보기

## 🗂️ **함수**  
1. **선택적 매개변수와 기본 매개변수 (Optional & Defalt parameter)**
    - 컴파일러는 매개변수들이 함수로 전달될 유일한 매개변수라고 가정함. (즉, 함수에 주어진 인자의 수 = 기대하는 매개변수의 수)
    - 선택적 매개변수는 변수명 뒤에 '?'를 붙힘.
    - 변수 뒤에 ='value'를 쓰면 default값이 됨.
	
2. **나머지 매개변수(rest Parameters)**
    - 선택적 매개변수들의 수를 무한으로 취급 가능함.
    - '...매개변수'를 써서 값을 받음.
    - 매개변수의 맨 마지막에 써야함.

3. **this & 화살표 함수**
    - this : 함수가 호출될 때 정해지는 변수
    - 최상위 레벨에서 비-메서드 문법의 호출은 this를 window로함. (strict mode에서는 undefined로)
    - 함수표현식을 ES6의 화살표 함수로 바꾸면 함수가 호출된 곳이 아닌 생성된 쪽의 this를 캡처함.
    - 화살표함수의 this는 부모의 this를 참조함.
 
## 🗂️ **리터럴타입**  
1. **리터럴타입**
    - 집합 타입보다 구체적인 하위의 타입
    - 종류 : 문자열 리터럴타입, 숫자 리터럴타입
 
## 🗂️ **유니언과 교차타입**  
1. **유니언타입**
    - 여러타입 중 하나가 될 수 있는 값
    - 세로막대(|)로 각 타입을 구분함. number | string | boolean
 
2. **교차타입**
    - 여러타입을 하나로 결합.
    - 기존 타입을 합쳐 필요한 기능을 모두 가진 단일 타입을 얻을 수 있음.

## 🗂️ **클래스**  
1. **상속**
    - 부모클래스의 속성과 메서드를 자식 클래스가 물려받는 것
    - 코드의 중복 줄이고, 유지보수를 쉽게하기 위함.
	- 문법 : class A(subclass명) extends B(superclass명)
    - 메서드 오버라이딩 :
    
        - 부모클래스의 메서드를 자식 클래스에서 '재정의'하는 것
        - 자식이 부모의 메서드를 덮어씀
        - 자식은 부모와 동일한 이름과 매개변수를 사용
        - 오버라이딩한 메서드 안에서 super키워드를 사용해 부모의 메서드를 호출함.
    
2. **추상클래스**
    - 직접 인스턴스를 생성할 수 없는 클래스
    - 하위 클래스에서 반드시 구현해야하는 메서드
    - 클래스명 앞에 'abstract'를 붙혀서 사용함.


    예시 : 
```ruby
        abstract class Animal {
            abstract makeSound(): void;
            move() {
                console.log("이동중...");
            }
        }

        class Dog extends Animal {
            makeSound() {
                console.log("멍멍")
            }
        }

        const dog = new Dog();
        dog.makeSound(); // 멍멍!
        dog.move(); // 이동중...
```
## 🗂️ **제네릭**
1. **제네릭?**
    - 데이터 타입을 고정하지 않고 다양한 타입을 유연하게 받을 수 있도록 하는 타입
    - 함수, 클래스, 인터페이스, 타입별칭 등에서 사용 가능함.

2. **사용하는 이유**
    - 코드의 재사용성이 증가 : 중복코드를 줄이고 타입에 유연하게 대응할 수 있음.
    - 타입의 안정성 보장 : 타입추론이 가능해져 런타임 에러를 컴파일 단계에서 사전 방지 가능함.
3. **기본 문법**
    ```ruby
    function 함수명<T>(매개변수: T): T {
        return 매개변수;
    }
    ```
    ※ T는 타입 매개변수(Type Parameter)의 약자로 기본으로 사용하는 것.



## 📝 **동기에게 도움 받은 내용**
지은님 : <br>
예시 코드를 보다가 생각한대로 출력값이 안나와서 물어봤는데, 같이 코드를 보면서 왜 그런건지 설명해주셨습니다. (TS Playground 일시적 오류로 값이 이상하게 나타나고 있었음.) + vsCode 프로그램으로 회고록 작성 시 툴이 익숙치 않았는데 작성하는 방법에 대해서 알려줘서 고마웠습니다.




## 📝 **추가적인 궁금증**
제네릭에 대한 개념은 이해했지만 그걸 함수, 클래스, 인터페이스에서 어떻게 응용해서 쓰는지에 대해서는 추가적으로 공부가 필요해 보입니다.



## 📝 **오늘 느낀 개선점이 있다면?**
개념을 어느정도 이해했으면 나와있는 예시를 똑같이 따라하는 것 뿐만 아니라  스스로의 구체적인 예제 코드를 만들면서 잘못 이해한 부분이나 문법, 사소한 오탈자들을 체크하면서 학습을 진행하면 체화가 더 잘 될 것 같다.