# Daily Retrospective  
**작성자**: 허수경
**작성일시**: 2024-12-18(수)

## 1. 오늘 배운 내용 (필수)  
### 자료구조란
- 자료의 집합
- 논리적인 규칙에 의해 자료에 대한 처리를 효율적으로 수행할 수 있도록 구분하여 표현

#### 자료구조의 필요성
- 데이터에 편리하게 접근하고 변경하기 위해 데이터를 저장 및 조직화
- 메모리를 효율적으로 사용하면서 데이터를 빠르고 안정적으로 처리하는 것이 궁극적인 목표

### 1-1. ArrayList (정적배열)
---
- 정적배열은 메모리가 연속적인 형태로 저장된다.

#### 장점
- 정적배열의 형태는 항목 접근 속도가 빠르고 일정하다.
	- 배열의 원소들은 모두 연속된 메모리 위치에 저장되기 때문에 인덱스를 통해 빠르게 원소를 참조하거나 변경할 수 있다.
> 검색 대상 요소의 메모리 주소 = 배열의 시작 메모리 주소 + 인덱스 * 요소의 바이트 수    

예를 들어, 위 그림처럼 메모리 주소 1000에서 시작하고 각 요소의 크기가 8byte인 배열을 생각해 보자.
```
인덱스가 0인 요소의 메모리 주소 : 1000 + 0 * 8 = 1000
인덱스가 1인 요소에 메모리 주소 : 1000 + 1 * 8 = 1008
인덱스가 2인 요소에 메모리 주소 : 1000 + 2 * 8 = 1016
```
이처럼 배열은 인덱스를 통해 효율적으로 요소에 접근할 수 있다는 장점이 있다

#### 단점
- 크기가 고정되어 있어서 사용 전 배열 크기를 지정해야 한다.
- 배열이 큰 경우 메모리 할당이 힘들다
	- 메모리상에 남아있는 공간이 있더라도 연속적인 공간이 아니면 배열을 할당할 수 없다.
	- 데이터 유실이 발생할 수 있는 위험이 있다(?)
- 중간 삽입/삭제가 복잡하다.
	- 중간 삽입/삭제가 일어날 경우 원소들의 연속적인 순서를 맞추기 위해 앞쪽으로 당기거나 밀어주는 작업이 필요하다. O(n)의 시간복잡도를 갖는다.

### 1-2. Dynamic Array (동적배열)
---
#### 개념 및 특징
- 동적 배열은 정적 배열의 단점을 어느정도 보완한 자료형, 필요에 따라 동적으로 크기를 변화시킨다.
- 내부적으로 배열로 구현되어 있으므로 원소를 참조/변경 하는데 빠른 장점을 그대로 가지고 있다.
- 배열의 사이즈보다 데이터가 작을 경우, 낭비되는 공간이 생긴다 (2배씩 증가시키기 때문)
	- 현재 배열의 크기가 100일 때, 하나만 추가하고 싶어도 크기는 200으로 커진다. 그럼 나머지 99에 대해 낭비되는 공간이 생긴다.

#### 동적배열의 동작 원리 – 배열의 동적 확장
- 처음 동적 배열이 생성될 때 내부에 일정한 크기를 갖는 배열을 할당한다.
- 추가된 원소의 총 개수가 내부 배열이 가진 크기를 넘어가면 기존의 2배 크기로 배열을 새로 할당한 후 기존 원소를 복사한다.

#### Iteration protocol
- 반복 가능한 객체를 만드는 데 사용되는 규약이다.
- 객체는 `Iterator`를 제공하고, 그 `Iterator`를 사용하여 객체의 요소를 순차적으로 접근할 수 있다.
- `for...of`, `스프레드 연산자(...)`, `Array.from()` 등에서 순차적으로 값을 반환할 수 있다.

1) Iterator protocol (반복자 프로토콜)
- 반복의 상태를 관리하고 다음 값을 반환하는 규약이다.
- 반복자 객체는 `next()` 메소드를 반드시 구현해야 하며, 이 메서드는 두 가지 속성을 포함하는 객체를 반환한다.
	- value: 현재 반복 값.
	- done: 반복이 끝났는지를 나타내는 불리언 값. true이면 반복이 종료된다.

2) Iterable protocol (순회 가능 프로토콜)
- Javascript 객체를 반복 가능하도록 만드는 규약이다.
- 순회 가능 프로토콜을 만족하기 위해 객체는 `Symbol.iterator` 메소드를 구현해야 한다.
- `Symbol.iterator` 메소드는 반복자 프로토콜을 구현한 반복자 객체를 반환한다.

> +심볼이란

- 다른 값과도 중복되지 않은 유일무이한 값이다.
- `iterable`, `generator` 등의 내부시스템의 기본적으로 들어가 있는 개념이다.

```
const sym1 = Symbol("foo");
const sym2 = Symbol("foo");
console.log(sym1 === sym2); // false
```
그럼, 언제 왜 심볼을 사용하는지 궁금해졌다.

자바스크립트가 기본 제공하는 빌트인 심볼 값을 Symbol ECMA 사양에서는 Well-Known Symbol이라고 부르며 다양한 알고리즘에서 사용한다.
그중 대표적인 예시는 순회 가능한 빌트인 이터러블이다.
Array, String, Map, Set 등과 같이 순회 가능한 빌트인 이터러블은 `Symbol.iterator`를 키로 갖는 메서드를 가지며, `Symbol.iterator` 메서드를 호출하면 이터레이터를 반환하도록 ECMA 사양에 규정되어 있다.

> +덕 타입(Duck Typing) 이란

- 덕 타입은 객체가 특정 메서드나 프로퍼티를 구현(포함)하는 방식으로 그 타입을 결정하는 방법론
- 자바스크립트에서 이터러블 객체는 그 객체가 `[Symbol.iterator]()` 메서드를 구현하는지만 확인되면 해당 객체는 이터러블 객체로 간주된다.

---
## 2. 동기에게 도움 받은 내용 (필수)
- `민준`님께서 콜백 함수와 자바스크립트 공부 사이트에 대해 안내해주셔서 학습에 도움이 되었습니다.
- `지은`님께서 이터레이터를 사용하면 이터레이블을 상속 받지 않아도 되는지 궁금했는데 이해시켜주셨습니다.

---
## 3. 추가적인 궁금증 (선택)

자바스크립트의 배열은 일반적인 배열과 다르다고 하셔서 어떤 점이 다른지 찾아보았다.
- 일반적으로 배열이라는 자료 구조의 개념은 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료구조를 말한다. 
- 자바스크립트의 배열은 동일한 크기를 갖지 않아도 되면 연속적으로 이어져 있지 않을 수도 있다. 
- 자바스크립트의 배열은 배열의 동작을 흉내낸 특수한 객체이다.

#### 자바스크립트의 배열
1) 자바스크립트 배열의 요소는 사실 프로퍼티 값이다.
- 자바스크립트에서 사용할 수 있는 모든 값은 객체의 프로퍼티 값이 될 수 있으므로 어떤 타입의 값이라도 배열의 요소가 될 수 있다. 

2) 자바스크립트 배열은 해시 테이블로 구현된 객체이다.
- 해시 테이블로 구현되었기에 메모리 주소가 연속적으로 나열되지 않는다. 그래서 여러가지 타입을 하나의 배열에 넣을 수 있다.
- 그래서 인덱스로 배열 요소에 접근하는 경우는 일반적인 배열보다 느리지만 요소를 탐색/삽입/삭제하는 경우에는 일반적인 배열보다 빠르다. 
	- 인덱스로 접근하는 경우, 해당 인덱스와 같은 키값을 찾기위해 순차 검색을 하기 때문에 일반적인 배열보다 느림.

3) 자바스크립트 배열의 크기는 동적이다.
- 자바스크립트에서 배열의 내부 크기는 고정되지 않으며 배열의 길이가 변경될 때마다 동적으로 크기가 조정된다. 자바스크립트 엔진에서 메모리를 효율적으로 관리하며, 배열에 요소를 추가할 때 내부적으로 필요한 만큼 메모리 공간을 확장하고 최적화된 방식으로 배열을 처리한다.
    
##### 그래서 자바스크립트의 배열은 인덱스로 통한 데이터 접근의 단점보다는 탐색, 추가, 삭제에 의한 장점이 더 크다고 판단해 희소 배열인 해쉬 테이블로 배열을 구현한 것이다. 

---
## 4. 도전 과제 (선택)  
1. 콜백함수와 match 함수를 이해하기 어려웠다.<br>
테스트 코드 작성시 `(item) => item === 10` 이 부분에 대해 이해가 가지 않았다.<br>
처음에는 myArray 객체를 item에 할당해준 적이 없는데 어떻게 myArray가 item으로 전달되는지 궁금했다.<br>
이를 살펴보니 `콜백함수`에 대해 이해가 필요했다.
콜백함수는 함수의 인자로 넘겨지는 함수를 의미한다.
그러니깐 myArray 객체의 myFindIndex 메서드의 파라미터로 함수가 넘어간다.

MyArray 클래스의 myFindIndex 메서드에서는 `Predicate` 타입에 의해 함수를 받는다.

- `Predicate` 타입
```
// types.ts
export type Predicate<T = any> = (item: T) => boolean;
```
`Predicate`는 제네릭 타입으로, `item`을 받아서 `boolean` 값을 반환하는 함수 타입을 정의한 것이다. `myFindIndex` 메서드에서 `match` 매개변수는 바로 이 `Predicate` 타입의 함수를 받는다. 즉, `myFindIndex` 메서드는 `item`을 하나씩 받아 `match(item)`을 실행하고, 조건을 만족하는 원소가 있으면 그 인덱스를 반환한다.


2. 이터레이블과 이터레이터 객체의 상관관계를 이해하기가 어려웠다.
Iterator 객체와 Iterable 객체의 차이를 아는 것이 중요한 포인트인 것 같다.
정리하자면:
1) **이터러블 객체 (Iterable)**는 반드시 Symbol.iterator 메서드를 구현해야 한다.
2) `Symbol.iterator` 메서드는 **이터레이터 객체 (Iterator)**를 반환해야 한다.
3) 따라서, 이터러블 객체는 `Symbol.iterator`를 통해 이터레이터 객체를 생성하거나 반환한다. 즉, 이터러블 객체는 이터레이터 객체를 소유한 객체이다.

그리고 Iteratble를 상속하는 건 선택이다.(선택이지만 권장사항이다.)<br>
이유는, JS 덕 타입의 특징으로 `Symbol.iterator` 메서드를 소유하고 있어 이미 이터러블한 객체가 되기에 자동으로 상속받는 것으로 동작이 된다.<br>
하지만 상속을 명시해주므로서 해당 객체가 이터러블한 객체를 알리고,
`Symbol.iterator` 메서드를 구현하지 않을 경우, 컴파일러(타입스크립트 환경)에서 에러를 발생시켜 실수를 방지할 수 있다.

