## 1. 오늘 배운 내용 (필수)

*정적배열* 
 - 크기가 고정 : 성능이 빠르나, 크기를 초과하면 저장불가, 크기를 초과하지 않는다면 저장공간의 낭비
 - 구현이 간단함 

*동적배열*
 - 크기가 유연 : 메모리를 효율적으로 사용 가능, 크기변경 시 메모리 재할당 비용 발생
 - 구현이 상대적으로 복잡, 관리가 필요

*JS에서의 배열*
 - 기본적으로 동적배열만 지원
 > 하지만 사실 배열이 아니였다?!
 - 배열의 동작을 흉내내는 특수 객체 
  -- 한 배열안에 다양한 자료형의 데이터가 들어갈 수 있음 (비균일타입)
  -- 연속나열이 아님
  -- 상대적으로 접근이 느림 

*함수오버로드*
 - 동일한 이름의 함수를 매개변수의 타입이나 개수에 따라 다르게 정의하는 기능
 - 코드의 가독성을 높이고, 직관적으로 사용할 수 있음 

 \\함수시그니처
  - 함수의 이름, 매개변수, 반환값등 함수를 정의하는데 사용되는 형태 및 구조
  - js에서는 명시적으로 제한하지 않으나, ts에서는 명시적으로 작성 가능

*싱글링크드리스트*
 - 각각의 노드가 자신의 next를 알고 있어서 꼬리물기처럼 연결되어있는 형태
 - 데이터의 삽입/삭제에 유리
 - 반대로 데이터의 조회는 불리
  > 배열과 상호보완적 관계
 - 자신의 next를 알고 있어야 하기 때문에 메모리 사용 측면에서 비효율적
 - 맨 앞과 맨 뒤의 노드를 의미하는 head/tail이 있고, 노드 안에서 자기노드와 다음노드를 의미하는 data/next가 있다.
  > head/tail이 실제 노드를 의미하는지 모르고 prev, next랑 같은 의미로 생각해서 한참을 헤맴..
 - 객체안의 객체 형태

*제네릭*
 - 타입을 변수화 한 것
 - 코드의 재사용성을 높인다 
 - 가독성과 유지보수성 향상에 도움이 된다
 - 함수, 클래스, 인터페이스 가리지 않고 사용 가능 
  > 실제로 현우님이 주신 예제를 보고 실습해봐야 완벽히 이해할 수 있을듯.

*타입가드*
 - 매개변수 타입을 유니언으로 지정했을때, 변수의 타입을 좁혀주는 역할
 > if문으로 밸리데이션 넣은 느낌?

 *iterable, iterator*
 - 객체를 순회할 수 있도록 만들어주는 친구.(까지 이해.)


## 2. 동기에게 도움 받은 내용 (필수)
- 아연님께 myArray - match부분 도움을 받았습니다.
- 민준님과 건호님께 깃 오리진 푸쉬 관련해서 도움을 받았습니다.
- 도형님이 포케 가지러 같이 가주셨습니다. 가지러 가는 길에 링크드 리스트의 노드 개념에 대해서 설명해주셨습니다.
- 건호님이 질문 받아주시면서 비전공자의 마음을 공감해주셨습니다. 덕분에 힘이 났습니다. 
- 수경님과 다은님이 화장실 발매트 색깔을 추천해주셨습니다. 두 분이 같은 색을 추천해주셔서 고민할 시간을 아꼈습니다.
- 현철님이 늦게까지 같이 남아주셔서 힘이 됐습니다.

---

## 3. 추가적인 궁금증 (선택)

*함수오버로드로 여러 함수를 같은 이름으로 만드는 것과, 함수 매개변수에 ?를 넣어서 옵셔널로 하는 것이 어떤 차이가 있을지?*
 - 함수오버로드가 호출하는 방식마다 명확하게 다른 동작을 지정할 수 있음.
 - ?를 사용하는 방법은 매개변수가 선택사항이 될 뿐, 어턴 타입 조합이 허용되는지 세분화하기 어려움
 - 가독성의 측면에서도 함수오버로드가 명시적으로 표현하기 때문에 유리.
 - 단순히 선택적 매개변수를 처리하려면 ?, 명확하게 의도가 있다면 함수오버로드를 사용할 것.

*iterator는 객체를 순회가능하도록 만들어주는 것인지? 아니면 그 자체로 객체를 순회해주는건지?*
 - 객체를 반복 가능하도록 만들어 주는 것. 객체에 for .. of 루프, 스프레드 연산자등을 사용할 수 있게 해준다.
 - 수동으로 하고 싶다면, next()를 호출해서 반복 수행 가능.

*사전질문에서 우리회사는 평소에는 배열을 쓰는데, 데이터가 특정 수가 넘어가면 링크드리스트로 바꾼다는 것을 들었다.*
 - 재희님이 뒤에서 민준님께 말씀하시는 걸 귓동냥으로 훔쳐들어보니, 이카운트 특성상 전체에서 조회하는 거 보다 특정 데이터 기준으로 근처에 있는 데이터를 찾을일이 많아서 그렇다.
 - 진짜로 상담하다보면 전체 데이터 뒤지는 사람보다 특정 일자 전표 찍고 그 위 아래 전표 보는 사람이 많다.
    >> 고객의 사용 패턴을 파악해 효율적인 구조에 적용한 사례를 들으니 확 와닿았다.
 - 별개로, 원래는 배열형태인 것을 어떻게 링크드리스트 형태로 바꾸는지? 바꾸는데 비용이 더 들진 않을까?


## 4. 도전 과제 (선택)

*링크드리스트의 구조를 이해하는데 어려움이 있었습니다.*
 - 노드 개념이 낯설었습니다. 
 - 이전에 배열 혹은 객체에서 데이터를 찾아서 수정하거나 삭제할 때,
   어딘가에 전체 데이터를 담아두고, 해당 데이터안에서 찾았다면,
   링크드리스트는 전체 데이터를 담아두는 배열 같은 게 없어서 내가 필요한 데이터를 찾는 방법을 생각하는데 어려움이 있었습니다.

---

## 5. 해결 방안 및 배운 점 (선택)

*그림으로 그려서 해결했습니다.*
 - 노드도 prev, data, next를 갖는 객체일뿐이고, 꼬리물기처럼 연결된 노드를 순회해서 찾으면 된다는 것을 배웠습니다.
 - 이전엔 findIndex같은 함수로 찾거나, for문으로 배열의 인덱스를 순회하면서 찾았는데,
   currnetNode = currentNode.next로 찾는다는 개념이 생소하고 어색해서 그랬던 것 같습니다.

---

## 8. 해결하지 못한 문제 및 의문점 (선택)

*어제 제네릭을 제대로 이해하지 못하고 오늘을 맞이했는데, 제네릭을 통한 구현이 필요했다*
 - 이해 못한 개념은 확실하게 이해하고 넘어가야 할 필요성을 느꼈다. 
 > 주말을 이용해서 이해할 것.

*iterable, iterator : 그냥 쓰라는대로만 쓰고, 어떻게 동작하는지 정확하게 이해하지 못했다.*

*Symbol도 마찬가지. 고유한 객체라는 것은 알겠는데, iterator와 어떤 연관이 있는지, 실제 개발에선 어떻게 사용하는지 와닿지 않았다.*

*연결리스트는 데이터의 삽입/수정/삭제에서 유리하고, 탐색에 불리하다고 하는데, 결국 수정/삭제하려면 탐색을 해야하는 거 아닌가?*
