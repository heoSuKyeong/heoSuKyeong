# Daily Retrospective  
**작성자**: 허수경 <br>
**작성일시**: 2024-12-20(금)

## 1. 오늘 배운 내용 (필수)  
### Hash Dictionary
#### 해시개념 (Hash)
- 임의의 데이터를 특별한 알고리즘을 통해 `고유한 숫자로 매핑하는 함수`
- 매핑 전 데이터의 값을 `키(Key)`, 매핑 후 데이터의 값을 `해시 값(Hash Code)`, 매핑하는 과정을 `해싱(Hashing)`이라고 한다.
- 해시(Hash)는 데이터의 값을(Key) 고유한 숫자로(Hash Code) 만든 후 이를 내부적 배열인(Bucket)에 사용하기 때문에 빠른 검색 속도를 갖는다.
	- 배열 인덱싱 시 해시 값을 사용하는 구조이기 때문에 별도의 정렬 없이 데이터를 빠르게 찾거나 삽입이 가능하다.
	- 해시 값을 이용해 자료가 분산되므로 자료 전체를 *정렬하여 출력하고자 하는 작업에는 적합하지 않다.*

#### 해시 함수의 특징
- 함수의 결과물은 특정 길이의 숫자이므로, 해시 값을 가지고 원본 정보를 알기 어렵다.
예) “Hi” = 30, “Ecount” = 40, “World = 30 일 때 30 또는 40을 가지고 원본 값을 알기는 어렵다.
- 따라서 해시는 비밀번호, 전자서명, 전자투표와 같은 민감한 입력의 무결성을 검증해야 하는 보안 분야에서도 널리 사용한다.
- 단방향 함수의 특징을 가진다. 그래서 해시 충돌이 발생한다.
  
#### 간단한 해시 알고리즘 구현
```
public getHashCode(value: TValue): number {
  const json = JSON.stringify(value);
  //유니코드로 변환
  return json.split("").reduce((acc, cur) => acc + cur.charCodeAt(0), 0);
}
  
```
> 왜 JSON으로 변환하는가?
1. `객체의 비교 문제`:  JavaScript에서 객체는 참조값을 기준으로 비교된다. 같은 구조와 데이터를 가진 객체라도 참조값이 다르면 obj1 !== obj2로 평가되기 때문에 `JSON.stringify()`를 사용하여 객체를 문자열로 변환하면 객체의 데이터 값을 기반으로 비교할 수 있다.
2. `문자열 기반 해싱` : 객체를 JSON으로 변환하면 데이터를 일정한 포맷의 문자열로 바꿀 수 있다. 이를 통해 객체나 배열과 같은 복잡한 구조도 문자열로 표현할 수 있으므로 해싱 처리에 적합하다.
  
  
#### 해시 자료구조에서 버킷의 인덱스를 계산하는 방법
- 해시 자료구조에서 버킷의 인덱스는 데이터를 저장할 위치를 결정하기 위해 사용된다. 이는 해시 함수로부터 얻은 값을 기반으로 계산되며, 저장된 데이터에 빠르게 접근할 수 있는 핵심 원리 중 하나이다.
  
```
private getBucketIndex(key: TKey): number {
  const hashCode = this._comparer.getHashCode(key);

  return hashCode % this._bucketSize;
}
```  
#### 충돌방지와 회피
- 많은 키 값을 매핑하기 때문에 해시 충돌이 발생할 수 있다.
- 따라서 동일한 해시 값에 이미 데이터가 있다면 해당 데이터를 저장할 다른 위치가 필요하다.
- 해당 버킷에 데이터가 이미 있다면 체인처럼 노드를 추가하여 다음 노드를 가리키는 방식의 구현이 많이 사용된다.
- 한 버킷에 데이터가 쏠리는 현상을 방지하고자 버킷 사이즈를 소수로 설정하는 방법도 있다.

#### 재해싱(resizing)
- 재해싱이란?<br>
해시 테이블이 가득 차거나 특정 임계점(예: 125% 차지율)에 도달했을 때, 기존 테이블을 더 큰 크기의 테이블로 확장하고 모든 데이터를 새롭게 해싱하는 과정이다.
이 과정에서 버킷 크기를 변경하여 충돌을 줄이고 성능을 유지한다.
  
- 재해싱 과정
1) 기존 해시 테이블의 데이터를 순회하며 각 데이터를 새 버킷 크기에 따라 다시 해싱한다.
2) 새로 계산된 해시 값을 사용해 데이터를 새 위치로 이동시킨다.


---
## 2. 동기에게 도움 받은 내용 (필수)
- `민준`님께 오늗도 많은 도움을 받았습니다. 디버깅 중 변수 확인 방법과 이터레이터 내부에서 this가 잘못 바인딩되어 발생한 오류에 대해 문제점을 짚어주셨고, 동작 원리에 대해서도 상세히 설명해주셨습니다.
- `주원`님과 `연아`님과 함께 산책하며 서로의 고민을 나눌 수 있어 마음이 한결 가벼워졌습니다.

---
## 5. 해결 방안 및 배운 점 (선택)  
### Iterator의 this
- `this`가 메서드 호출 시점에 동적으로 결정되기 때문에 `Iterator`에서 `this`를 사용하지 못한다.
- 해결방법으로는 화살표 함수를 사용하여 `this`를 사용할 수 있는데 이는 화살표 함수 내부의 `this`는 선언 당시의 상위 컨텍스트(렉시컬 환경)에 묶이기 때문이다. 하지만 화살표 함수로 `this`를 고정하면 동적 바이딩인 불가능해져 의도한 유연성이 사라질 수 있어 지양해야한다.

- `Iterator`에서 `this`를 적절히 사용하려면 `실행 컨텍스트`와 `렉시컬 환경` 를 이해해야한다.
    - 실행 컨텍스트
        - 코드가 실행될 때 생성되는 환경.
        - `this`는 실행 컨텍스트에 따라 동적으로 결정됨.

    - 렉시컬 환경
        - 코드가 작성된 구조에 따라 변수와 함수가 참조되는 환경.

그래서 함수 내부에서 외부의 this 참조를 변수에 저장하여 사용하는 간접적인 바인딩 방법으로 문제를 해결할 수 있었다.
이를 통해 Iterator에서 this를 사용할 수 없는 문제를 해결하면서도 화살표 함수의 한계를 피할 수 있었다. 
```
[Symbol.iterator](): Iterator<KeyValuePair<TKey, TValue>> {
    let idx = -1;
    const temp = this;   // 간접적 바인딩

    return {
      next() {
        idx++;
        if (idx < temp._keyList.length) {
          let value = temp.findEntry(temp._keyList[idx]);
          if (value) {
            return {value, done: false};
          }
        }
        return {value: undefined, done: true};
      }
    }
  }
```
---
## 8. 해결하지 못한 문제 및 의문점 (선택)  
- 어제 해결해야겠다고한 타입(null, undefined, any...)에 대해 공부해보았다. 하지만 여전히 어떨 때 어떤 타입을 사용해야하는지 감이 잡히지 않는다. 다양한 예제를 살펴보며 공부를 더 해야겠다.