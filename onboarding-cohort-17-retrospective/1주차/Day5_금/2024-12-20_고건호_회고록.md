# Daily Retrospective

**작성자**: 고건호
**작성일시**: 2024-12-20

## 1. 오늘 배운 내용

JavaScript에 대한 학습은 TypeScript에 대한 학습 도중 익숙치 않은 개념이 나왔을 때 하기로 결정했습니다. 우선은 TypeScript에 대한 개념을 잡는 것이 나을 것 같다고 판단했습니다.

- 타입 별칭과 인터페이스
- TypeScript의 배열

#### 타입 별칭과 인터페이스

학습을 하며 타입 별칭과 인터페이스의 차이점에 대해서는 확실히 알 수 있었지만, 각각의 사용 시기(?)에 대해서는 명확히 이해가 가지 않았습니다.

핸드북에서도 둘은 매우 유사하며 대부분의 경우 둘 중 하나를 자유롭게 선택하여 사용하라고 명시되어 있었습니다.

따라서 확장이 필요할 것 같으면 인터페이스를, 그냥 선언해준 이후로 변하지 않을 것 같으면 타입 별칭을 사용하자는 스스로의 원칙을 세웠습니다.

실무와 관련하여 생각을 더 해보니 인터페이스의 병합 기능이 실무에서 어떻게 사용되는지 궁금하고 과연 이 병합 기능이 장점만 있는 것인지에 대한 의문도 들었습니다.

지난 번에 본부장님께 타입과 인터페이스 관련한 질문을 드린 적이 있는데, 그때 인터페이스가 중구난방으로 병합되어 확장되면 나중에 문제가 될 수도 있다는 말씀을 하셨던 것 같습니다.

그런 불상사를 막기 위해 네임 스페이스, 더 나아가서 중첩 네임 스페이스를 사용하는 것으로 알고 있는데, 극단적인 상황이긴 하지만 만약 이런 상황이 발생할 경우 인터페이스를 관리하는 것에도 많은 리소스가 투입될 것 같아 살짝 의문이 들기도 했습니다.

---

## 2. 동기에게 도움 받은 내용

송년회 장소까지 최현철 선임님께서 운전하시는 차를 탈 수 있었습니다. 선뜻 함께 차를 타고 갈 동기들을 찾는 최현철 선임님의 따뜻한 마음에 감동 받았습니다.
문득 전향자 선배님들이 계시지 않았다면 모르는 것 투성이인 제가 회사 생활에 잘 적응할 수 있었을지 의문이 들었습니다.
저도 전향자 선배님들께 좋은 사람으로 기억되고 싶으니 앞으로 더 노력하겠습니다.

---

## 5. 해결 방안 및 배운 점

HashDictionary의 이터레이터를 구현하며 일반 함수의 this 바인딩 문제를 화살표 함수를 사용하는 방식으로 해결했습니다.

```typescript
[Symbol.iterator](): Iterator<KeyValuePair<TKey, TValue>> {
    let index = 0;
    const keyList = this._keyList;

    return {
      next: (): IteratorResult<KeyValuePair<TKey, TValue>> => {
        if (index < keyList.length) {
          const key = keyList[index++];
          const entry = this.findEntry(key);
          if (entry) {
            return { value: entry, done: false };
          }
        }
        return { value: undefined, done: true };
      },
    };
  }
```

책과 핸드북을 통해 개념은 대충 알고 있었지만 백문이 불여일견이라고 직접 부딪혀보지 않는 이상 익숙해지지 않는다는 것을 깨달았습니다.

---

## 8. 해결하지 못한 문제 및 의문점

주말에 구현했던 자료구조들을 처음부터 다시 구현해보며 정리하는 시간을 가져보려 합니다. 수업 중간에는 시간 때문에 깊이 파보진 못했던 내부 구현 부분과 동작 방식을 살펴보면 TypeScript에 자연스럽게 적응할 수 있지 않을까 기대하고 있습니다.
