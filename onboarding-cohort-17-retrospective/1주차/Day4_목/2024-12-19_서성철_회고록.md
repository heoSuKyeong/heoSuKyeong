# Daily Retrospective  
**작성자**: [서성철]  
**작성일시**: [2024-12-19]  

---
## 1. 오늘 배운 내용 (필수)  

*양방향 연결리스트*
- prev, next를 알고 있어서 앞, 뒤 노드랑 연결 
- 노드를 삭제하는 방법 : 지울 노드의 next를 prev노드의 next로, 지울 노드의 prev를 next노드의 prev로.
  > 메모리 누수를 방지하기 위해 현재 노드의 next, prev를 null로 해준다.
  > 지울 노드의 data는 GC(Garbage Collection)에 의해 제거됨

*Stack*
- Last In, First Out
  > 프링글스
- 뒤로가기, undo등에서 사용
  > 이카운트에선 비즈니스 로직보다 코어쪽에서 많이 사용하는듯. (게시판 실행취소 정도?)
- 연결리스트를 거꾸로 뒤집으면 head쪽의 node부터 뺄 수 있다는 것도 알았다. 
  > 발상의 전환
- push and pop

*Queue*
- First In, First Out
  > 마트 계산줄
- 이카운트에선 카프카 이용하는 기능에서 쓰는듯. 일괄삭제, 원가생성 등등..
- push and shift

*Hash*
- key - value 형태로 저장
- key를 해시함수를 통해 해시값을 생성하고, 이를 이용해 데이터가 저장될 인덱스를 결정
- 접근이 빠름 
- 해시충돌이 일어날 수 있음
  > 해시충돌을 방지하는 방법은 체이닝 혹은 개방주소법

*소스 피드백*
- 타입단언은 사용하지 않는 것이 좋음
 > 타입단언 할 때, undefined/null도 나올 수 있음을 알려주거나, undefined나 null이 나오면 에러를 뱉도록
 > 결국 남이 볼 때 중요하다
- 함수를 콜 할땐 끝에 ()넣는 거 까먹지 말자. 안붙이면 그냥 함수까지만 접근하고 끝남

```typescript
private removeData(data: TValue): void {
    const targetNode = this.find(data);

    if (targetNode) {
      this.removeNode(targetNode);
    } else {
      return;
    }
  } // 이 코드는 되는데,  

private removeData(data: TValue): void {

    if (this.find(data)) {
      this.removeNode(this.find(data));
    } else {
      return;
    }
  } // 이 코드는 에러남
```
- 함수 호출할 땐 결과를 변수에 저장하자 : 효율성, 가독성, 안정성의 측면에서.
    : this.find(data)가 내부적으로 상태를 변경하는 함수라면, 두 번째 호출의 결과가 첫 번째 호출의 결과와 다를 수 있기 때문에, 에러를 뱉는다.
      > 타입스크립트는 똑똑해서, 두 번째 호출에서 null일 수 있는 가능성까지 감지한다.

---
## 2. 동기에게 도움 받은 내용 (필수)
(1) 아연님을 하루종일 괴롭히면서 많은 도움을 받았습니다. : linked list / type guard / comparer메서드 추적 방법 및 사용방법, 함수 재사용하는법
(2) 다은님께 제네릭에 관한 설명을 들었습니다. 원래는 제가 뭘 모르는지 몰랐는데 뭘 모르는지는 알 수 있을 때까지 끌어올려주셨습니다. 끝나고 남아서 해시설명도 해주셨습니다.
(3) 주현님이 또 작은 세미나를 열어주셨습니다. 동기, 비동기에 관해 설명해주셨습니다.
(4) 성재님이 해시 자료구조에 대해 설명해주셨습니다. 해시가 어떻게 동작하는지 감을 살짝 잡았습니다.
(5) 민준님께 private,public에 관한 설명을 들었습니다. this._tail을 그대로 가져다 쓰면 안되고, _linkedlist.last로 가져와야 한다는 사실을 알았을때 속이 시원했습니다.
(6) 수경님이 고질적인 문제인 커밋할때 맨끝 음절이 두 번 입력되는 문제를 해결해주셨습니다. 감사합니다다
(7) 건호, 도형, 성재, 주현님이 항상 동기방에 읽어보거나 공부해볼만한 자료들을 올려주십니다. 덕분에 주말에 심심하지 않을 것 같습니다.

---
## 3. 추가적인 궁금증 (선택)



---
## 4. 도전 과제 (선택)  

1. node를 알고 지운다고 했는데, node를 어떻게 아는지?
 - 연결리스트는 인덱스도 없고, 결국 node를 직접 알 수 있는 방법이 없지 않나?

2. 다은님의 설명으로 제네릭을 쓰면 확장성이 생긴다는 것을 이해했음. 그럼, 제네릭을 쓰는거랑 any를 쓰는거랑 뭐가 다른지?

3. 삽입, 수정, 삭제에 유리한 자료구조가 왜 필요한지?
 - 결국 모든 데이터는 DB에 있고, 삽입/수정/삭제는 쿼리가 해주는 거 같은데..
  > 조회에 유리한 자료구조만 있으면 되는 거 아닌가?

4. 연결리스트는 삽입/수정/삭제에 유리하고, 조회에 불리하다고 했는데, 결국 수정/삭제하려면 조회를 해야하는 거 아닌가?

5. 연결리스트에서 노드를 삭제하는건 slice나 pop처럼 실제로 노드를 삭제하는 것이 아니라, 삭제 대상인 노드의 앞/뒤 노드 포인터만 조정해주는 것.
   그렇다면, 갈 곳 잃은 삭제 대상 노드의 데이터는 그대로 남아있는 것 아닌가?    

6. GC(Garbage Collection)이 뭔지?


---
## 5. 해결 방안 및 배운 점 (선택)  

\\해결방법 : 재희님, 현우님께 질의 + 구글링 
 
1. 그래서 private함수. 함수 내에서만 접근할 수 있음
 - 내부에 있는 find 함수로 변수로 받은 data가 있는 노드를 찾아서 해당 노드를 삭제
 - 결국 node에 있는 데이터를 가지고 삭제하는 것임.

2. 사용성 측면 : 다른 개발자가 어떤 타입이 반환될 지 모른다
   메모리적 측면 : any를 쓰면 어떤 타입이 들어올 지 모르기 때문에 메모리를 최대한 잡아놓는다

3. DB에서 가져온 데이터를 클라이언트에 맞게 서버에서 가공해주려고 할 때 필요.

4. 비즈니스 로직에서도 배열의 인덱스를 바로 알아서 지우는 경우는 많지 않다. 대부분 sid같은 값으로 찾아서 삭제하는데,
   그렇게 되면 배열도 처음부터 순회하면서 수정/삭제 대상을 찾아야 하는 건 마찬가지. 
   따라서 연결리스트가 중간삽입 / 수정 / 삭제에서 가지는 이점만 남는다.
   >> 그럼 전부 다 연결리스트 쓰면 될 거 같은데, 배열을 쓰는 이유는? 메모리의 낭비 때문?

5. 참조 대상을 잃은 노드는 GC(Garbage Collection)가 정리해준다.

6. 메모리 관리를 자동화하는 프로세스, js에서는 런타임 시점에 자동으로 수행된다.
   


---
## 7. 오늘의 교육을 더 좋게 만들 수 있는 방법이 있었을까? (선택) 
회고록을 쓰면서 느낀 점 : 중요하진 않은데, 3,4,5,8의 역할이 살짝 중복되는 느낌이 있습니다.
> 어느 카테고리에 써야할지 고민이 되는 경우가 있음.
\\ 해결한 궁금증 : 해결방법까지
\\ 해결 못한 궁금증 
> 이렇게 두 개로 통합하는 건 어떨까요??

---
## 8. 해결하지 못한 문제 및 의문점 (선택)  

*as unknown과 any의 차이?*
 > 지금까지의 흐름으로 보면 any는 진짜 아무거나 막 쓸 수 있는거고, as unknown은 뭔가 제한을 걸긴 걸 거 같음.

*객체에서 데이터를 찾을 때, key를 알고 있으면 빨리 찾을 수 있다고 했는데, 해시를 사용하기 때문에 빠른건지? 아니면 그냥 key로 찾는게 빠른건지?*
 > 후자라면, 결국 전체 객체를 순회해야하기 때문에 빠르진 않은 거 같은데??

*해시값을 찾는 과정에서, key > 해시함수 > 나머지로 인덱스 할당 > 할당한 인덱스에 key-value를 연결리스트 형태로 저장(체이닝 기법을 사용할 경우) 까지 이해함*
 > 이 과정에서, 할당한 인덱스에 해당하는 key-value값은 어떻게 알 수 있는 건지?