# Daily Retrospective

**작성자**: [최현철]  
**작성일시**: [2024-12-19]

## 1. 오늘 배운 내용 (필수)

1.  Stack 자료구조

    1. 마지막에 들어간 것부터 꺼내서 쓴다.
    2. 넣기 : push / 빼기 : pop
    3. 엔진 콜스택처럼 코어쪽에서 많이 사용

    **getter 메소드**

    1. class 내에서 메소드명 앞에 "get" 을 붙여서 구현 / getter 메소드는 값을 반환
    2. 사용 시 메소드가 아닌 프로퍼티처럼 접근 가능
       > public get count() { return this.\_linkedList.count; } 선언해놓고 사용할 때에는 this.count로 호출하면 값 호출됨
    3. 2번 때문에 프로퍼티에 정의해두고, getter 메소드로도 정의해두면 해당 프로퍼티는 읽기전용 속성이 되는것임

    **setter 메소드**

    1.  메소드명 앞에 "set"을 붙여서 구현

        _그냥 "obj.property = 세팅할값"으로 설정 가능했었는데..? set없어도 왜 자동으로 됐었던건지 ?_

        > 객체 리터럴 (문자 그대로 직접친 객체)에서 정의된 프로퍼티는 `데이터 프로퍼티`로 처리됨

        > `데이터 프로퍼티`는 setter 메소드 없이도 엔진에서 알아서 처리해줌

        _데이터 프로퍼티 ? 프로퍼티의 종류가 뭐뭐있는지 ?_

        1. 데이터 프로퍼티 : 키-값 쌍 형태로 저장하는 객체의 일반적인 프로퍼티티

           > value : 값

           > writable : 값 변경 가능여부 (default : true)

           > enumerable : 열거 가능 여부 (default : true)

           > configurable : 속성 정의 변경 가능 여부 (default : true)

        2. 접근자 프로퍼티 : 값을 저장하지 않고, getter와 setter 매서드를 통해서만 값을 설정하고 가져오는 프로퍼티 = `_count`를 설정하기 위한 `count`

           > get : 값가져오는 getter 메소드

           > set : 값 설정하는 setter 메소드

           > enumerable : 열거 가능 여부 (default : true)

           > configurable : 속성 정의 변경 가능 여부 (default : true)

    2.  객체의 속성 초기화 할 때 값에 대한 유효성체크 OR 유효성체크 결과 로그찍는 등의 추가로직 가능
    3.  무한루프 주의
        > 보통 객체 내부에서 사용하는 프로퍼티에 언더바 붙여서 사용함. `_count`

2.  Queue 자료구조

    1. 선입선출
    2. 추가 `enqueue` / 빼기 `dequeue`

3.  Hash Dictionary 구조

    1.  Hashing이란 ? : 임의의 데이터를 고유한 임의의 값으로 변환해서 내부적 배열의 인덱스 값으로 변환해놓는 것

        > key : 변환하기 전 값 / Hash 값 : 변환된 후의 값 / bucket : 변환된 인덱스로 데이터가 들어가있는 내부 배열 / value : 버킷에 담김

        > **key값만 해싱해서 고유한 값으로 바꿔서 인덱스로 쓰는것일뿐 value는 어떠한 가공도 하지 않은채로 버킷에 그대로 담아둠**

    2.  굉장히 빠르게 탐색 가능 / 별도 정렬 불필요

    3.  기본적인 객체는 Hash 사용 x / Map 객체는 Hash 사용

    4.  해쉬값으로 역방향 추론 불가능 = 단방향 함수임

    5.  Hash 알고리즘 이해하기 1

        [1] public getHashCode(value: TValue): number {

        > value를 매개변수로 받음

        > Ex) value = { 이름 : "현철", 나이 : "31"}

        [2] const json = JSON.stringify(value);

        > value가 객체 일 수도 있으니 Json으로 변환 = JavaScript에서 객체 비교할 때 많이 쓰이는 방법

        > _`[1] === [1]`도 false로 나오니까 json으로 변환해서 비교해야 같은지 알 수 있음_

        > Ex) "{"이름":"현철","나이":"31"}"

        [3] return json.split("").reduce((acc, cur) => acc + cur.charCodeAt(0), 0);}

        1.  빈문자열로 json 변수값 나누기 = 문자열을 한글자씩 나눠서 배열에 담기
            > Ex) `["{", """, "이", "름", """, ":", """, "현", "철", """, ",", """, "나", "이", """, ":", """, "3", "1", """, "}"]`
        2.  배열을 순회하면서 누적값 계산

            > `reduce(callback, initialValue)` : 배열순회, 누적해서 단일 값으로 줄여줌

            > 순회하는 중 만나는 요소(currentValue, cur)를 charCodeAt하여누적값 (accumulator, acc)에 더해간다.

        3.  요소들을 charCodeAt(0)으로 변환 = 현재 요소 cur의 유니코드 값을 반환

            > 문자열.charCodeAt(Index) : 문자열의 index에 해당하는 문자 1개를 유니코드 값으로 변환

            > Ex) cur = "{" ㅁ > 123

            > charCodeAt은 문자 1개만 처리 가능함

        4.  결과적으로 모든 문자가 유니코드로 변환된 값들의 합 하나로 리턴됨
            > Ex) 302772

    6.  Hash 알고리즘 이해하기 2

        [1] `private getBucketIndex(key: TKey): number {`

        1. key를 매개변수로 입력하고 number를 리턴

        [2] `const hashCode = this._comparer.getHashCode(key);`

        1. 알고리즘1을 통해서 해쉬코드 생성

        [3] `return hashCode % this._bucketSize;}`

        1. 버킷의 사이즈가 3이면, 코드를 3으로 나눠서 나머지를 구함
           **나머지를 구하는게 왜 버킷의 인덱스임?**

           > 버킷의 크기 내에서 고르게 분포시키기 위함임

           > 결국 2번 인덱스에 value가 이미 들어가있는 상태에서 2번에 또 value가 들어갈 수 있음 그게 `해쉬충돌`

## 2. 동기에게 도움 받은 내용 (필수)

- 수경, 주원, 승준, 도형, 건호님과 함께 점심을 먹으면서, 개발본부의 면접 분위기 + 개발자 신입분들이 느끼는 회사분위기 등에 대해 들을 수 있어 새로운 것들을 많이 알게되었습니다.
- 디버깅해도 찾지 못했던 문제를 강민님께서 단번에 고쳐줘서 빠르게 문제를 찾아 고칠 수 있었습니다.👍
- 해시 자료구조에 대해서 이해안가는부분(버킷인덱스 구하기, 해시충돌)을 성재님께서 친절한 답변으로 해결해주셨습니다.

---

## 3. 추가적인 궁금증 (선택)

## 4. 도전 과제 (선택)

1. 양방향 연결 리스트에서 정의해뒀던 이터레이터를 스택 클래스로 어떻게 끌고와서 재활용하지 ... ?
   _양방향 연결리스트에서는 헤드부터 정방향으로 순회해야하고, 스택에서는 꼬리부터 역방향으로 순회해야하는데 ?_

---

## 5. 해결 방안 및 배운 점 (선택)

[GPT찬스]

1. 이터레이터를 만드는 메소드를 public으로 연결리스트에서 정의해두고 [Symbol.iterator]()에서는 해당 메소드로 만들어내도록

   > 이터레이터를 만들어내는 메소드에서 어떤 방향으로 순회할지에 대해 매개변수를 받아서 생성할 때 방향 지정할 수 있도록

   > Stack 방향 바꾸면서 필요없어짐 => 바로 `this._LinkedList.[Symbol.iterator]()`로 끌어다쓰면됨.

---

## 7. 오늘의 교육을 더 좋게 만들 수 있는 방법이 있었을까? (선택)

MS 오피스 사용이 익숙한데, 공부한 내용 정리할 때 리브레 오피스 사용이 불편합니다.
사용량이 많지 않을줄 알았는데, 생각보다 많이 쓰게되고, 추후 과제 발표자료를 만들 때에도 사용해야할 것 같아 MS오피스 인증해주시면 좋을 것 같습니다.
(설치는 되어있으나 인증키없어서 못씀)

---
