# Daily Retrospective  
**작성자**: 허수경 <br>
**작성일시**: 2024-12-19(목)

## 1. 오늘 배운 내용 (필수)  
### 2-1. Linked List (단방향)

#### 개념
- 노드(Node)가 데이터와 포인터를 가지고 연결되어 있는 자료 구조
#### 장점
- 선형리스트와 다르게 메모리상 연속된 위치에 데이터가 존재하지 않아도 된다. (크기가 유동적이다.)
- 삽입/삭제가 간단하다. (리스트 내에서 자료 조작이 필요하지 않다.)
#### 단점
- 접근 속도가 느리다. (나의 다음 순서만을 알고 있어 맨 처음 헤드부터 출발하여 순차적으로 탐색한다.)
- 포인터 사용으로 인한 공간 낭비가 있다.
- 알고리즘이 복잡하다.



### 2-2. Linked List (양방향)
#### 개념
- Doubly Linked List(양방향 연결 리스트)는 각 노드가 데이터와 함께 이전 노드(prev)와 다음 노드(next)에 대한 포인터를 가지는 자료 구조이다.
#### 장점
- 양방향으로 탐색이 가능하므로 특정 작업(예: 중간 노드 삭제 등)이 더 효율적이다.
- 단방향 리스트에서 발생하는 역방향 탐색 문제를 해결할 수 있다.
#### 단점
- 각 노드가 두 개의 포인터를 가지므로, 단방향 리스트에 비해 메모리 사용량이 많다.
포인터 관리가 복잡하여 구현 난이도가 높다.


#### 학습 포인트
1. 제네릭 클래스 구현을 통해 제네릭 문법에 대한 이해와 사용법을 학습한다.
- `제네릭(Generic)` : 타입에 의존하지 않는 재사용 가능한 클래스를 구현할 수 있도록 도와준다.  제네릭을 활용하여 타입 안정성과 유연성을 제공한다.
- 제네릭 클래스는 숫자, 문자열, 사용자 정의 객체 등 다양한 데이터 타입으로 사용할 수 있다.
- 사용법
	- `class LinkedNode<TValue>`: 제네릭 타입 선언.
	- `LinkedNode<TValue> | null`: 제네릭과 null 타입 혼합 사용할 수 있다..

```
// 제네릭 클래스 예시
//(숫자 리스트와 문자열 리스트를 각각 구현할 필요 없이 제네릭을 사용하면 한 클래스로 두 가지 리스트를 처리할 수 있다.)
const numberList = new SinglyLinkedList<number>();
numberList.addLast(1);
numberList.addLast(2);

const stringList = new SinglyLinkedList<string>();
stringList.addLast("A");
stringList.addLast("B");

```  
  
2. 단방향 연결리스트의 구현을 통해 값을 저장(보관)하는 노드의 개념과 포인터에 대해 학습한다.
3. 역방향 참조 발생시 어떤 점이 불편하며 또한 성능에 문제가 있는지 학습을 통해 인지하고 양방향 연결 리스트의 필요성을 이해한다.
- 단방향 연결리스트에서 중간이나 마지막 노드를 삭제할 때, 이전 노드의 정보를 추적할 수 없어 리스트를 처음부터 끝까지 탐색해야 한다. 이로 인해 성능 저하가 발생한다.
  - 예를 들어, 중간 노드를 삭제하려면 해당 노드의 이전 노드를 찾아 next 포인터를 수정해야 한다. 하지만 단방향 리스트에서는 이전 노드를 알 수 없으므로 리스트를 처음부터 끝까지 탐색해야 한다. 이는 시간 복잡도를 증가시키며, 성능에 부정적인 영향을 미친다.
  
- 단방향 리스트는 메모리 사용이 적지만, 특정 연산에서 성능 저하가 발생할 수 있다.
양방향 리스트는 삽입과 삭제가 빈번할 때나 양방향 탐색이 필요한 경우에 유리하다. 그러나 메모리 사용량이 더 많고, 추가적인 포인터 관리가 필요하다.
> 그럼, 삽입과 삭제가 빈번하게 일어난다면 무조건 양방향 리스트를 사용하는 것이 좋을까?
  <br><br>
메모리와 성능의 트레이드오프:<br>
단방향 리스트와 양방향 리스트는 사용 사례에 따른 성능과 메모리 사용량의 차이를 고려해 선택해야 한다. 삽입과 삭제가 빈번하게 일어나는 경우라면 양방향 리스트가 더 효율적일 수 있으며, 메모리 사용을 최소화하고자 한다면 단방향 리스트가 더 적합하다. 

## 3. Stack
#### 개념
- LIFO(Last In First Out) 형식의 자료구조
- 밑이 막힌 상자나 통에 쌓는 행위를 생각
#### 사용 예시
- 재귀 알고리즘, 웹 브라우저 방문기록, 실행취소(undo), 역순 문자열 만들기, 수식의 괄호 검사

## 4. Queue
#### 개념
- FIFO(First In First Out) 선입선출 구조의 자료구조
- Stack 과 반대개념의 자료구조
#### 사용 예시
- 우선순위가 같은 작업 예약(프린터 인쇄 대기열), 콜센터 고객 대기시간, 티켓 카운터

#### 학습포인트
1. 스택 자료구조의 이해와 구현을 통해 해당 자료구조의 필요성과 사용법을 학습
2. 큐 자료구조의 이해와 구현을 통해 해당 자료구조의 필요성과 사용법을 학습  
3. DoublyLinkedList(양방향 연결리스트)를 사용함으로써 코드 재사용에 대해 이해
	- Stack, Queue 배열이나 연결 리스트를 사용하여 구현할 수 있다.
	- 배열을 사용하면 삽입/삭제가 O(n) 시간이 걸릴 수 있지만, 연결 리스트(특히 양방향 연결리스트)를 사용하면 삽입과 삭제 연산이 **O(1)**로 매우 빠르다.
		(양방향 연결리스트는 두 방향으로 노드를 탐색할 수 있기 때문에 빠른 삽입/삭제를 지원한다.)
	- 그 외 Underflow 대해 `pop` 또는 `peek` 할 때에 스택이 비어있다면 `undefined`를 반환할 수 있도록 처리해주었다.

  
---
## 2. 동기에게 도움 받은 내용 (필수)
- `주현`님 코드를 읽으면서 타입스크립트의 강점인 타입 시스템을 적극적으로 활용하여 타입 안정성을 높이는 방법을 배우고, 추론에 의존하지 않는 코드로 발전해야겠다고 결심했습니다. 또한, 테스트 코드 작성 시 비동기 함수로 인해 의도치 않게 실행되는 문제를 수정하는 과정에서 콜백 함수에 대한 이해를 돕는 설명을 받았습니다.
- `성철`님께서 늘 저녁메뉴 주문과 결제를 진행해주셔 편하고 빠르게 저녁을 먹을 수 있었습니다.

---
## 3. 추가적인 궁금증 (선택)
1) 생성자의 선언
- 아래 코드를 보면 constructor가 총 3개가 작성되어 있다. 처음에는 왜 굳이 세 번째 생성자만 작성하면 충분한데, 여러 개의 생성자를 작성했을까 하는 의문이 들었다. 이에 대해 재희 선임님께 여쭤보니 첫 번째와 두 번째는 선언부에 해당하고, 세 번째는 구현부에 해당한다고 설명해 주셨다.
- 이는 자바스크립트에는 생성자 오버로딩이 없기 때문에, 타입스크립트에서 제공하는 문법을 사용한 것이다.
타입스크립트에서의 생성자 선언부는 메서드의 매개변수 조합을 명시하는 역할을 하며, 여러 개 작성할 수 있다. 반면, 구현부는 모든 선언부를 포괄하는 하나의 구현만 작성할 수 있다.
```
class LinkedNode<TValue> {
  prev: LinkedNode<TValue> | null = null;
  next: LinkedNode<TValue> | null = null;
  data: TValue;

  // 선언부
  constructor(data: TValue); 
  constructor(data: TValue, prevNode: LinkedNode<TValue>, nextNode: LinkedNode<TValue>);

  // 구현부
  constructor(data: TValue, prevNode: LinkedNode<TValue> | null = null, nextNode: LinkedNode<TValue> | null = null) {
    this.data = data;
    this.next = nextNode;
    this.prev = prevNode;
  }
}
```

2) 반환 타입과 타입 단언
- 메서드에서 타입 단언으로 선언한 객체를 반환을 해주면 에러를 발생시키지 않는다고 생각하여 명시하지 않고 타입 단언으로 undefined를 반환했다.
하지만, 이는 타입시스템에 맞지 않았다.
- version 1 의 경우) 반환 타입을 TValue로 명시했지만, 실제로는 undefined를 반환할 가능성이 있다. `undefined as TValue`는 타입 단언을 통해 컴파일러의 에러를 우회한 코드로, 사용자는 이 함수가 항상 TValue 타입을 반환한다고 착각할 수 있어서 런타임에서 예기치 못한 에러를 발생시킬 가능성이 높다.
- version 2 의 경우) 반환 타입으로 `TValue | undefined`를 명시하여, 이 함수가 두 가지 타입을 반환할 가능성이 있음을 사용자에게 명확히 알렸다. 이와 같이 의도를 명확히 전달하고 타입의 안정성을 지킬 수 있기 때문에 반환 타입을 명시해야한다.

> 타입 단언 ? <br>
`undefined as TValue`는 컴파일러에게 "이 값은 분명히 TValue 타입이다"라고 선언하는 것이다.
따라서 컴파일러는 이 코드에 대해 오류를 발생시키지 않지만, 런타임에서 undefined가 실제로 반환되면, 이를 처리하려는 코드에서 예상치 못한 에러를 일으킬 수 있다.
```
// version 1. (비권장)
public dequeue(): TValue {
  // TODO ...
  const result = this._linkedList.removeFirst();
  if (result !== null) {
    return result;
  }
  return undefined as TValue;
}

// version 2. (권장)
public dequeue(): TValue | undefined {
  // TODO ...
  const result = this._linkedList.removeFirst();
  if (result !== null) {
    return result;
  }
  return undefined;
}
```
---
## 4. 도전 과제 (선택)  
### 양방향 리스트와 단방향 리스트 성능 비교
- 단방향 연결 리스트(Singly Linked List)는 간단한 구조로 메모리를 적게 사용한다는 장점이 있지만, 삽입 및 삭제 연산에서 이전(prev) 노드 정보가 없어 성능이 저하되는 단점이 있다. 반면, 양방향 연결 리스트(Doubly Linked List)는 이전 노드 정보를 포함하고 있어 삽입 및 삭제 시 더 나은 성능을 기대할 수 있다
이러한 차이가 실제 성능에 얼마나 영향을 미치는지 확인하고자, 두 리스트에 각각 1000개의 데이터를 삽입한 뒤, 삽입/조회/삭제 연산에 걸리는 시간을 측정하는 코드를 작성하여 아래와 같은 결과를 얻었다.
```
Singly Linked List
- Add Time: 2.17 ms
- Find Time: 3.16 ms
- Remove Time: 2.14 ms

Doubly Linked List
- Add Time: 0.97 ms
- Find Time: 3.26 ms
- Remove Time: 0.11 ms
```
- 테스트는 랜덤 데이터를 삽입/조회/삭제하는 방식으로 수행되었으며, 실행할 때마다 결과 값은 조금씩 달라질 수 있다.  양방향 리스트는 삽입과 삭제 성능에서 단방향 리스트에 비해 명확히 우수한 성능을 보였다. 자료구조를 선택할 때 사용 사례에 따른 성능과 메모리 간의 트레이드오프를 신중히 고려해야 한다는 점을 다시 한번 느꼈다.

---
## 8. 해결하지 못한 문제 및 의문점 (선택)  
- 타입에 대한 이해가 아직 부족하다(any, null, undefined...) -> 내일(금)까지 찾아보도록 해야겠다.
- 5.0 프레임워크를 이해하는데 필요한 지식들(제네릭, 클래스, 인터페이스, 상속, 커맨드 패턴)에 대해 이해가 부족하여 실습을 해보면서 보충해야겠다.