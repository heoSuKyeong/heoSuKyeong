# Daily Retrospective

**작성자**: [김민준]  
**작성일시**: [2024-12-19]

## 1. 오늘 배운 내용

**스택**
- LIFO(Last In First Out)
    - 나중에 넣은 객체가 먼저 빠져나가는 구조.

- 구현
    - 동적배열을 이용해서 구현해도 문제가 없습니다.
        - 마지막 값만을 다루므로 메모리의 순서를 유지하는데 문제가 없습니다.
    - 링크드 리스트로 구현하는 것이 보편적이라 생각합니다.

- 사용 예시
    - JVM의 스택 메모리나 JS의 콜 스택이 대표적입니다.
    - 문서 편집기의 커서나 브라우저의 뒤/앞으로 가기도 사용할 수 있습니다.

**큐**
- FIFO(First In First Out)
    - 먼저 넣은 객체가 먼저 빠져나가는 구조

- 구현
    - 일반적인 배열로는 매우 비효율적인 자료구조가 될 수 있습니다.
        - 배열에 처음 데이터를 지우는 것은 매우 비효율적
    - 링크드리스트를 이용하여 구현하는 것이 효율적입니다.

- 사용 예시
    - Tomcat의 태스크 큐, JS의 태스크, 마이크로 태스크 큐
    - 대기열 등등...

**해쉬**
- 임의의 데이터를 특별한 알고리즘을 통해 고유한 숫자로 매핑하는 함수.
- 매핑 전 데이터 값을 `키`, 매핑 후 데이터 값을 `해시 값`, 매핑하는 과정을 `해싱`이라 합니다.

- 장점
    - 배열 인덱싱 시 해시 값을 사용하는 구조이기 때문에 별도의 정렬 없이 데이터를 빠르게 찾거나 삽입이 가능하다.

- 충돌방지와 회피
    - 많은 키 값을 매핑하기 때문에 해시 충돌이 발생할 수 있다.
    - 해당 버킷에 데이터가 이미 있다면 체인처럼 노드를 추가하여 다음 노드를 가리키는 방식의 구현이 사용됨
    - 한 버킷에 데이터가 쏠리는 현상을 방지하고자 버킷 사이즈를 소수로 설정한다.

**타입스크립트의 생성자**
- 타입스크립트의 생성자는 오버로딩이 되지 않아 단일 생성자를 구현 후 선언하는 방식을 사용하는 것을 알게 되었습니다.

## 2. 동기에게 도움 받은 내용

### 17기 화이팅!!

- **수경님**이 typescript 생성자에 대해 질문해주셨습니다. (잘모르는 내용이라 답변해드리지 못했지만 해결하시고 나서 친절하게 알려주셨습니다.)
- **성철님, 아연님, 승준님**이 지칠때 쯤에 3층에 같이 데리고 가주셨습니다.
- **동기분들**이 모여서 jest의 비동기 콜백에 대해서 의견을 나누시고 있는 것을 보고 콜백에 대해 다시 공부할 수 있어서 좋았습니다.
- **지은님, 다은님**이 vscode 한글 깨짐에 대해서 같이 찾아봐 주셨습니다.
- **건호님**이 책 pdf 파일을 공유해주셨습니다.
- **도형님**이 `iterable`에 대한 학습 링크를 알려주셨습니다.


## 3. 추가적인 궁금증 및 학습 후기

**궁금증**
- 저는 `Codeforces`라는 사이트를 통해 알고리즘을 풀어왔습니다. 다른 사람 풀이에 대해 데이터를 넣어 저격을 할 수 있는데(시간 초과, 잘못된 출력 등) 빈번하게 저격을 당하는 것이 **해쉬를 이용한 시간 초과 저격**이었습니다. 라이브러리의 해쉬 함수를 분석하여 **같은 해쉬 값**이 나오도록 하면 같은 해쉬 값의 버킷에 모든 데이터가 저장되어 사실상 링크드리스트 처럼 동작하게 하여 **한번의 연산 당** **`O(n)`** 이 되도록 하는 것입니다.
    - 이에 대해 유저들은 해쉬 함수를 최대한 쓰지 않으려고 노력합니다. 대안으로 해쉬 함수를 쓰더라도 해쉬 함수를 오버라이드하여 랜덤 해쉬 생성기를 만드는 것을 보았는데
    - **`실무에서는 신경써야될 정도의 문제인지 궁금합니다.`** 

**학습후기**
- 스택에 대해 공부하다보니 이번 공채 코딩테스트 2번 문제가 생각이 났습니다.
    - 하늘 다리를 만드는 문제였었는데 저는 **단조 스택**(Monotonic Stack)이라는 기법을 사용했었습니다.
    - 스택 내부의 데이터를 단조 감소/증가하게 하는 방법입니다.
    - 스택 내부에서 단조 감소하다가 스택의 마지막 값보다 큰 값이 나오면 단조 감소를 유지할 수 있게 스택에 있는 데이터를 삭제합니다.
        - 다음에 들어올 데이터가 이전 데이터보다 크다는 것은 이전 데이터로는 하늘다리를 만들 수 없음을 의미합니다.
        - `[100 50 20]` 스택에서 `30`이 들어온다는 말은 `20`은 하늘다리를 이을 수 없음을 의미합니다.
    - 시간 복잡도 `O(1)`의 강력한 기법이라 생각합니다
- 타입스크립트는 자바와 많이 다른점이 있는 것 같습니다. 
    - 단일 생성자
    - 덕 타입 언어
    - `null`, `undefined` 원시 값을 타입에 명시 해주어야함

## 4. 도전 과제

- 타입스크립트에 대한 학습이 부족한거 같다. 더 열심히 공부해보자!

## 5. 해결 방안 및 배운 점

- **재희 선임님**
    - `this.removeFirst()`, `this.removeLast()`를 메서드를 분리한 이유가 무엇인지에 대해서 질문하셨습니다.
        - 저는 구현코드를 분리하는 것이 가독성이 더 좋지 않을까 생각하여 분리하였습니다.
        - **답변**: 코드의 역할이 **노드를 지운다**라는 같은 역할을 가지고 있는데 굳이 나눌 필요가 있을까?
    - 위 말씀에 대해 같은 생각을 하고 코드를 수정했지만 만약에 `this.removeFirst()`나 `this.removeLast()`의 코드가 길어지더라도 한 메서드안에 모든 구현을 넣어야할까에 대해 재질문하였습니다.
        - **답변**: 코드가 길어지는 경우는 한 메서드안에 **많은 책임**이 있는 것이 아닌지 고민해볼 필요가 있다. **단일 책임**인데도 불구하고 코드가 길어지는 경우 분리하는 것도 생각해볼 수 있을거 같다. 정답은 없으니 다시 고민해보면 좋을거 같다. 
```typescript
private removeNode(node: LinkedNode<TValue>): void {
    if(this._count <= 0) {
      return;
    }

    this._count--;

    if (node === this._head) {
        this.removeFirst(); // 분리해야할까..?
    }

    if (node === this._tail) {
        this.removeLast();
    }

    let prevNode: LinkedNode<TValue> | null = node.prev;
    let nextNode: LinkedNode<TValue> | null = node.next

    if(prevNode != null && nextNode != null) {
      prevNode.next = nextNode;
      nextNode.prev = prevNode;
    }
  }
```

## 6. 오늘 느낀 개선점이 있다면?

- 현우 팀장님이 말씀하신 것처럼 학습 우선 순위를 바꿔야되지 않을까 하는 생각을 가지게 되었습니다. 

## 7. 오늘의 교육을 더 좋게 만들 수 있는 방법이 있었을까?

- 재희님 질문에 대해 친절하게 답변주셔서 감사합니다
- 현우님 회고록 피드백 감사합니다

## 8. 해결하지 못한 문제 및 의문점

- 어떤 것을 공부해야할지 방향을 잡을 필요가 있다.
- 동기들과 의견을 주고 받기위해 노력해봐야겠다.
- 코드 리뷰를 받으면서 `역할`에 대한 키워드에 대해 알게 되었고 앞으로 많은 고민이 필요합니다.