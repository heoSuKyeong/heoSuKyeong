# Daily Retrospective

**작성자**: [이지은]  
**작성일시**: [2025-01-02]

## 1. 오늘 배운 내용 (필수)

### 5.0 프레임워크 개념

#### 프레임워크

-   개발자가 개발을 할 수 있도록 준비된 환경
-   개발자가 개발을 할 수 있도록 준비된 표준/방법
-   개발자가 편하라고 미리 만들어둔 공통들

#### 프레임워크의 변화

-   프레임워크 1.0 : 공통화, 표준화 미흡, 개발 언어 asp
-   프레임워크 2.0 : 공통화, 표준화를 조금 높임, 개발 언어 asp.net(C#)
-   프레임워크 3.0 : 공통화, 표준화를 높임, 개발 언어 asp.net(C#), pipeLine(표준화)
-   프레임워크 4.0 : 공통화, 속성, 예외, 조건
-   프레임워크 5.0 : 공통화, 속성, 예외, 조건 -> 현재 5.0 개발중
-   프레임워크 10.0 : 공통화, 속성, 예외, 조건

=> 공통화, 표준화를 중요하게 생각 -> 버전이 올라갈수록 그 범위를 점점 넓혀가는 중이다. (공통화와 표준화는 모두 비용을 아끼기 위한 것.)

#### 비용 ?

-   개발의 생산성 (고민, 이해, 코딩, 설계...)
-   금전적 비용 -> 인건비 -> 즉, 개발 시간을 아껴야 함

#### 웹이라는 환경의 개발(시스템) 3요소

-   **클라이언트** (대표적으로 브라우저) -> 화면 개발이 필요함
    -   브라우저
    -   서버
    -   사용자가 직접적으로 사용하는 단말기
    -   엑셀(이카운트에서는)
-   **웹 서버** -> 기능 개발이 필요함
-   **DB 서버** -> DB에 대한 CRUD가 필요함

### 요구사항에 맞게 설계해보자.

---

요구사항

공지사항

-   제목, 내용, 공지 기간을 입력하고 조회할 수 있어야 한다.
-   공지 기간을 반드시 입력해야 한다. -> 공지기간을 입력하지 않으면 저장 못한다.
-   제목을 10글자만 입력할 수 있어야 한다. -> 10글자를 넘기면 저장 못한다.

숙제

-   제목, 내용, 과목을 입력하고 조회할 수 있어야 한다.
-   과목을 반드시 입력해야 한다. -> 과목을 입력하지 않으면 저장 못한다.
-   제목을 입력하지 않으면 과목명을 제목으로 자동으로 입력(저장)해준다. -> 값을 자동으로 채워준다.
-   제목은 20글자까지 입력할 수 있다. -> 20글자를 넘기면 저장 못한다.

---

Q. 위 요구사항을 브라우저 소스, 웹 서버 소스, DB 테이블 모두 하나만으로 구현하려면 어떤 방법으로 개발할 수 있을까?

A. DB에 여러 종류의 게시글을 올릴 때 필요한 칼럼을 모두 다 만든다. 그리고 데이터를 삽입할 때, 필요없는 칼럼은 null로 넣는다.

(1) 브라우저

-   브라우저에서 글을 작성하기 전에 공지사항, 숙제를 선택할 수 있도록 한다. (DB에 게시글 종류 칼럼을 추가)
-   게시글 종류를 선택한 것에 따라 작성 페이지에서 입력 받는 칼럼을 달라지게 보여준다.
-   공지사항, 숙제 각각 필수로 받아야 하는 칼럼들을 입력 받는다.
-   작성이 끝나면 작성(게시) 버튼을 누른다.

(2) 서버

2-1. 공지사항을 작성했다면 - 공지사항 제목이 10글자를 넘는지 확인, 제목이 무조건 있어야 함 - 공지기간(시작일, 종료일)이 있는지 확인
2-2. 숙제를 작성했다면 - 숙제 제목이 20글자를 넘는지 확인 - 과목명을 입력했는지 확인 (20글자 이내 -> 숙제제목이 없다면 과목명으로 대체해야 하기 때문에 제목과 같은 글자수 제한이 있어야 함) - 숙제 제목의 default 값을 과목명으로 해줌

위의 요구사항을 어기지 않는다면, 각 게시글에 필요 없는 칼럼들은 null 처리한 후 DB에 넣어준다.
조건을 어긴 경우에는 팝업으로 에러 메시지 출력해서 재입력 받는다.

### 5.0 프레임워크 용어

공지사항, 숙제 -> 업무 = bizz
공지사항 입력, 공지사항 조회, 숙제 입력, 숙제 조회 -> 메뉴 = menu
제목, 내용, 공지기간, 과목, 타입 -> 항목 = Prop
prop을 묶은 것(Props) -> data_model

#### bizz 업무

-   업무마다 업무의 목적이 있고 이에 따라 데이터의 구조, 처리 방법 등이 달라진다.
-   예) 판매, 견적, 구매 등

#### menu 메뉴

-   업무를 이용하기 위한 도구
-   하나의 업무 내 입력, 조회, 현황 등 다양한 메뉴가 있다. 또한 같은 메뉴 타입에서도 목적에 따라 여러 메뉴로 구분하여 특징이 다를 수 있다.
-   5.0에서는 중요한 지위를 부여하지 않고자 함
-   예) 판매입력, 판매조회 등

#### function 기능

-   하나의 기능이 상황에 따라서 처리 방법 등이 달라질 수 있다.

#### prop 항목

-   각 항목별 의미하는 정보가 다르며 이에 따라 표시하는 방법, 기능 등이 다르다.
-   예) 검색창 내 기준일자, 사용일자, 비용그룹, 비용, 거래처 등

#### sid

-   데이터를 특정하기 위한 우리만의 key를 통칭함 -> 고유한 id
-   데이터 구조를 통일시키기 위한 목적
-   예) bizz_sid, menu_sid, record_sid, data_sid, tenant_sid, user_sid

#### definition 명세서

-   공통 기능이 동작하기 위한 정보일 뿐, definition 자체가 기능을 가지지는 않는다.
-   prop_definition은 따로 없다. data_model_definition에 같이 적혀있다.
-   예) bizz_definition, menu_definition, data_model_definition

#### data_model 데이터 모델

-   같은 목적을 가진 여러 항목의 묶음으로 생각할 수 있다.
-   데이터 모델의 목적과 각 항목의 관계에 따라 처리하는 방법이 다르다.
-   data_model_template을 활용해, 메뉴 타입 별로 세분화됨
-   예) 재고싱글-입력, 재고싱글-조회, 재고싱글-조회서치 등

#### definition vs. attribute

-   definition = 정의 -> 한 번 정해지면 바뀌지 않는 것
-   attribute = 속성 = 설정 -> 바뀌게 되는 것

#### 5.0 프레임워크의 근간이 되는 컨셉

-   로직은 하나! 나머지는 설정으로 간다.
-   필요한 건 다 속성 테이블에 넣어놓고, 필요할 때 꺼내쓰도록 하자.

## 2. 동기에게 도움 받은 내용 (필수)

**다은님**: 5.0 개념이 중간중간 이해가 안됐는데 보충설명을 해주셨습니다. 감사합니다...

---

## 3. 개발 기술적으로 성장한 점 (선택)

### 1. 교육 과정 상 배운 내용이 아닌 개인적 호기심을 해결하기 위해 추가 공부한 내용

5.0 환경 설치 후, 네트워크 관련 이론 공부를 할 때 주신 키워드로 위주로 공부해봤다.

### 포트 번호

#### 포트 번호

-   서버에서 둘 이상의 사용자 프로세스가 동시에 TCP를 사용할 수 있다. 각 프로세스와 연관된 데이터를 식별하기 위해 포트 번호가 사용된다.

-   네트워크 상에서 통신을 할 떄 IP 주소를 바탕으로 해당 서버가 있는 컴퓨터에 접근하게 된다. 하나의 IP에서 여러 애플리케이션을 실행할 경우, 컴퓨터에는 여러 개의 서버가 실행하게 된다. 이때 포트 번호를 통해 대상 IP 기기의 특정 애플리케이션의 서버에 접속할 수 있도록 알려주어야 한다.

-   포트 번호는 16비트로 0 ~ 65,535까지 사용할 수 있다. 이 중에서 0 ~ 1023번 까지의 포트 번호는 주요 통신을 위한 규약에 따라 이미 정해져 있는 포트(well-known port)이다.

#### 자주 사용되는 포트 번호

| 번호 | 프로토콜 | 통신 프로토콜 | 설명                   |
| ---- | -------- | ------------- | ---------------------- |
| 80   | HTTP     | TCP           | 웹 서버 접속           |
| 443  | HTTPS    | TCP           | 웹 서버 접속(SSL)      |
| 110  | POP3     | TCP           | 메일 읽기              |
| 25   | SMTP     | TCP           | 메일 서버 간 메일 전송 |
| 22   | SSH      | TCP           | 컴퓨터 원격 로그인     |
| 53   | DNS      | UDP           | DNS 질의               |
| 123  | NTP      | TCP           | 시간 동기화            |
| 20   | FTP      | TCP           | 데이터 전송            |
| 21   | FTP      | TCP           | FTP 제어               |

### DNS

#### DNS(Domain Name System)이란?

-   DNS는 사용자에게 친숙한 도메인 이름을 컴퓨터가 네트워크에서 서로를 식별하는 데 사용하는 인터넷 프로토콜(IP) 주소로 변환하는 인터넷 표준 프로토콜의 구성 요소이다.

#### DNS 작동 과정

-   DNS의 모든 쿼리(DNS 요청이라고도 함)는 동일한 논리에 따라 IP 주소를 확인한다. 사용자가 URL을 입력하면 컴퓨터는 DNS 서버를 점진적으로 쿼리하여 사용자의 요청을 처리하는 데 적합한 정보 및 리소스 레코드를 찾는다. 이 프로세스는 DNS가 해당 도메인 연결된 권한 있는 DNS 서버에서 올바른 응답을 찾을 때까지 계속된다.

### localhost

#### localhost란?

-   localhost는 웹 응용 프로그램이나 웹 사이트에 로컬로 액세스하고 테스트하는 데 사용되는 컴퓨터의 루프백 네트워크 인터페이스를 나타낸다. 이를 통해 자신의 컴퓨터에서 웹 서버를 실행할 수 있으므로 인터넷 연결 없이도 프로젝트를 개발하고 테스트할 수 있다. localhost에 액세스하면 본질적으로 자신의 컴퓨터에 액세스하는 것이다.

#### localhost를 사용하는 이유

1. 테스트 및 개발을 위한 통제되고 격리된 환경을 제공하므로 라이브 버전에 영향을 주지 않고 애플리케이션을 실험할 수 있다.
2. 활성 인터넷 연결이 필요하지 않으므로 오프라인 개발이 편리하다.
3. 완료되지 않았거나 테스트되지 않은 코드를 프로덕션 서버에 배포하는 것과 관련된 위험이 줄어든다.

#### localhost와 127.0.0.1 사이에 차이점이 있는가?

localhost와 127.0.0.1에 액세스하는 것에는 실질적인 차이가 없다. 둘 다 컴퓨터의 루프백 IP 주소를 나타낸다. 그러나 일부 소프트웨어 또는 구성에서는 이를 다르게 취급하거나 다른 것보다 선호할 수 있다. 대부분의 사용 사례에서는 둘을 교대로 사용하여 로컬 웹 서버에 액세스 할 수 있다.

### URL 구성

```
[scheme]://[userinfo@]host[:port][/path][?query][#fragment]

# https://www.google.com:443/search?q=hello&hl=ko
```

-   프로토콜: https
-   호스트명: www.google.com
-   포트번호: 443
-   패스: /search
-   쿼리 파라미터: q=hello&hl=ko

#### scheme

-   주로 프로토콜(어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙) 사용
-   예) http, https, ftp 등
    -   http는 80번, https는 443번 포트를 주로 사용한다.
-   포트는 생략 가능하다.

#### userinfo

-   URL에 사용자 정보를 포함해서 인증한다.
-   요즘은 거의 사용하지 않는다.

#### host

-   호스트명
-   도메인명 또는 IP 주소를 직접 사용 가능하다.

#### port

-   접속 포트
-   일반적으로 생략 가능하다.
-   생략 시 http는 80, https는 443 포트 번호로 설정한다.

#### path

-   리소스 경로
-   계층적 구조로 구성된다.

#### query

-   query parameter, query string 등으로 불린다.
-   웹 서버에 제공하는 파라미터
-   문자 형태
-   key-value 형태
-   ?로 시작되며, &로 여러 개 추가 가능

#### fragment

-   http 내부 북마크 등에 사용한다.
-   웹문서 해시태그라고도 불린다.
-   서버에 전송하는 정보가 아니다.

### URL의 웹 브라우저 요청 흐름

1. DNS 서버를 조회해서 IP와 포트 정보를 받는다.
2. 정보를 토대로 HTTP 요청 메시지를 생성한다.
3. 서버에 HTTP 메시지를 전송한다.

    - 웹 브라우저의 SOCKET 라이브러리를 이용해서 TCP/IP 커넥션 연결을 요청한다.
    - 이전 단계에서 찾은 IP와 PORT정보를 가지고 SYN, SYN+ACK, ACK 과정(3 way handshake)을 통해 서버와 연결을 한다.
    - 연결이 성공되면 TCP/IP 4 계층으로 데이터를 전달한다.
    - HTTP 메시지를 포함한 TCP/IP 패킷 생성하여 서버로 전송하게 된다.

4. 서버는 패킷을 받으면 TCP/IP 패킷을 까고 HTTP 메시지를 가지고 해석한다.
5. 그 후 html 데이터를 포함한 응답 메시지를 만들어서 클라이언트에 반환한다.
6. 클라이언트에서는 응답 메시지를 받아 화면에 렌더링한다.

### Message Queue

> https://www.ibm.com/kr-ko/topics/message-queues

#### Message Queue란?

메시지 큐는 애플리케이션 간 데이터를 교환하기 위해 메시지를 임시로 저장하고 전달하는 비동기 메시징 시스템이다.

-   메시지는 큐에 저장되며, 수신 애플리케이션이 준비될 때까지 안전하게 대기한다.
-   네트워크 장애나 수신 애플리케이션의 문제에도 데이터 손실이 방지된다.

#### 주요 특징

1. 안정적인 메시지 전달
    - 메시지가 손실되지 않으며, 수신 애플리케이션에 한 번만 전달된다.
2. 비동기 통신
    - 프로세스가 중단되더라도 시스템이 계속 작동할 수 있다.
3. 다양한 배포 옵션
    - 클라우드, 물리적 장치, 메인프레임, 소프트웨어 등 다양한 환경에서 사용할 수 있다.

#### 장점

1. 안정성: 애플리케이션 간 중요한 메시지가 사라지지 않도록 보장.
2. 연결성: 메시지 암호화와 트랜잭션 지원으로 애플리케이션 개발 간소화.
3. 다양한 언어 지원: Java, Python, Node.js 등 여러 언어 및 프로토콜(MQTT, REST 등)과 호환.
4. 복원성: 특정 구성요소의 오류가 시스템 전체에 영향을 미치지 않도록 설계.
5. 보안 강화: 메시지 식별, 인증, 암호화를 통한 보안 제공.
6. 통합 기능: 파일 전송 등 부가 기능 제공으로 기존 프로토콜(예: FTP)을 대체.

### 미들웨어

#### 미들웨어란?

-   미들웨어(Middleware)는 소프트웨어와 소프트웨어 간의 연결을 돕는 중간 계층 소프트웨어다. 이를 통해 서로 다른 애플리케이션, 서비스, 또는 데이터베이스가 통신하고 협력할 수 있다.

-   역할:
    -   데이터 교환을 중개하거나 형식을 변환.
    -   메시지 큐잉, 로드 밸런싱, 트랜잭션 관리 등을 지원.
    -   서로 다른 기술 스택을 사용하는 시스템 간 상호 운용성을 높임.
-   예시:
    -   메시지 브로커(Kafka), 캐시 서버(Redis), API 게이트웨이, 데이터베이스 미들웨어 등이 있다.

#### Kafka(카프카)

-   Kafka는 분산 메시징 시스템 또는 스트리밍 플랫폼으로, 실시간 데이터 처리를 위해 설계되었다.
-   특징
    -   퍼블리셔-구독자 모델(Pub-Sub):
        -   데이터를 생성하는 프로듀서(Producer)가 데이터를 특정 토픽(Topic)에 보낸다.
        -   이 데이터를 구독(Subscribe)한 컨슈머(Consumer)가 수신한다.
    -   분산 시스템:
        -   데이터를 여러 서버(브로커)에 분산 저장하여 높은 가용성과 확장성을 제공한다.
    -   내구성:
        -   데이터가 디스크에 영구 저장되어 장애가 발생하더라도 데이터 손실 가능성이 낮음.
    -   실시간 스트리밍:
        -   실시간 이벤트 데이터 스트림을 처리하고 분석할 수 있음.
-   주요 용도
    -   실시간 데이터 분석 (예: 클릭스트림 데이터 분석)
    -   로그 및 이벤트 수집 (예: 서버 로그 모니터링)
    -   메시지 큐 (예: 비동기 통신)

#### Redis(레디스)

-   Redis는 인메모리 데이터 저장소로, 주로 빠른 데이터 액세스와 캐싱을 위해 사용됩니다.
    -   Redis = Remote Dictionary Server
-   특징
    1. 인메모리(In-memory):
        - 데이터를 메모리에 저장하므로 매우 빠른 읽기/쓰기 속도를 자랑.
    2. 데이터 구조:
        - 단순 키-값 저장소뿐만 아니라, 리스트, 세트, 해시, 정렬된 세트 등의 다양한 데이터 구조 지원.
    3. 분산 가능:
        - 클러스터링을 통해 대규모 데이터를 분산 처리 가능.
    4. 영속성:
        - 데이터를 메모리에 저장하지만 디스크에 주기적으로 스냅샷을 저장하여 데이터 영구성 제공.
-   주요 용도
    -   캐시:
        -   DB 질의 결과를 캐싱하여 성능 향상 (예: 사용자 세션 관리).
    -   메시지 큐:
        -   Pub-Sub 모델을 사용한 간단한 메시지 브로커로 활용 가능.
    -   데이터 카운팅:
        -   실시간 데이터 카운팅 및 통계 처리.
    -   분산 락:
        -   분산 환경에서의 데이터 동기화 처리.

### 3. 위 두 주제 중 미처 해결 못한 과제. 앞으로 공부해볼 내용.

1. **prop_id와 refer_type**

    prop_id와 refer_type이 각각 존재하는 이유에 대해 현철님이 질문을 하셨다. 이때 팀장님이 답변으로 "종속 관계가 생기는 것을 커플링이라고 부르며, 약속은 작을 수록 좋다. 그래서 prop_id와 refer_type이 겹칠 수 있지만 따로 따로 존재하고 있다."라고 답변해주셨다. 그런데 나는 refer_type 자체의 의도를 잘 이해를 못한 상태인 것 같다. 이 부분에 대해 다시 생각해봐야겠다.

    그런데 신입 교육 자료에 있는 이 표에서 항목, refer_type, prop_id가 모두 같은 값이 입력되어 있어서 더 의문이 되었다...

    | 항목           | data_type | 의미->refer_type | prop_id -> prop_sid |
    | -------------- | --------- | ---------------- | ------------------- |
    | 거래처         | 코드형    | 거래처           | 거래처              |
    | 품목           | 코드형    | 품목             | 품목                |
    | 추가항목코드형 | 코드형    | 추가항목코드형   | 추가항목코드형      |
    | 수량           | 숫자형    | 수량             | 수량                |
    | 단가           | 숫자형    | 단가             | 단가                |
    | 공급액         | 숫자형    | 공급액           | 공급액              |

    5.0 매뉴얼을 보고 생각해보면...

    - 항목 id (prop_id)
        - 항목의 id로 하나의 데이터 모델 내 값이 유일하다.
        - 데이터 모델의 데이터는 {[prop_id]:[value]} 형태로 구성되어 있다.
        - 여러 데이터 모델이 합쳐져서 하나의 모델을 이루는 경우, `$`으로 출처 데이터 모델을 나타낸다.
    - 의미 (refer_type)
        - 항목의 업무적인 의미를 뜻한다.
        - prop_id는 동적으로 바뀌기 때문에 항목의 의미에 따라 데이터를 다루는 경우 refer_type을 사용해야 한다.
        - 여러 업무의 definition을 조합하는 등 예외 상항이 아니라면, 1개의 data model 내에서 유일한 값을 가진다.

    => "prop_id는 동적으로 바뀌기 때문에 항목의 의미에 따라 데이터를 다루는 경우 refer_type을 사용해야 한다." => 이 부분이 두 개의 확실한 차이가 아닐까 함...

    그런데 prop_id가 동적으로 바뀐다는 사실도 왜인지 이해가 되지 않는 상태다. 열심히 공부해야겠다.

2. 지금 개념 강의를 들으면서 이카운트 erp 시스템과 연결되지 않아서 어려운 부분들이 있는거 같다. erp 시스템을 켜놓고 이 부분이 어떤 것에 해당하는지 생각해보는 시간을 가져야겠다.

---
