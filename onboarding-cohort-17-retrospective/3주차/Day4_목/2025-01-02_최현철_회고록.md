# Daily Retrospective

**작성자**: [최현철]  
**작성일시**: [2025-01-02]

## 1. 오늘 배운 내용 (필수)

### 공통화 실습

1단계. 명세에 있는 기능들의 공통점 도출하여 공통점별로 분류

2단계. 분류된 것들을 코딩 비슷하게 스케치

3단계. 공통화된 부분을 절차로 만들기

4단계. 절차 내에서 달라지는 부분 (변수여야 하는부분) 표기

5단계. 변수로 받아야하는 것들을 모아서 정리 (서류)

### 5.0 용어

1. Framework : 개발을 위해 미리 준비한 환경 / 표준 / 방법 / 공통

   - 1.0 : asp / 공통화, 표준화 미흡
   - 2.0 : asp.net (C#) / 공통, 표준화 개선
   - 3.0 : C# + pipeline / 공통, 표준화 개선
   - 4.0 : 공통화, 속성, 예외, 조건
   - 5.0 : 공통화, 속성, 예외, 조건
   - 10.0 : 공통화, 속성, 예외, 조건 - 이카운트의 꿈, 목표

2. 업무 bizz

3. 메뉴 menu

4. 데이터모델 data_model (반찬통) ??

5. 항목 props (반찬들)

6. sid (주민등록번호) : 특정 데이터를 나타내는 고유한 식별값

- 1~9 + A~W (32가지 경우의 수)의 15자리 - 32진수 15자리
- 웹서버에서 생성 (generate)
- id는 직접 손으로 작성
- Ex. bizz_sid / menu_sid / data_model_sid / prop_sid / attr_sid

7. 명세 definition (서류1, 등본) => ts에서 interface

- 한번 정해지면 바꿀 수 없음
- Ex. bizz_definition / menu_definition / data_model_definition
- prop_definition은 data_model_definition 안에 있음

8. 속성 attribute (attr) (서류2, 인적사항)

- 언제든 바꿀 수 있다.
- 기능이 동작할 때 영향을 준다.
- 모든 속성은 주인(owner)를 가진다.
- attr_sid는 관리단위마다 각각 다 다르게 고유하다.
- attr_id는 속성마다 동일하다.

9. 데이터타입 data_type

10. 레퍼타입 refer_type

- prop_id로 다되지만, 약속을 느슨하게 하기 위해서 의미를 구별하는 목적으로 refer_type으로 떼냈다.

## 2. 동기에게 도움 받은 내용 (필수)

네트워크 관련해서 개념이해가 잘 안되는 부분마다 강민님께 질문해서 이해하고 넘어갈 수 있었습니다.
누군지 모르는 마니또에게 마우스 손복받침대를 선물받아 손목이 편안해졌습니다.
선물보다도 제 감성에 잘맞는 정성스러운 편지를 받아 개발경험을 시작한 것에 대해 긍정적으로 편안한 마음을 가질 수 있게 되었습니다.

---

## 3. 개발 기술적으로 성장한 점 (선택)

### 1. 교육 과정 상 배운 내용이 아닌 개인적 호기심을 해결하기 위해 추가 공부한 내용 - 12/31 공부내용 이어서 정리

#### URL

1. URL 이란 ?

- 인터넷에서 특정 자원(파일, 웹페이지 등)을 그리키는 주소

2. URL의 기본 구성요소

- 프로토콜://호스트명(:포트)/경로(?쿼리문자열#프래그먼트)

  - 프로토콜 : 통신방법

  - 호스트명 : 자원이 있는 서버 주소

  - 포트 : 통신에 사용되는 번호, 생략 시 기본값 (HTTP = 80, HTTPS = 443)

  - 경로 : 서버 안에서 자원의 위치

  - 쿼리 문자열 : 추가 정보를 서버에 전달

  - 프래그먼트 : 웹페이지 내 특정 위치를 지정

#### URL의 웹 브라우저 요청 흐름

0.  사용자가 웹 브라우저에 URL을 입력

    - 브라우저가 입력된 URL을 기반으로 HTTP 요청을 준비

1.  브라우저가 DNS 서버에 도메인 이름 변환 요청

    - DNS 서버는 도메인 이름과 매칭되는 IP주소를 반환

          google.com -> 200.200.200.2

    - DNS 요청은 가벼운 데이터 전송이므로 UDP 프로토콜을 사용

2.  브라우저가 서버에 TCP/IP 연결 요청

    - IP 주소 + 포트 번호 활용해서 "3-way handshake"를 통해 대상 서버에게 TCP 연결 요청
    - 대상 서버는 요청 수락 + 브라우저와 연결 설정

3.  브라우저가 HTTP 요청 메시지를 서버에 전송

    - TCP 연결 성공 후 HTTP 프로토콜을 사용하여 대상 서버에게 요청 메시지 전송
    - 요청메시지 : 메서드 (GET, POST 등) + 요청 경로 (/entry/...)로 구성
    - 브라우저는 소켓 라이브러리를 통해 데이터를 전송

4.  서버가 브라우저에게 응답 메시지를 반환

    - 서버가 요청을 처리한 후 HTTP 응답 메시지를 브라우저에 반환 (HTML 코드, 이미지파일 등)
    - 응답 메세지 구성 : 상태코드 (200 OK, 400 Not Found) + 헤더 정보 + 본문 데이터

#### 네트워크 관련 용어정리

- DNS 서버 : 사람이 읽기 쉬운 도메인 이름을 컴퓨터가 처리할 수 있는 IP주소로 변환

- UDP / TCP 프로토콜 :

| **특성**             | **UDP**                        | **TCP**                                 |
| -------------------- | ------------------------------ | --------------------------------------- |
| **연결 방식**        | 데이터 전송 전 수신자와 연결 X | 데이터 연결 전 3-way handshake로 연결   |
| **데이터 전송 속도** | 빠름                           | 느림 (연결 설정 및 오류 검증 과정 포함) |
| **신뢰성**           | 낮음 (손실 데이터 재전송 없음) | 높음 (데이터 손실 시 재전송)            |
| **오류 복구**        | 없음                           | 있음                                    |
| **데이터 순서**      | 보장되지 않음                  | 보장 (패킷이 순서대로 도착)             |
| **사용 사례**        | 스트리밍, 게임(fps), VoIP      | 웹 브라우징, 이메일, 파일 전송          |

- 3-way handshake :

  - 브라우저(클라이언트)가 SYN(synchronize) 패킷을 서버로 보냄
  - 서버는 클라이언트의 요청을 수락 + SYN-ACK(acknowledge) 패킷을 클라이언트로 보냄
  - 클라이언트는 서버의 응답을 확인한 후 ACK 패킷을 다시 보냄

        클라이언트 : 들리니? ------------------ SYN
        서버 : 응 들려 / 너도 들려 ? ---------- SYN-ACK
        클라이언트 : 응 들려. 그럼 시작한다. --- ACK

- SYN 패킷 : "연결을 시작하고싶다" 라는 신호역할의 패킷

- ACK 패킷 : "잘 받았다, 계속말해" 라는 확인신호

- TCP / IP 4계층 모델 ??? --> 각각 다른계층임, 붙어있는줄;

  - 응용 계층 : HTTP/HTTPS 요청 데이터 생성
  - 전송 계층 : TCP 프로토콜을 사용하여 데이터를 패킷 단위로 분할
  - 인터넷 계층 : IP 프로토콜을 사용하여 목적지 주소로 패킷을 전송
  - 네트워크 액세스 계층 : 실제 네트워크를 통해 물리적으로 데이터를 전송

- 패킷

  1.  **패킷** 이란 ?

      - 네트워크에서 데이터를 전송하기 위해 작은 단위로 나눈 데이터 조각

  2.  패킷의 필요성

      1.  효율성

          - 한번에 모든 데이터를 전송할 수 없음 ??

            _\* 어떻길래 한번에는 못보내는지 ?_

                1) 네트워크는 MTU 제한이 있음
                * MTU (Maximum Transmission Unit) : 네트워크에서 한번에 전송할 수 있는 데이터의 최대 크기. 일반적인 이더넷의 MTU는 1500 바이트.

                2) 혼잡관리(독점아니고 동시다발적으로 ) / 에러 발생시 복구 쉽게 (해당 패킷만 재전송)

          - 작은 크기로 쪼개서 전송하면 네트워크를 더 효율적으로 사용할 수 있음 ??

            _\* 작으면 왜 효율적 ? 빈공간 더 촘촘히 매울 수 있어서 ?_

                1) 나눠진 패킷을 병렬로 보낼 수 있어서
                2) '네트워크 자원'을 공평하게 분배할 수 있어서
                3) 손실패킷만 재전송 가능

                * 네트워크 자원이란?

      2.  에러처리 및 손실복구 : 일부 손실되면 손실된 패킷만 재전송하면됨

      3.  경로 선택

          - 각 패킷이 서로 다른 경로를 통해 전송될 수 있음
          - 최적의 경로를 선택해 전송 속도를 높일 수 있음 ??

          _\* 패킷의 경로 개념이 뭔지?_

              패킷이 출발지에서 목적지까지 이동하는 동안 거치는 네트워크 장비 (라우터, 스위치)와 링크 (케이블, 무선)을 의미

              네트워크는 여러 라우터와 네트워크 링크가 연결된 복잡한 구조로 이루어짐.
              라우터 : 최적의 경로를 선택해주는 역할 (트래픽, 물리적거리, 장애여부 통해 판단)

  3.  패킷의 구성요소 : 헤더 + 페이로드 + 트레일러

      1. 헤더 : 패킷 시작부분, 데이터 전송에 필요한 정보들

         - 출발지 주소 : 보낸 곳의 IP 주소
         - 목적지 주소 : 받을 곳의 IP주소
         - 프로토콜 정보 : 전송방식이 뭔지 (UDP, TCP 등)
         - 시퀀스 번호 : 내가 몇번째 조각인지

      2. 페이로드 : 실제 전송하려는 데이터 내용

      3. 트레일러 : 데이터 전송이 끝났음을 알리는 정보 + 오류 검출 코드 ??

  4.  패킷의 전송 과정

      1.  분할 : 큰 데이터를 작은 패킷 단위로 분할 (TCP계층)

              "Hello, World!" -> "Hel" "lo," "World!"

      2.  전송 : 네트워크를 통해 목적지로 전송
      3.  재조립 : 목적지 도착 후 순서(시퀀스 번호)대로 조립

              패킷2 > 패킷1 > 패킷3으로 도착 -> 패킷1 패킷2 패킷3 으로 조립

  5.  패킷의 특징

      1. 작은 단위의 데이터
      2. 다양한 경로 ??
      3. 각 패킷은 독립적, 목적지에서 다시 조립

- 소켓 : 브라우저와 서버 간 데이터를 주고받는 통로

#### URL의 웹 브라우저 요청 흐름 - 용어 공부 후 재정리

0.  사용자가 URL 입력

1.  [클라이언트] DNS 서버에 도메인 이름 변환 요청
2.  [DNS] 변환된 IP주소 반환
3.  [클라이언트] TCP/IP 연결 요청 (3-way handshake)
4.  [클라이언트] HTTP 요청 메세지 생성 + 운영체제의 네트워크 스택으로 전달
5.  [TCP계층] 브라우저에서 전달받은 데이터를 MTU에 맞게 세그먼트로 분할 (패킷아님, 아직 "세그먼트")
6.  [TCP계층] 각 세그먼트에 TCP 헤더 추가 (위 용어정리에 헤더 구성 참고)
7.  [IP계층] 세그먼트에 IP 헤더 추가

    _\* TCP 헤더 / IP 헤더 ? TCP에서 헤더 이미 넣었는데 IP에서 헤더 왜 또 넣음_

    | **특성**      | **TCP 헤더**                     | **IP 헤더**                              |
    | ------------- | -------------------------------- | ---------------------------------------- |
    | **위치**      | 전송 계층                        | 인터넷 계층                              |
    | **주요 역할** | 데이터 순서 및 신뢰성 보장       | 데이터의 네트워크 전달 및 경로 선택      |
    | **주요 필드** | 포트 번호, 시퀀스 번호, ACK 번호 | 출발지 IP 주소, 목적지 IP 주소, 'TTL'    |
    | **적용 범위** | 송신자 ↔ 수신자(종단 간 통신)    | 경로 상의 모든 네트워크 장비(Hop-to-Hop) |

    - TTL (Time To Live) : 패킷이 네트워크를 통과할 수 있는 최대 Hop 수

8.  [IP계층] 세그먼트가 MTU보다 큰 경우 IP 계층에서 새로 조각화

    _\* 처음 분할할 때 MTU에 맞게 분할했는데, 왜 더 클 수 있는지?_

        MTU의 차이가 나기 떄문
        > TCP계층에서는 송신자의 MTU 크기에 맞춰서 세그먼트를 나눔
        > 실제 전송되면서 경유하는 네트워크 장치나 링크의 MTU가 더 작은 경우가 있을 수 있음
        > 위 경우 해당 네트워크 장치의 IP계층에서 MTU에 맞게 다시 조각화(세그먼트화) 실행

        ** TCP 계층은 각 종착지, 송신자 / 수신자의 운영체제 안에 있음 (End to End)
        ** IP계층은 각 종착지뿐만 아니라 중간 네트워크 장치(라우터 등)에 모두 존재함 (Hop to Hop)

9.  [네트워크인터페이스] 패킷을 네트워크를 통해 실제 전송

### 3. 위 두 주제 중 미처 해결 못한 과제. 앞으로 공부해볼 내용.

1. 위에서 더 파고들지 않았던 개념

   - 소켓 라이브러리 ?
   - 운영체제의 네트워크 스택 ?
   - 네트워크 자원 (라우터 등) 상세

2. 이해한 개념들을 나중에 다시 찾아볼 수 있도록 UML등의 그림으로 다시그리기

   - 처리위치 분류
     - 대분류 : 송신자 / 중간(네트워크 장비 + 링크) / 수신자
     - 중분류 : TCP 계층 / IP 계층 / 운영체제? / 라우터 / ... 등
   - 처리위치 별 데이터 상태
     - 세그먼트
     - 패킷 + TCP 헤더
     - 패킷 + TCP 헤더 + IP 헤더
     - 재분할 등등

---

## 4. 소프트 스킬면에서 성장한 점 (선택)

지식을 공부할 때 이해되지 않는 단어를 찾아보는 것만으로도 해당 지식을 더 깊이있게 알 수 있다는 것을 꺠달았습니다.
하지만 문장이 단어를 찾게하고, 단어를 찾다보니 문장에 또 모르는 단어가 있어서 계속 파고들기는 조금 지치는 것 같습니다.

---
