# Daily Retrospective

**작성자**: 허수경 <br>
**작성일시**: 2025-01-02

## 1. 오늘 배운 내용 (필수)

- Framework 5.0의 개념
- Framework 5.0의 용어

### 프레임웍(Framework) 이란

---

- 개발자가 개발을 할 수 있도록 준비된 환경
- 개발자가 개발을 할 수 있도록 준비된 표준(방법)

### 프레임웍 5.0 이란

---

| Version       | 별칭       | 철학                                                                            |
| ------------- | ---------- | ------------------------------------------------------------------------------- |
| 프레임웍 1.0  | 구프레임웍 | 공통화, 표준화가 미흡 / asp를 사용                                              |
| 프레임웍 2.0  | 2          | 1.0에서 부족했던 공통화&표준화를 높이는 것에 집중 / asp -> asp.net(C#)으로 변경 |
| 프레임웍 3.0  | 3          | 공통화,표준화 집중 / asp.net(C#), pipeLine(표준화)                              |
| 프레임웍 4.0  | 4          | 공통화, 속성, 예외, 조건                                                        |
| 프레임웍 5.0  | 5          | 공통화, 속성, 예외, 조건                                                        |
| 프레임웍 10.0 | 10         | 공통화, 속성, 예외, 조건                                                        |

- 프레임웍 1.0 부터 10.0까지 철학을 살펴보면 `공통화`와 `표준화`에 집중을 두었다. 버전의 발전에 따라 적용범위를 넓혀가고 있다.

### 5.0의 목표

---

- 개발의 비용을 줄이는 것

#### 비용에는 무엇이 있을까?

- 개발의 생산성: 코드를 고민하고 이해하고 코딩하는 비용
- 인건비 :개발 시간을 아껴야함

#### 웹 환경에서의 개발

- 웹의 3요소는 클라이언트, 웹서버, DB서버로 구성
- 어떻게하면 3요소 별로 개발하는 시간을 아낄 수 있을까?

### 코드 공동화

- 어떤 기능을 요구하더라도 절차는 같지만, 각 방안에서 구현 방식을 다르게 한다.

#### 1. UI

- 방안1) 각 카테고리별로 HTML 파일을 개별 작성.
- 방안2) 모든 항목을 그린 뒤, 조건에 따라 특정 UI를 감추는 방식.

```
if (user.등급 > 5) {
	return;
}
hide(서류.감출대상);
```

#### 2. 서버 <br>

- 방안1) 공지사항과 숙제별로 조건문을 작성해 각각의 로직 구현.
- 방안2) 카테고리별 설정을 사용해 공통화된 로직을 적용.
- 공통 로직으로 코드 수정 빈도가 감소한다.
- 새로운 게시판 유형 추가 시, 설정만 변경하면 처리 가능하다.

```
if (서류.게시판유형 == "회고록") {
	//저장가능해
}

if (length(서류.대상) > 서류.자리수) {
	// 저장 못함
}
```

#### 3. DB

- 방안1) 공지사항과 숙제 테이블을 각각 생성.
- 방안2) 단일 게시판 테이블을 생성하여 공통 컬럼으로 관리.
- 단일 테이블로 데이터를 관리하므로, 새로운 게시판 추가 시 쿼리를 수정할 필요가 없다.

| 제목         | 내용      | 공지기간               | 과목 |
| ------------ | --------- | ---------------------- | ---- |
| 새해공지사항 | 감기 조심 | 2025/01/01 ~2025-02-28 | null |
| 개념교육수게 | ....      | null                   | 개념 |

```
insert 게시판테이블(제목, 내용, 공지기간, 과목, 타입)
values (@제목, @내용, @공지기간, @과목, @타입);
```

### Framework 5.0 용어

---

#### 1. 업무 (bizz)

- 공지사항, 숙제 등과 같은 단위

#### 2. 메뉴 (menu)

- 입력, 조회 등

#### 3. 항목 (prop)

- 제목, 내용, 공지기간, 과목, 타입 등 업무에 필요한 데이터 필드

#### 4. 데이터모델 (data_model)

- 항목(prop)을 담는 반찬통 역할(전체적인 구조)

#### 5. 서류 (definiton)

- 업무, 메뉴 등을 정의하는 등본 역할
- 인터페이스로 구현한다.
- 업무에 필요한 등본: `bizz_definiton`
- 메뉴에 필요한 등본: `menu_definition`
- 데이터모델에 필요한 등본: `data_model_definition`
- 항목에 필요한 등본: `prop_definition` (X, 존재하지않음 왜냐 데이터모델이 있으니깐)

#### 6. 고유한ID (sid)

- 중복되지 않는 고유 식별자
- defintion 안에는 sid가 있다.
- bizz_sid, menu_sid, data_model_sid, prop_sid

- **SID의 특징**

1. 숫자 1~9, A~W의 조합 15자리의 문자
2. 웹서버에서 만들어 내어(generate) 의미를 알 수 없다.

- **ID의 특징**

1. notice, homework와 같이 사람이 작성한다.
   <br>

**SID와 ID 비교**:
| - | sid | id | 이름 |
| ---- | --------------- | -------------- | -------- |
| bizz | 54f1345623546fe | notice | 공지사항 |
| bizz | 54f1345623546fa | homework | 숙제 |
| menu | 54f1345623546fw | notice_input | 입력 |
| menu | 54f1345623546ft | notice_list | 조회 |
| menu | 54f1345623546fy | homework_input | 입력 |
| menu | 54f1345623546fn | homework_list | 조회 |

#### 7. 속성 (attribute / attr)

- 필수 항목 설정
- 언제든 바뀔수 있고 기능이 동작할 때 영향을 미친다.
- **속성 예시**:

1. 자릿수 속성 > 해당 속성에 자리수 체크가 이루어져야한다.
   - attr_sid: 자리수
   - attr_id = max_length
2. 필수 입력 속성 > 해당 속성에 필수체크가 이루어져야한다.

| owner1   | owner2   | attr_sid | attr_id    | value            |
| -------- | -------- | -------- | ---------- | ---------------- |
| 공지사항 | 제목     | 1        | max_length | 10               |
| 숙제     | 제목     | 2        | max_length | 20               |
| 공지사항 | 공지기간 | 3        | not_null   | true             |
| 숙제     | 내용     | 4        | max_length | 1000             |
| 숙제     | 제목     | 5        | 채우기     | 같이 입력된 제목 |

#### 8. refer_type

- `prop_definition`은 없지만 데이터모델에 정의되어 있다. (?)
- **예시: 공지사항**

  | prop     | prop_sid | prop_id  | data_type | refer_type(의미) |
  | -------- | -------- | -------- | --------- | ---------------- |
  | 제목     | 1        | title    | 문자      | title            |
  | 내용     | 2        | content  | 문자      | content          |
  | 공지기한 | 3        | limit_dt | 날짜      | limit_dt         |

- **예시: 숙제**

  | prop | prop_sid | prop_id | data_type | refer_type(의미) |
  | ---- | -------- | ------- | --------- | ---------------- |
  | 제목 | 1        | subject | 문자      | title            |
  | 내용 | 2        | content | 문자      | content          |
  | 과목 | 3        | class   | 날짜      | class            |

  -> 공지사항과 숙제는 동일한 역할(예: 제목)을 가지지만 `prop_id`가 다를 수 있다. 이를 `refer_type`으로 통일하여 역할을 명확히 정의하고 관리 효율성을 높인다.

### 기능 요구사항

- 공지사항의 제목은 최대 입력 가능한 자리수가 10자리이다.
- 숙제의 제목은 최대 입력 가능한 자리수가 20자리이다.
- 숙제의 내용은 최대 입력 가능한 자리수가 1000자리이다.

#### 이카운트 용어로 생각해보기

- 공지사항, 숙제 = bizz(업무)
- 자리수 = attribute(속성)
- 제목 = prop(항목)
- 10, 20 = 속성값

```
자리수체크(prop) {
	if (bizz_definition.bizz_sid == "980427-00000000") {
		// 저장 가능해
	}

	// 공지사항의 제목의 자리수를 알아야
	// 자리수라는 것은 attr_id = max_length
	// var 자리수: number = attr.getValue({공지사항, 제목}, "max_length")
	var 자리수: number = attr.getValue({prop.bizz_sid, prop.prop_sid}, "max_length")

	// var data = data_model.getValue("제목-개념교육숙제");
	var data = data_model.getValueByReferType(prop.refer_type);

	if (length(data) > 자리수) {
			//저장 못함
	}
}
```

- 어떤 것을 검사하는지 고정되지 않았음 (현재 목표하고 있는 5.0의 방식)
- 자리수 체크 전용이 아닌 모든 조건의 체크 메소드를 만들 수 있나? (이것을 구현하는 것이 10.0 의 목표)

## 2. 동기에게 도움 받은 내용 (필수)

- 매일 주원님과 점심 산책을 하며 즐겁고 유쾌한 대화를 나눌 수 있어 감사했습니다.
- 현철님께 프레임워크 용어에 대한 관련 자료를 받아 이해하는데 큰 도움이 되었습니다.
- 성철님께서 선물받으신 케이크를 나눠주셔서 아연님, 민준님, 주원님과 함께 스윗한 간식 시간을 보낼 수 있었습니다.
- 코감기에 걸려었는데 마니또에게 가습기를 선물받아 아주 큰 도움이 되었습니다. 선물해주신 마니또님과, 마니또 행사를 준비하고 진행해주신 분들께 감사드립니다.

---

## 3. 개발 기술적으로 성장한 점 (선택)

### 1. 교육 과정 상 배운 내용이 아닌 개인적 호기심을 해결하기 위해 추가 공부한 내용

#### 서버 분산이 DB 부하에 미치는 영향

월요일에 '서버 분산에 따른 DB의 성능 영향'에 대해 궁금했었다.
이에 주현님께 도움을 받았다.<br>
**서버를 분산시키면, 각 서버가 요청을 처리한 뒤 DB로 전송하는 쿼리의 양을 최적화할 수 있다.
특히, 서버에서 미리 계산하거나 캐싱을 활용하여 DB로 전달하는 작업을 줄이면 DB 부하를 어느 정도 완화할 수 있다.**<br>
그러나 서버 부하 분산은 DB로 향하는 요청을 줄이거나 최적화하는 데 도움을 줄 수 있지만, DB 부하 자체를 완전히 해결하지는 못한다.<br>
DB 부하를 효과적으로 분산시키기 위해서는 캐싱, 읽기/쓰기 분리, 샤딩, 파티셔닝과 같은 기술을 상황에 맞게 적용해야 한다.<br>
DB 성능 최적화를 위해 많이 사용되는 방법 중 하나는 읽기/쓰기 분리이며 Replication 구성으로 분리한다.
쓰기 요청은 Master 서버에서 처리하고, 읽기 요청은 복제된 Replica 서버에서 처리한다.
데이터를 동기화하기 위해 Master 서버는 변경 내용을 바이너리 로그(Binary Log) 형식으로 Replica 서버에 전송한다.
DB는 기본적으로 Read 작업에서 자원 소모가 많기 때문에 Read작업이 많아 성능 이슈가 발생한다면 경우 가장 먼저 고려해볼 전략이다.
하지만 master의 복사본을 사용하기에 데이터 정합성을 보장할 수 없다는 치명적인 단점이 있다.

### 3. 위 두 주제 중 미처 해결 못한 과제. 앞으로 공부해볼 내용.

#### prop_definition과 data_model_definition의 관계

- 데이터모델은 항목(prop)을 담는 컨테이너 역할을 하며, 여러 개의 항목이 데이터모델에서 참조된다고 이해했다.
  하지만 인터페이스 정의를 살펴보니, 단순히 데이터모델이 항목을 참조하는 구조가 아니라, 항목도 데이터모델을 참조하는 양방향 관계를 가지고 있다는 점을 발견했다.
  이로 인해, 왜 이러한 양방향 참조 관계가 필요한지 의문이 생겼다.

```
// prop_definition
export interface IPropDefinition extends IPropIdentifier, IReadOnlyPropDefinition {
	data_model_id?: string;
	prop_id: $$prop_id;
	// 생략
}

// data_model_definition
export interface IDataModelDefinition
	extends IReadOnlyDataModelDefinition<IPropDefinition, IAttribute>,
		IDataModelIdentifier {
	data_model_id: string;
	props: IPropDefinition[];
	attributes?: IAttribute[];
	data_model_name?: string;
	data_model_name_code?: $$resx;
	entity_resolver_id?: string;
	prop_group?: { [prop_group: string]: IPropertyGroup };
}

```

- 그외 `attribute` - `onwer`에 대한 이해가 부족하다.
