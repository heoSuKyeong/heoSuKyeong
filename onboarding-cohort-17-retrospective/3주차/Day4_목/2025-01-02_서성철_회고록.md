# Daily Retrospective  
**작성자**: [서성철]  
**작성일시**: [2025-01-02]  

## 1. 오늘 배운 내용 (필수)  

1. 5.0의 목표와 방향성

    *FrameWork*
    - 개발자가 개발을 할 수 있도록 만들어둔 환경
    - 개발자가 개발을 할 수 있도록 준비된 표준 
    - 개발자가 개발을 편하게 할 수 있도록 미리 만들어둔 공통 

    *Ecount FrameWork*
    - 1.0(구 프레임웍) : 공통화, 표준화 미흡
    - 2.0 : 공통화, 표준화 높힘
    - 3.0 : 공통화, 표준화 높힘. pipeLine(표준화)
    - 5.0 : 공통화, 속성, 예외, 조건
    - 10.0 : 5.0 고도화. 기능을 레고단위로 만들어서 고객이 직접 조립할 수 있도록.
        > 결국 이카운트가 나아가는 개발방향은 공통화, 표준화다. 얼마나 심화하느냐에 따른 차이만 있을뿐.
    
    *게시판마다 다르게 구현해야할 때, 공통화라는 가치를 유지하면서 어떻게 다름을 구현할 수 있을지?*
    - 요구사항 
        1) 브라우저, 웹서버, DB테이블은 하나로
        2) 공지사항 게시판 : 제목(10글자까지), 내용, 기한(필수값)
        3) 숙제 게시판 : 제목(20글자까지, 빈값일 경우 과목명이 들어감), 내용, 과목

    - DB테이블 : 설정테이블로 각 게시판id에 해당하는 설정값을 가지고 있는다.  
    ![alt text](image.png)

    - 서버 : 테이블의 설정정보 읽어서 유효성체크 및 처리시 값 변경 로직 실행
        > 유효성체크 및 값관련 설정은 서버에서 한다고 가정.

    - 브라우저 : 테이블의 설정정보 읽어서 표시항목만 나타나도록


2. 5.0용어

    *Definition*
    - 명세서. 공통 기능이 동작하기 위한 정보를 가지고 있을 뿐. 그 자체가 가지는 기능은 없다
    - 주민등록등본처럼 변하지 않는 정보를 정의할 때 사용
    - 다른 용어 뒤에 붙여서 사용 : bizz_definition, menu_definition, data_model_definition ... 
    - interface

    *bizz*
    - 업무 : 판매, 구매, 견적, 게시판1, 게시판2, ...

    *menu*
    - 메뉴 : 견적입력, 견적조회, 견적현황, ...

    *sid*
    - 각 항목이 가지는 고유값 : bizz_sid, menu_sid, refer_sid, tenant_sid, ...
    - 난수로 채번

    *data_model*
    - ERP에서 다룰 데이터를 정의. 하나하나의 항목인 prop의 집합
    - 반찬통

    *Attribute*
    - 속성, 설정 
    - 주로 변하는 정보들을 정의해놓는다

    *owner*
    - 속성의 주인. 속성이 동작하는 단위
    - SC설정인 경우, owner는 회사
    - 개인설정인 경우, owner는 사용자
    
    *prop*
    - 항목 : 판매상단 거래처, 판매하단 품목, ...

    *props*
    - 항목이 가리키는 값에 대한 명세

    *refer_type*
    - 항목의미 
    - 견적의 거래처랑 판매의 거래처가 같은 거래처인지 어떻게 알거야? refer_type보고.

    *data_type*
    - 항목이 가지는 데이터의 모양에 대한 정보
    - date, number, string, ...   
    

    2-1. 배운 용어를 판매입력에 대입
    > 재고공통은 아직 가지 않았다고 가정

    bizz : 판매
    menu : 판매입력
        > 이때, ${bizz} + 입력으로 하는지?
    data_model : 판매입력 상단, 판매입력 하단
    attribute : 안전재고 설정
    owner : 판매입력? 판매? 아니면 SC설정에 예외로 판매?
    prop : 일자, 품목, 거래처, 수량, 창고, ...
    refer_type : prod, cust, count, wh, ... 
    data_type : date, string, number, ... 



## 2. 동기에게 도움 받은 내용 (필수)
1. 현철님이 5.0 개념 관련 문서를 공유해주셨습니다.
2. 마니또가 선물해준 수건으로 아침운동 후 샤워를 마치고 개운하게 물기를 제거했습니다.


## 3. 개발 기술적으로 성장한 점 (선택)
### 1. 교육 과정 상 배운 내용이 아닌 개인적 호기심을 해결하기 위해 추가 공부한 내용

1. DMO, QC, 기획에서 생각하는 5.0의 개념과 개발에서 생각하는 5.0의 개념이 어떻게 다른지?
    - 결국 큰 흐름은 비슷하다. 일반화와 공통화.
    - 기획은 기능적인 측면에서 개발은 코드측면에서.
    - 결국 기능을 구현하는 것이 코드기 때문에, 양측 모두 일반화와 공통화 필요

2. pipeline이 뭐지?
    - 정의 : 코드 -> 빌드 -> 테스트 -> 배포 -> 모니터링의 단계로 이루어지며, 소프트웨어 개발과 배포 과정을 자동화하고 효율적으로 관리하기 위한 일련의 단계를 의미.
    - 코드단계 : 개발자가 코드를 작성하고 버전관리 시스템(eg.Git)에 push.
    - 빌드단계 : 코드를 컴파일하고, 필요한 의존성을 설치하며, 실행가능한 app으로 패키징.(eg.velox?)
    - 테스트 단계 : 테스트를 실행하여 코드의 품질과 기능을 검증 (eg.TestCase, QC)
    - 배포단계 : 테스트가 통과된 빌드가 스테이징 환경 혹은 프로덕션 환경에 배포 (eg.QA)
    - 모니터링 단계 : 배포된 app을 모니터링하고 성능 및 문제를 추적 (eg.up30)

    2-1. 의존성이 뭐지?
        - app이 실행되기 위해 필요한 외부 라이브러리 프레임워크 혹은 도구를 의미
        - 이카운트에서는 자체적으로 만든 Velox를 의미하는듯?

    2-2. 패키징이 뭐지?
        - app과 의존성을 하나로 묶어 실행 가능한 파일 or 배포 가능한 상태로 준비하는 과정을 의미 
        - npm run build?

3. prop_id를 고유한 값으로 써도 되는데, 왜 prop_sid와 refer_type으로 나눠서 관리하는지?
    - 하나로 다 할 수 있지만, 개발 경험상 의존성이 강한 큰 약속 하나보다, 작은약속 여러개로 나눠서 관리하는 것이 낫더라.
    - 그렇다면, 작은 약속으로 쪼개는 기준이 무엇인지?



### 2. 오늘 직면했던 문제 (개발 환경, 구현)와 해결 방법

1. 게시판마다 다름을 일반화하는 과제를 받았을때, 이미 알고 있던 지식에 갇혀서 새로운 방안을 생각해내지 못했다.
    - 백지에서 시작했다면 다른 해결방안을 찾을 수도 있었을 거 같은데..


### 3. 위 두 주제 중 미처 해결 못한 과제. 앞으로 공부해볼 내용.

1. 이미 알고 있는 지식을 활용하는 것은 좋으나, 거기에 갇히지 말고 새로운 시선으로 바라보는 훈련을 해야겠다.
