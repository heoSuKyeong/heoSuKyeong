# Daily Retrospective

**작성자**: 나아연  
**작성일시**: 2024-01-02

## 1. 오늘 배운 내용 (필수)

### 5.0의 목표

**비용 줄이기. 개발 시간 단축하기**

---

[숙제]

어떻게 해야 소스가 1개일때 공지사항과 숙제의 차이를 구현할 수 있을까?

제약: 화면 개발, 기능 개발, 테이블 1개를 사용해야함

1. 화면 개발

   - key를 동적으로 사용한다. 공통부분이 아닌 공지기간과 과목은 해당 key를 화면 라벨에 띄운다.
   - UI에 사용할 워딩이 아니어도 기능 key와 UI에서 사용할 단어를 매핑해 화면에 띄울 수 있다.

2. 기능 개발

   - 어떤 서비스에 대한 내용인지를 함께 요청받는다.
   - 동일한 인터페이스를 상속받으며 두 개의 메서드를 가지는 공지사항, 숙제 클래스가 존재한다.

   1. 서비스 값을 받아 해당 클래스에 적합한 데이터인지 판단하여 boolean을 반환한다.
   2. 나머지 값을 받아 해당 서비스의 제약조건들을 검증한다. : 필수여부, 대체항목, 글자수

   - 이후 테이블에서 데이터를 조회하면 "기타" 칼럼은 서비스 따라 공지기간, 과목으로 매핑한다.
   - 서비스를 추가할 때 특정 조건을 가진 클래스를 새로 만들어야 하지만, 요청을 받아 각 서비스에 해당하는 검증을 진행한 뒤 DB에 저장하는 흐름은 하나의 과정으로 볼 수 있을 것 같다.

3. 테이블

   - 하나의 테이블을 사용한다면 공지사항과 숙제 데이터가 섞여있어 각 행이 어떤 서비스의 데이터인지 파악이 필요하다.
   - 제목, 내용, 기타(공지기간/과목), 서비스 칼럼을 둔다.

---

### 서버

```
if (length(제목) > 10) {
  저장 막기
}
------------------------
if (length(@제목) > @대상길이) {
  저장 막기
}
```

하드코딩하지 않고, 검증 대상과 대상 길이를 외부에서 전달받아 검증하는 로직을 수행한다.
저장을 막아야하는 기준 길이가 변경되어도 위 코드는 변함이 없다.
또한 검증 대상이 제목이 아닌 내용으로 변경되어도 위 코드는 변함이 없다.

### DB

공지사항과 숙제를 한 테이블로 관리하기

```sql
insert (제목, 내용, 공지기간, 타입)
values ('새해공지', '감기조심하세요', '2025-01-02 ~ 2025-02-28', '공지사항');
---------------------------------------
insert (제목, 내용, 과목, 타입)
values ('개념숙제', '...', '개념숙제', '숙제');
```

위 경우에는 저장해야 하는 타입별로 각각 쿼리를 작성해야 한다.

```sql
insert (제목, 내용, 공지기간, 과목, 타입)
values ('새해공지', '감기조심하세요', '2025-01-02 ~ 2025-02-28', null, '공지사항');
```

데이터가 들어갈 필요가 없는 칼럼은 null을 저장하도록 한다.

| 제목     | 내용           | 공지기간from | 공지기간to | 과목 | 타입     |
| -------- | -------------- | ------------ | ---------- | ---- | -------- |
| 새해공지 | 감기조심하세요 | 2025-01-02   | 2025-02-28 | null | 공지사항 |
| 개념숙제 | …              | null         | null       | 개념 | 숙제     |

### Client

모든 요소가 포함된 화면을 하나 개발하고,
필요하지 않은 요소를 화면에 노출시키지 않는다.

---

**업무 `bizz`**

업무마다의 목적이 있고 이에 따라 데이터의 구조, 처리방법이 달라짐

**메뉴 `menu`**

하나의 업무 내 다양한 메뉴가 존재한다. (조회, 입력 등)

**항목 `prop`**

입력받거나 조회하는 제목, 내용, 공지기간 등이 항목이다.

**데이터 모델 `data_model`**

같은 목적을 가진 여러 항목의 묶음이다.
두 데이터가 가진 항목들이 다르거나, 같은 항목으로 구성되어 있어도 데이터 타입이나 목적, 의미가 다르다면 서로 다른 데이터 모델이다.

**속성 `attribute`**

속성 = 설정 = 살면서 바뀌는 것.
서로 다른 구체적인 특징

**속성의 주인 `owner`**

속성의 주인. 추상적인 개념

**Definition**

정의 = 한 번 정해지는 것.
인터페이스라고 봐도 될 것 같다

|               |               |           |
| ------------- | ------------- | --------- |
| 업무=bizz     | 공지사항      | 숙제      |
| 메뉴=menu     | 공지사항 입력 | 숙제 입력 |
|               | 공지사항 조회 | 숙제 조회 |
| data_model    |               |           |
| ㄴ 항목=props | 제목          |           |
|               | 내용          |           |
|               | 공지기간      |           |
|               | 과목          |           |
|               | 타입          |           |

```
const 길이 = getValue({"공지사항", "제목"}, "max_length");

if (length(서류.제목)) > 길이) {
  저장 막기
}
```

공지사항과 제목의 max_length 속성의 **값(data)** 을 가져와 비교한다.

| owner1   | owner2   | attr_sid    | attr_id    | data      |
| -------- | -------- | ----------- | ---------- | --------- |
| 공지사항 | 제목     | ASD3456F... | max_length | \* **10** |
| 숙제     | 제목     | EBSE3233... | max_length | 20        |
| 공지사항 | 공지기간 | 4578ASES... | not_null   | true      |
| 숙제     | 내용     | DSAD6753... | max_length | 1000      |
| 숙제     | 제목     | ASDFA89A... | 채우기     | 제목      |

- 공지사항 prop
  | | prop_sid | prop_id | data_type | refer_type(의미) |
  | -------- | -------- | -------- | --------- | ---------------- |
  | 제목 | ... | title | 문자 | title |
  | 내용 | ... | content | 문자 | content |
  | 공지기한 | ... | limit_dt | 날짜 | limit_dt |

- 숙제 prop
  | | prop_sid | prop_id | data_type | refer_type(의미) |
  | ---- | -------- | ------- | --------- | ---------------- |
  | 제목 | ... | subject | 문자 | title |
  | 내용 | ... | content | 문자 | content |
  | 과목 | ... | class | 날짜 | class |

  - 같은 '제목'을 의미하더라도 prop_id는 다를 수 있음 (공지사항의 제목(title) != 숙제의 제목(subject))
  - refer_type이 같으면 같은 것을 의미한다고 볼 수 있음

## 2. 동기에게 도움 받은 내용 (필수)

- 마니또에게 선물을 받았습니다. 누군지 확실하다!! 생각했는데 아닌 거 같습니다.
- 성철님께서 케이크를 나눔해주셨습니다. 감사합니다.
- 현철님께서 오늘 배운 내용들이 정리되어있는 문서를 공유해주셨다. 감사합니다.

---

## 3. 개발 기술적으로 성장한 점 (선택)

### 1. 교육 과정 상 배운 내용이 아닌 개인적 호기심을 해결하기 위해 추가 공부한 내용

Array의 reduce에 대해 학습했다.

```jsx
const sum = lastDay.slice(0, a).reduce((acc, cur) => acc + cur);
```

reduce는 4개의 인자를 가진다.

- callback
  - 누산기 (acc)
    - 콜백의 반환값을 누적한다. 콜백의 이전 반환값 또는, 콜백의 첫 번째 호출이면서 initialValue를 제공한 경우에는 initialValue의 값이다.
  - 현재 값 (cur)
  - 현재 인덱스 (idx)
    - 처리할 현재 요소의 인덱스. initialValue를 제공한 경우 0, 아니면 1부터 시작한다.
  - 원본 배열 (src)
- initialValue
  callback의 최초 호출에서 첫 번째 인수에 제공하는 값. 초기값을 제공하지 않으면 배열의 첫 번째 요소를 사용한다. 빈 배열에서 초기값 없이 reduce()를 호출하면 오류가 발생한다.

### 3. 위 두 주제 중 미처 해결 못한 과제. 앞으로 공부해볼 내용.

- 이카운트에서 사용하는 용어들을 아직 완전히 이해하지 못했다.
- 프레임워크는 검증대상, 검증기준과 검증 로직을 분리했다는 느낌을 받았다.
- 어떤 값이 들어오더라도 검증기준에 대해 로직을 수행 가능할 것 같다.
- 하지만 그만큼 외부에서 값을 조작하기 쉽고 객체라는 느낌을 받지 못했으며 객체의 역할이 무엇인지에 대해 이해하지 못했다.
- 캡슐화보다 유연성에 초점을 맞추었기에, 세부구현사항을 알아야 기능을 구현할 수 있을 것 같다는 생각이 들었다.
