# Daily Retrospective

**작성자**: [나강민]  
**작성일시**: [2025-01-03]

## 1. 오늘 배운 내용 (필수)

1. 서류를 빗대어 Definition, Attribute에 관한 용어 설명
2. 5.0 프레임워크에서 하고자 하는 로직의 방향성
3. 용어 정리 및 프레임워크 동작 흐름에 관하여

## 1. 서류를 빗대어 Definition, Attribute에 관한 용어 설명

### 요구사항 및 해결 방안 정리

---

### 1. **요구사항**

- **목표**: 단일 소스/테이블로 다양한 업무를 처리할 수 있는 시스템 구현.
- **핵심 질문**:
  1. 서로 다른 업무를 하나의 로직으로 어떻게 처리할 수 있을까?
  2. 예를 들어, "자리수 체크"라는 공통 로직에서 **공지사항 제목**은 10자리, **숙제 제목**은 20자리로 제한되는데, 이를 동적으로 구현할 수 있는 방법은?

---

### 2. **고민 및 문제 정의**

- **차이를 어떻게 일반화할 것인가?**
  - 업무마다 요구사항이 다르기 때문에 단일 로직으로는 처리하기 어려운 부분이 존재.
  - 예: 같은 제목 속성(`title`)이라도 공지사항과 숙제에서 글자수 제한이 다름.
  - 업무에 따라 속성 설정과 동작 로직이 다르게 동작해야 한다는 점이 가장 큰 문제.

---

### 3. **방법: 서류를 기반으로 한 추상화 설계**

- **핵심 개념**:
  - 업무마다 고유한 상황을 "서류"라는 개념으로 작성하고, 이 서류를 기준으로 기능(로직)이 다르게 동작하도록 설계.

---

### 4. **서류의 구성**

1. **`definition`**:

   - 태어나면서 정해지는 고유 특성, 변하지 않는 정보.
   - 예: 주민등록등본, 고유 식별자 등.

2. **`attribute`**:
   - 동적으로 설정 가능한 속성, 언제든 변경 가능.
   - 예: 자리수 제한, 글자 색상, 서류의 스타일 등.

---

### 5. **서류의 주인 (Owner)과 역할**

#### **Definition의 Owner**

- `bizz`: 업무 분류 (예: 공지사항, 숙제).
- `menu`: 메뉴 단위 관리 (예: 공지사항 입력, 조회).
- `data_model`: 데이터 모델의 정의.

#### **Attribute의 Owner**

- **주체**: 속성의 실제 소유자.
  - 예: 글자 색상 설정은 "항목" 자체가 아니라 "회사"가 주체.
- **종류 및 설명**:
  1. **`bizz`**: 업무 단위에서 속성을 정의. (예: 모든 공지사항의 글자 크기)
  2. **`menu`**: 메뉴별 속성을 정의. (예: 특정 메뉴에서만 사용되는 스타일)
  3. **`data_model`**: 로그인 사용자별로 다른 설정을 적용. (예: 개인화된 글자 색상)
  4. **`prop`**: 속성의 주체로 항목 자체를 설정. (예: 제목 속성 자체가 글자수 제한 대상)

---

### **Owner 속성 관리 재정리**

---

#### **현재 문제**

- `제목`의 `속성 ID`가 "누구의 제목인지"(숙제, 공지 등)를 알 수 없는 상황.
- 속성을 관리할 때, 소유자(`owner`)의 구분이 명확하지 않아 속성 값이 중복되거나 혼란을 초래할 수 있음.

---

#### **해결 방안**

- **`owner_type`** 필드를 추가하여 소유자를 명확히 구분.
- `owner_type`과 `owner`를 결합해 속성의 소유자를 구체적으로 표현.

---

#### **속성 관계 표 (기존 예시 + 개선된 예시)**

1. **기존 속성 관리 구조**

| **owner_type** | **owner** | **속성 ID** | **속성 값** |
| -------------- | --------- | ----------- | ----------- |
| 항목           | 거래처    | 글자색깔    | 파란색      |
| 회사           | 80000     | 글자색깔    | 빨간색      |
| 항목           | 제목      | 글자색깔    | 파란색      |

**문제점**:

- `제목` 속성의 주인이 누구인지(`숙제`, `공지사항`) 명확하지 않음.
- 속성 값(글자색깔)이 중복될 가능성이 있음.

---

2. **개선된 속성 관리 구조**

| **owner_type** | **owner** | **owner_type** | **owner** | **속성 ID** | **속성 값** |
| -------------- | --------- | -------------- | --------- | ----------- | ----------- |
| 업무           | 숙제      | 공지           | 제목      | 글자색깔    | 파란색      |
| 업무           | 공지사항  | 제목           | 제목      | 글자색깔    | 빨간색      |

**개선점**:

- `owner_type`을 추가하여 `제목` 속성의 소유자를 구체적으로 구분.
- 속성 값 중복 없이 소유자별로 속성 관리가 가능.

---

### 7. **속성과 정의의 구분**

- **`Attribute`**:
  - 동적으로 변경 가능한 속성. (예: 글자수 제한, 글자색)
- **`Definition`**:
  - 고정된 정보. (예: 주민등록등본, 서류의 유형)

### 5.0 프레임워크의 로직 방향성에 대한 설명

#### **1. 문제 정의 및 요구사항**

5.0 프레임워크에서 자리수 체크와 관련된 주요 요구사항은 다음과 같습니다:

- **단일 소스**: 제목, 내용 등 항목별로 별도의 자리수 체크 로직이 아닌, 모든 자리수 체크를 하나의 공통 소스로 처리해야 한다.
- **업무 특화**: 공지사항 제목은 10자리, 숙제 제목은 20자리처럼, 업무별로 자리수 제한이 다르지만 이를 동적으로 처리할 수 있어야 한다.
- **유효성 검증**: 입력된 항목의 길이가 자리수 속성값을 초과하면 저장이 불가능해야 하며, 이 검증은 동적으로 작동해야 한다.

---

#### **2. 로직 설계의 방향성**

5.0 프레임워크는 다음과 같은 방향성을 통해 로직을 설계하고자 합니다:

1. **추상화와 일반화**:

   - 모든 자리수 검증을 공통 로직으로 처리하도록 설계합니다. 즉, 제목이나 내용과 같은 항목별로 별도의 로직을 작성하지 않고, 항목의 `refer_type`과 업무의 `definition`을 기반으로 자리수 속성값을 가져와 검증합니다.
   - 이를 통해 코드 중복을 최소화하고 유지보수성을 높이는 방향으로 설계합니다.

2. **동적 속성 기반 검증**:

   - 각 업무(`bizz`)와 항목(`data_model`)이 고유한 자리수 속성값을 가질 수 있도록 설계합니다.
   - 자리수 속성값은 속성(`attribute`)에서 동적으로 가져와 검증하며, 로직 수정 없이 설정값만 변경하면 새로운 업무나 항목에 대응할 수 있도록 합니다.

3. **데이터 중심의 검증**:

   - 검증 대상 데이터는 `data_model`을 통해 가져오며, 이 데이터의 길이를 기준으로 자리수 체크를 수행합니다.
   - 데이터의 출처와 구조를 명확히 구분하여, 로직의 확장성과 유연성을 유지합니다.

4. **서류 기반 로직**:
   - "서류"라는 추상화된 개념을 통해 업무와 항목 간의 관계를 정의하고, 이를 바탕으로 검증 로직이 동작하도록 설계합니다.
   - 예를 들어, 공지사항이라는 업무(`bizz`)와 제목(`prop`)이 연결된 서류를 통해 자리수 제한을 적용합니다.

---

#### **3. 5.0 프레임워크의 로직 예시**

- **단일 자리수 체크 로직**:
  ```javascript
  function 자리수_체크(prop) {
    var prop = 업무.data_model_definition.props[항목];
    var 자리수속성값 = prop.getAttribute("max_length");
    var 데이터 = data_model.getValueByReferType(prop.refer_type);

    if (데이터.length > 자리수속성값) {
      return false; // 검증 실패
    }
    return true; // 검증 성공
  }
  ```
  - 업무와 항목을 기반으로 자리수 속성값(`max_length`)을 가져오고, 입력된 데이터의 길이를 비교합니다.

---

### **Refer_type의 역할과 설명**

---

#### **Refer_type의 정의**

`Refer_type`은 속성(`prop`)을 추상적으로 구분하는 역할을 합니다. 즉, 동일한 속성을 여러 업무나 항목에서 사용할 때, 그 속성이 어떤 역할을 하는지를 명확히 구분하기 위한 식별자입니다. 예를 들어, "제목"이라는 속성이 공지사항에서도 사용되고 숙제에서도 사용된다면, `refer_type`을 통해 두 속성의 역할을 구분하고 일관되게 처리할 수 있습니다.

---

#### **‘반장’ 예시를 통한 설명**

- **문제 상황**:

  - 이카중학교에서 1학년 1반에 반장이 100명 있다고 가정합니다. 이 모든 반장의 이름과 역할을 개별적으로 외우는 것은 불가능합니다.
  - 대신, 반장의 역할을 나타내는 `refer_type`을 활용하면 "반장"이라는 공통 역할을 기반으로 해당 속성에 접근할 수 있습니다.

- **해결 방법**:
  - 각 반장의 이름을 개별적으로 외우는 대신, `refer_type`으로 "반장"을 설정하고, 이 역할을 기반으로 필요한 작업(예: 출석 체크, 업무 할당 등)을 수행합니다.

| **번호** | **이름** | **역할** | **prop_id** | **이름** | **refer_type** |
| -------- | -------- | -------- | ----------- | -------- | -------------- |
| 1        | 홍길동   | 반장     | 1           | 홍길동   | 반장           |
| 2        | 아무개   | 청소반장 | 2           | 아무개   | 청소반장       |
| 3        | 김철수   | 당번     | 3           | 김철수   | 당번           |

---

#### **Refer_type의 역할**

1. **속성의 역할 정의**:

   - `Refer_type`은 속성이 수행해야 할 역할을 나타냅니다.
   - 예: "반장"은 반의 대표 역할, "청소반장"은 청소 담당 역할을 의미합니다.

2. **데이터 접근의 통일성**:
   - `Refer_type`을 통해 코드에서 데이터에 접근할 때, 속성의 고유 ID나 이름을 명시적으로 지정하지 않아도 됩니다.
   - 예: 반장의 이름을 `refer_type`으로 검색하면, 반장의 이름만 반환되도록 설정.

---

#### **공지사항과 숙제에서의 Refer_type 예시**

1. **공지사항** (`data_model_definition`):

| **prop_id** | **이름** | **refer_type** |
| ----------- | -------- | -------------- |
| 1           | 제목     | 제목           |
| 2           | 내용     | 내용           |
| 3           | 공지기한 | 공지기한       |

2. **숙제** (`data_model_definition`):

| **prop_id** | **이름** | **refer_type** |
| ----------- | -------- | -------------- |
| 1           | 제목     | 제목           |
| 2           | 내용     | 내용           |
| 3           | 과목     | 과목           |

---

#### 추가 질문 및 답

refer_type을 통해 데이터를 가져오는 것이 아닌 prop.prop_id로 가져오는게 더 나은 방향같은데 아닌가?에 대한 답변

```javascript
var 기존데이터불러오기 = data_model.getValueByReferType(prop.refer_type);

var 비교 데이터 1 = dmc.getValueByPropID(prop.prop_id); // prop_id를 기반으로 값 가져오기 refer_type와 비교하여 어떻게 값을 참조하는지에 대한 고찰. 사용가능. 핵심은 공통화

var 비교 데이터 2 = dmc.getValueByPropID("title"); // 명시적 사용 금지, 동적 refer_type을 사용해야 함
```

### 내가 이해한 프레임워크 전체 흐름 중 게시판 흐름

  <img src="../ref/나강민 2025-01-03 회고록 1.png"/>

---

#### **1. Action (진입점 EntryPoint)**

- `Action`은 UI에서 데이터를 받아 시스템의 첫 진입점 역할을 수행합니다. 이 단계에서는 사용자의 요청 데이터를 받아 로직 실행을 위한 초기 상태를 설정합니다. `Action`은 단순히 출입문 역할만 담당하며, 복잡한 로직 처리는 Main Program으로 넘깁니다.

---

#### **2. Main Program (흐름 제어)**

- `Main Program`은 로직의 중심이 되는 흐름 제어 역할을 합니다. Action에서 전달받은 데이터를 기반으로 필요한 `Modifier`(데이터 자동 채우기)와 `Validator`(검증 로직)를 호출하고, 결과를 데이터베이스(DB)에 반영하거나 다음 단계를 이어갑니다. 이 과정에서 전체 로직의 순서를 관리하며 데이터 흐름을 조율합니다.

---

#### **3. 채우기 매니저 (Modifier)**

- `Modifier`는 데이터를 자동으로 채우는 역할을 합니다. 예를 들어, 사용자가 입력하지 않은 필드를 기본값으로 자동 채우거나, 설정된 규칙에 따라 데이터를 보완합니다. 이 단계는 필수 값 누락 문제를 방지하고, 데이터를 구조화된 상태로 다음 단계에 넘기기 위해 필요합니다.

---

#### **4. 체크 매니저 (Validator)**

- `Validator`는 데이터 유효성 검사를 수행합니다. 자리수 체크, 필수 항목 체크 등 다양한 검증 로직이 여기에 포함됩니다. 모든 검증을 통과한 데이터만이 데이터베이스(DB)에 저장될 수 있습니다. 이를 통해 데이터의 품질과 일관성을 보장합니다.

---

#### **5. DB Insert**

- `DB Insert`는 검증을 통과한 데이터를 실제로 데이터베이스에 저장하는 단계입니다. 이 과정에서 데이터를 게시판 테이블 등과 연결하여 저장하며, 최종적으로 사용자가 원하는 형태로 데이터를 처리합니다.

---

#### **6. 데이터 모델 (data_model)**

- `data_model`은 프레임워크의 핵심 데이터 구조로, Attribute(속성)과 Definition(정의)을 포함합니다. Attribute는 동적으로 변경 가능한 속성을, Definition은 고정된 속성을 관리합니다. 데이터를 각 단계에 맞게 가공 및 전달하며, Modifier와 Validator가 참조하는 주요 데이터 컨테이너 역할을 합니다.

---

#### **7. DMC (DataModelContainer)**

- `DMC`는 `data_model`과 `data_model_definition`을 포함하는 컨테이너로, 데이터와 설명서를 함께 관리하며 로직의 모든 단계에서 이를 참조합니다.

---

#### **8. 게시판 테이블**

- 게시판 테이블은 DB Insert 단계를 통해 저장된 데이터가 최종적으로 저장되는 장소입니다. 게시판별로 데이터를 구분하고 저장하며, 이를 기반으로 사용자 요청에 따라 데이터를 조회하거나 처리합니다.

### 실제 회사 DB 테이블의 대한 설명 및 정리

### **DB 테이블 설계 및 문제점 해결**

---

### **1. 현재 테이블 구조**

#### **1.1. 초기 테이블 문제**

1. **문제 1: `type` 정보 누락**

   - 데이터에서 어떤 업무인지(`공지사항`, `숙제`, `판매전표`)를 구분할 수 있는 명시적인 `bizz_sid`가 없어 구분이 어려움.
   - **해결**: `bizz_sid`를 추가하여 업무 유형을 명확히 구분.

2. **문제 2: 기본 키(PK) 없음**

   - 테이블의 고유 데이터를 식별할 키가 없어 데이터 중복 및 관리의 어려움 발생.
   - **해결**: `tenant_sid`(회사 코드)를 포함한 조합 키(`data_sid`)를 인조 식별자로 생성하여 데이터 유일성을 보장.

3. **문제 3: `No`의 기준 불명확**
   - 각 업무(`bizz_sid`) 및 메뉴(`menu`)별로 게시판의 `No`(번호)가 중복될 가능성이 있음.
   - **해결**: `record_sid`를 추가하여 상단/하단 관계를 명확히 구분.

---

### **2. 해결된 테이블 구조**

#### **2.1. 게시판 테이블 (싱글)**

| tenant_sid | record_sid | data_sid (PK) | No  | title      | content        | notice_limit | class | bizz_sid    |
| ---------- | ---------- | ------------- | --- | ---------- | -------------- | ------------ | ----- | ----------- |
| 80000      | r1         | d1            | 1   | 새해공지   | 감기조심하세요 | 2025.02.28   | null  | FD23F423... |
| 80000      | r2         | d2            | 2   | 봄맞이공지 | 꽃구경하세요   | 2025.02.28   | null  | FD23F423... |
| 80000      | r3         | d3            | 1   | 개념숙제   | null           | null         | 개념  | 숙제        |

- **구조 변경**:
  - `record_sid`: 상단 레코드를 구분하는 고유 키 추가.
  - `data_sid`: 인조 식별자(PK)로 유일성을 보장.

---

#### **2.2. 게시판 테이블 (멀티)**

| tenant_sid | record_sid | data_sid (PK) | No  | title    | content | notice_limit | class | bizz_sid |
| ---------- | ---------- | ------------- | --- | -------- | ------- | ------------ | ----- | -------- |
| 80000      | r4         | d3            | 1   | 개념숙제 | null    | null         | 개념  | 숙제     |
| 80000      | r5         | d3            | 1   | 판매전표 | null    | null         | null  | 판매     |
| 80000      | r6         | d5            | 1   | null     | null    | null         | null  | 판매     |

- **구조 변경**:
  - 멀티 레코드 지원을 위해 하단 데이터를 여러 행으로 저장.
  - 상단(`record_sid`)과 하단 데이터를 1:N 관계로 연결.

---

### **3. 문제 해결 요약**

#### **3.1. 문제: 데이터 유일성**

- 데이터 고유 식별을 위한 키가 없음.
- **해결**:
  - `data_sid`를 인조 식별자로 생성.
  - `record_sid`를 상단/하단 데이터 연결에 활용.

#### **3.2. 문제: 데이터 중복**

- `No`가 업무(`bizz_sid`)별로 중복될 가능성.
- **해결**:
  - `tenant_sid`, `record_sid`, `data_sid` 조합으로 유일성을 보장.

#### **3.3. 문제: 1:N 관계**

- 판매 수정 시 상단(single)과 하단(multi) 데이터를 구분해야 하지만, 기존 테이블 구조에서는 이를 명확히 처리할 수 없음.
- **해결**:
  - 상단과 하단 데이터를 각각 싱글 테이블과 멀티 테이블로 구분.

---

### **4. 전표 테이블 설계**

#### **4.1. 재고 자유형 싱글 테이블**

| tenant_sid | record_sid      | data_sid        | record_seq_no | bizz_sid | menu_sid  | data_dt  | data_no | wh_sid | wh_nm | cust_sid | cust_nm |
| ---------- | --------------- | --------------- | ------------- | -------- | --------- | -------- | ------- | ------ | ----- | -------- | ------- |
| 80000      | 7I28F5ULKND1FLS | 8LI26C8FGL5J1FT | 1             | 견적     | 견적입력  | 20240101 | 1       | null   | null  | null     | null    |
| 80000      | U7FIP28GAF871L  | 28L6C8FGL5IJT1F | 1             | 판매     | 판매입력  | 20240101 | 1       | null   | null  | null     | null    |
| 80000      | T7FAP218F8IGT7L | LL2856CFG8IJT1F | 1             | 판매     | 판매입력2 | 20240101 | 2       | null   | null  | null     | null    |

#### **4.2. 재고 자유형 멀티 테이블**

| tenant_sid | record_sid      | data_sid        | record_seq_no | bizz_sid | menu_sid | data_dt  | data_no | prod_sid | prod_nm | price | qty  |
| ---------- | --------------- | --------------- | ------------- | -------- | -------- | -------- | ------- | -------- | ------- | ----- | ---- |
| 80000      | 7I28F5ULKND1FLS | 8LI26C8FGL5J1FT | 1             | 견적     | 견적입력 | 20240101 | 1       | null     | null    | null  | null |
| 80000      | KN7I21F8LSF5ULD | 8LI26C8FGL5J1FT | 2             | 견적     | 견적입력 | 20240101 | 1       | null     | null    | null  | null |
| 80000      | F87UGAFIP2871L  | 28L6C8FGL5IJT1F | 1             | 판매     | 판매입력 | 20240101 | 1       | null     | null    | null  | null |
| 80000      | F7AFIPU71G288L  | 28L6C8FGL5IJT1F | 2             | 판매     | 판매입력 | 20240101 | 1       | null     | null    | null  | null |

---

### **5. 결론 및 정리**

- **인조 식별자(`data_sid`)**를 통해 유일성을 보장.
- **`record_sid`**로 상단(single)과 하단(multi) 데이터를 구분하여 1:N 관계 처리.
- **`bizz_sid`, `menu_sid`**로 업무와 메뉴 구분.
- 상단/하단 데이터를 분리하여 효율적 데이터 관리 및 중복 방지.

---

### **서버, UI, DB 흐름 관점에서 데이터 이동과 5.0 프레임워크의 관점**

---

#### **1. 데이터 흐름: UI → 서버 → DB**

1. **UI에서 서버로 데이터 전달**:

   - **UI**는 사용자가 입력한 데이터를 `data_model`이라는 **데이터 그릇**에 담아 서버로 전달합니다.
   - 이 단계에서는 **클라이언트 중심**으로 데이터를 처리하며, `data_model`은 비즈니스 로직 수행을 위한 데이터 구조를 포함합니다.
   - 예: 게시판에서 작성한 제목, 내용 등을 `data_model_게시판_싱글`에 담아 서버로 전송.

2. **서버에서 데이터 처리**:

   - 서버는 전달받은 `data_model`을 기반으로 비즈니스 로직을 수행합니다.
   - 이때, `data_model`과 DB 테이블 구조가 일치하지 않더라도, 비즈니스 로직 수행에 필요한 데이터는 `data_model`을 중심으로 처리됩니다.
   - **핵심 관점**: `data_model`은 서버와 클라이언트 간 데이터를 주고받는 데 최적화되어 있으며, DB와의 구조적 차이를 허용합니다.

3. **DB 저장: Table Model로 변환**:
   - 서버는 DB 테이블 구조에 맞게 데이터를 저장하기 위해 `data_model`을 `table_model`로 변환합니다.
   - `table_model`은 DB 테이블과 1:1 매핑되며, 데이터를 효율적으로 저장하거나 조회하는 데 사용됩니다.
   - 예: `content` 필드처럼 대량 데이터를 다룰 경우, `table_model_게시판_싱글`과 `table_model_게시판_싱글_내용`으로 분리하여 저장.

---

#### **2. 5.0 프레임워크의 관점에서의 데이터 흐름**

1. **Data Model 중심 설계**:

   - **5.0 프레임워크**는 **Data Model**을 중심으로 데이터를 처리합니다.
   - 비즈니스 로직은 `data_model`을 기반으로 수행되며, 데이터의 구조나 형태는 UI 및 서버 간 데이터를 주고받는 데 최적화됩니다.
   - 예:
     - 공지사항과 숙제 모두 `data_model_게시판_싱글`을 사용.
     - R(조회자 현황)처럼 DB에 없는 기능형 항목도 Data Model 내에서 처리.

2. **Data Model Template**:

   - 데이터 모델 설계는 **data_model_template**에서 시작됩니다.
   - `data_model_template`는 데이터를 담는 그릇의 설계를 정의하며, 빌드 시 다양한 `data_model`을 자동 생성합니다.
   - 예:
     - 입력용(`data_model_게시판_싱글_입력`), 검색 조건용(`data_model_게시판_싱글_검색조건`), 검색 결과용(`data_model_게시판_싱글_검색결과`) 등으로 나눔.

3. **Table Model로의 변환**:

   - 서버에서 DB에 저장하기 직전, `data_model`을 `table_model`로 변환합니다.
   - 이 변환 과정을 통해 DB 테이블과 1:1로 매핑되며, 데이터를 효율적으로 저장하거나 조회할 수 있습니다.
   - **중요점**: Data Model과 Table Model은 각자 역할이 다르며, 비즈니스 로직 중심의 Data Model은 DB와 구조적으로 일치하지 않아도 됩니다.

4. **비즈니스 로직 중심의 설계**:
   - 5.0 프레임워크에서는 비즈니스 로직이 최우선이며, 데이터 흐름은 이를 지원하도록 설계됩니다.
   - Data Model은 비즈니스 로직의 중심 역할을 하며, Table Model은 이를 DB와 연결하는 최적화된 구조로 작동.

---

#### **3. 데이터 이동 과정의 예시**

1. **UI → 서버 (Data Model)**:

   ```typescript
   class data_model_게시판_싱글 {
     tenant_sid: string;
     recode_sid: string;
     data_sid: string;
     no: number;
     title: string;
     content: string; // 대량 데이터
     notice_limit: string; // 공지사항 전용
     class: string; // 숙제 전용
     bizz_sid: string;
     R: string; // 기능형 항목
   }
   ```

   - UI에서 데이터를 담아 서버로 전달.
   - 공지사항, 숙제 등 다양한 데이터가 동일한 Data Model을 사용.

2. **서버 내 데이터 처리**:

   ```typescript
   function processData(dataModel: data_model_게시판_싱글) {
     // 비즈니스 로직 수행
     if (dataModel.title.length > 100) {
       throw new Error("제목이 너무 깁니다.");
     }
   }
   ```

   - 서버는 Data Model을 기반으로 비즈니스 로직을 수행.
   - R(조회자 현황)과 같은 기능형 항목도 Data Model 내에서 처리.

3. **서버 → DB (Table Model)**:

   ```typescript
   class table_model_게시판_싱글 {
     tenant_sid: string;
     recode_sid: string;
     no: number;
     title: string;
     notice_limit: string; // 공지사항 전용
     class: string; // 숙제 전용
     bizz_sid: string;
   }

   class table_model_게시판_싱글_내용 {
     tenant_sid: string;
     recode_sid: string;
     content: string; // 대량 데이터
   }
   ```

   - 서버에서 Table Model로 변환 후, DB에 저장.
   - 대량 데이터(`content`)는 별도의 Table Model로 분리하여 저장.

---

#### **4. 5.0 프레임워크에서 강조하는 점**

1. **Data Model 중심**:

   - 비즈니스 로직은 `data_model`을 중심으로 수행.
   - Data Model과 DB 테이블 구조가 다르더라도 비즈니스 로직에 영향을 주지 않음.

2. **Data Model Template의 중요성**:

   - Data Model 설계를 잘하면 다양한 요구사항에 따라 자동으로 필요한 `data_model`을 생성 가능.
   - 입력, 검색 조건, 검색 결과 등 상황에 맞는 Data Model을 생성하여 유연성을 극대화.

3. **Table Model로의 변환**:

   - DB와의 소통을 위한 최적화된 구조.
   - Data Model과 독립적으로 설계되어 성능을 극대화.

4. **유연성과 확장성**:
   - 하나의 Data Model로 다양한 상황을 처리하며, 구조적으로 복잡한 요구사항도 해결 가능.
   - Table Model을 통해 데이터 저장의 효율성을 보장.

---

### **결론**

5.0 프레임워크는 데이터 흐름을 **UI → 서버 → DB**로 정의하며, 각 단계에서 데이터 처리의 역할을 명확히 구분합니다. `Data Model`은 비즈니스 로직 중심의 설계로, 데이터 흐름의 핵심을 담당하며, `Table Model`은 DB 저장의 최적화를 위해 설계됩니다.

### **내가 생각하는 5.0 프레임워크 목표와 개발 방향**

---

### **1. 5.0 프레임워크의 핵심 목표**

1. **개발 비용 절감**:

   - 기존의 복잡하고 중복된 구조를 단순화하여, 개발 및 유지보수 비용을 줄이는 것이 핵심 목표입니다.
   - 예: 기존에는 판매 상/하단, 구매 상/하단, 견적 상/하단 등으로 분리된 테이블을 재고자유형 싱글/멀티와 회계자유형 싱글/멀티로 통합.

2. **통합과 일반화**:

   - **통합**: 비슷한 기능을 가진 요소들을 하나로 통합하여 중복을 제거.
     - 예: 100개의 테이블을 5개로 줄임으로써, DB 통신 코드도 단순화.
   - **일반화**: 고객 설정을 활용해 다양한 요구사항을 처리할 수 있도록 유연성을 확보.
     - 예: 서류의 정의(`definition`)와 속성(`attribute`)를 사용하여 공통된 기능을 처리.

3. **공통 기능의 효율화**:
   - 공통 기능(자동채우기, 자리수 체크, 필수체크 등)을 잘 설계하여 중복된 코드를 제거.
   - 예: 소스 코드 하나로 다양한 업무를 처리하도록 함.

---

### **2. 내가 주로 개발할 범위**

1. **공통 기능 개발**:

   - 자리수 체크, 필수 체크, 자동 채우기 등과 같은 **`Validator`**와 **`Modifier`** 역할.
   - 유효성 검사와 데이터 자동 수정 기능을 담당.

2. **Data Model 처리**:

   - **`Data Model`**은 클라이언트(UI)와 서버 간 데이터 이동의 중심.
   - 데이터를 정의하는 `definition`과 속성을 설정하는 `attribute`를 기반으로 작업.

3. **서류 중심 설계**:

   - 모든 기능은 **서류**(`definition`)를 중심으로 동작하며, 이를 변경하지 않는 것을 원칙으로 함.
   - 예: 판매 서류, 구매 서류 등 업무에 맞는 정의를 기준으로 로직 설계.

4. **공통 모듈 재사용**:
   - 재사용 가능한 공통 기능을 설계하고, 새로운 업무에 쉽게 적용할 수 있도록 모듈화.

---

### **3. 개발 방법**

#### **3.1. 목표 기반 개발**

- **개발 목표 이해**:

  - 왜 이 기능을 개발해야 하는지, 최종적으로 무엇을 해결하려는지 항상 목표를 파악.
  - 5.0의 목표는 단순화, 일반화, 비용 절감.

- **Definition과 Attribute 중심**:
  - 모든 기능은 서류 중심(`definition`)으로 설계하고, 속성(`attribute`)을 통해 동작 방식을 정의.
  - 예: 자리수 체크(`max_length`), 필수 입력(`not_null`) 등.

#### **3.2. 데이터 처리 흐름**

- **UI → 서버 → DB**:
  1. **UI에서 입력된 데이터를 `Data Model`로 전달.**
  2. 서버에서 `Data Model`을 기반으로 유효성 검사를 수행(`Validator`).
  3. DB 저장 전, `Data Model`을 `Table Model`로 변환하여 최적화된 형태로 저장.

#### **3.3. 공통 기능 개발**

- **자동 채우기 기능**:
  - 예: 입력하지 않은 필드를 자동으로 채우는 기능.
- **자리수 체크 기능**:
  - 예: 제목(`title`)의 글자수를 `max_length` 속성을 기반으로 검사.
- **필수 체크 기능**:
  - 예: 특정 필드가 비어 있으면 저장 불가(`not_null` 속성 검사).

#### **3.4. 서류 중심의 비즈니스 로직**

- **새로운 기능 추가**:
  - 서류(`definition`)를 기반으로 새로운 기능을 추가.
  - 예: 판매 서류에서 추가적인 유효성 검사 로직을 설정.
- **코드 유지보수**:
  - 새로운 기능은 기존 코드를 변경하지 않고, 정의(`definition`)와 속성(`attribute`)를 통해 처리.

---

### **4. 요약**

#### **4.1. 내가 위치한 개발 영역**

- **공통 기능 개발**:
  - 자리수 체크, 필수 체크, 자동 채우기 같은 **Validator/Modifier** 개발.
- **Data Model 설계 및 처리**:
  - 클라이언트와 서버 간 데이터를 이동시키는 `Data Model`과 이를 정의하는 `definition` 작업.

#### **4.2. 개발 방법**

- 항상 목표를 중심으로 개발(단순화, 일반화, 비용 절감).
- `definition`과 `attribute`를 활용하여 공통 기능 구현.
- 기존 서류 중심 설계 원칙을 준수하며, 유지보수 가능한 코드를 작성.

  5.0 프레임워크의 핵심은 **공통화**와 **일반화**를 통한 효율성 극대화입니다. 이를 기반으로, 내가 맡은 영역에서는 서류 중심의 기능을 설계하고, 재사용 가능한 모듈을 만들어 개발 효율성을 높이는 데 집중합니다.

## 2. 동기에게 도움 받은 내용 (필수)

현철님 : 오늘 같이 밥먹으러 가지 않았는데 우연히 동떨어진 저를 데리고 가주셔서 감사합니다.

도형님 : 강의 내용을 듣고, 비슷한 경험을 해본 사람과의 토론을 하면서 식견을 넓힐 수 있는 기회를 항상 주셔서 감사합니다. 예를들어 이번에도 sequenc_no는 왜 있는지, 1:n 처리에서 어떤 방식이 더 어울릴지 등등의 대한 이야기를 했습니다.

연아님 : 오늘 아침에 맛있는 귤을 주셔서 감사했습니다!

성철님 : 어제 회식자리에서 다 계산하시고 이후에 정산을 대표로 해주셔서 감사했습니다!

---

## 3. 개발 기술적으로 성장한 점 (선택)

### 1. 교육 과정 상 배운 내용이 아닌 개인적 호기심을 해결하기 위해 추가 공부한 내용

#### 실무 적용을 위한 추가 학습\*\*

- **코드 구조 분석**:
  - 처음 마주한 수많은 폴더와 파일 구조는 다소 복잡했지만, 학습한 용어(`definition`, `attribute`, `data_model`)가 코드 분석에 큰 도움이 되었습니다.
  - 실제 소스코드를 확인하며, 이론적으로 배운 내용을 코드에서 어떻게 구현하고 있는지 점검.
- **ecount-docs 학습**:
  - 실제 개발에서 어떻게 ERP 기능을 구현할 수 있을지에 대한 구체적인 방법을 배우기 위해 `ecount-docs` 문서를 공부.
  - 이를 통해 프레임워크의 내부 동작 방식과 코드 작성 시 주의해야 할 점을 이해.

---

### 2. 오늘 직면했던 문제 (개발 환경, 구현)와 해결 방법

오늘 학습 중, PK를 통일해서 처리하는 방식에 대한 효율성의 가치를 완전히 이해하기 어려웠습니다. PK를 통합하여 관리함으로써 데이터 유일성을 보장하고, 개발 및 유지보수의 복잡성을 줄이는 방향성은 알게 되었지만, 이 방식이 실제 설계비용을 얼마나 줄일 수 있는지 체감하기는 어려웠습니다.

예를 들어, 기존의 방식에서는 각각의 업무(판매, 구매, 견적 등)에 대해 개별 PK를 설정하고 관리했지만, 5.0 프레임워크에서는 tenant_sid, record_sid, data_sid와 같은 통합 PK 체계를 사용하여 데이터를 일원화합니다. 이로 인해 ERD 설계가 단순해지고, 데이터의 중복 문제를 방지할 수 있다는 점은 이해했으나, 이러한 방식이 모든 업무에 동일하게 적용될 때 발생할 수 있는 한계와 추가적인 복잡성에 대한 우려도 있었습니다.

### 3. 위 두 주제 중 미처 해결 못한 과제. 앞으로 공부해볼 내용.

아직 ERD를 효율적으로 설계하는 방식에 대한 구체적인 접근법과 감각이 부족하다고 느꼈습니다. 통합 PK 구조가 설계 비용을 줄이는 데 효과적이라는 점은 이해했지만, 이를 적용할 때 업무별 특성과 비즈니스 로직을 어떻게 반영해야 할지 명확히 알지 못했습니다.

각 업무의 요구사항을 효율적으로 반영하면서도 통합 PK 체계를 유지할 수 있는 설계 방식에 대해 더 깊이 이해해야 할 것 같습니다.

예: record_sid와 data_sid를 사용해 상단/하단 구조를 나눌 때, 다양한 비즈니스 로직을 어떻게 통합적으로 처리할지 고민.

PK 통합 방식이 모든 업무에 적합한지, 특정 상황에서는 개별 PK를 사용하는 것이 더 적합한지 판단할 수 있는 기준 마련.

특히, 복잡한 관계를 가진 데이터(다대다, 계층적 데이터 등)를 처리할 때, 통합 PK 구조의 성능과 유지보수성에 대한 구체적인 이해 필요.

이를 해결하기 위해, 기존에 작성된 ERD와 5.0 프레임워크의 설계 문서를 기반으로 다양한 사례를 분석하고, 실제로 소규모 데이터 모델을 설계하는 연습을 통해 경험을 축적할 계획입니다.

또한, 프레임워크의 설계 철학을 더 깊이 이해함으로써, 이론과 실무의 괴리감을 줄이고자 합니다.

---

## 4. 소프트 스킬면에서 성장한 점

오늘 학습을 통해 단순히 **개발 방법론에 치중하는 것의 한계를 넘어**, **이유와 목표를 이해하는 개발자**가 되는 것의 중요성을 깨달았습니다. 개발을 진행하기 전, "왜 이 기능을 구현해야 하는가?", "이 목표를 통해 무엇을 이루고자 하는가?"라는 질문을 던질 줄 알아야만 전체적인 그림을 그리며 나의 역할을 명확히 인지할 수 있다는 점이 인상 깊었습니다.

특히, **전체 목표와 구조를 이해하는 것이 나의 개발 방향성을 잡는 데 필수적**이라는 조언은 제 개발 사고방식을 전환시켜 주었습니다. 이를 통해 단순히 주어진 작업을 수행하는 개발자가 아니라, 프로젝트의 핵심 가치를 이해하고 더 나은 방향을 제시할 수 있는 개발자로 성장해야겠다는 다짐을 하게 되었습니다. 앞으로는 작업의 목적과 이유를 명확히 파악하고, 이를 기반으로 제 능력을 최대한 발휘할 수 있도록 노력하고자 합니다.

---
