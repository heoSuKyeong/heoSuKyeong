# Daily Retrospective

**작성자**: [김도형]  
**작성일시**: [2025-01-03]

## 1. 오늘 배운 내용 (필수)

- 5.0 프레임워크 용어 및 구조 분석
- 어제 내용 복습
- Refer Type
- 그 외 수업 내용
- 5.0 프레임워크의 방향성

### 1. 5.0 프레임워크

#### 1-1. 용어 및 구조 분석

| 용어                           | 개념                                                                                                                                                                                       | 예시                                                                         |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------- |
| `업무(bizz)`                   | ERP 내 주요한 개념 중 하나.                                                                                                                                                                | 판매, 공지사항, 주문                                                         |
| `메뉴(menu)`                   | 업무를 사용자가 사용할 수 있도록 접근 가능한 항목. 즉, 업무를 이용하기 위한 도구.                                                                                                          | 판매 입력, 판매 조회, 판매 현황, 공지사항 조회, 공지사항 입력                |
| `의미있는 데이터 모델(Object)` | 업무/메뉴 내에서 목적과 이유가 존재하는 의미를 지닌 데이터 모델.                                                                                                                           | 조회 검색 폼, 조회 결과 리스트, 현황 결과 리스트                             |
| `데이터 모델(data_model)`      | 데이터 모델은 데이터의 관계, 접근과 그 흐름에 필요한 처리 과정에 관한 추상화된 모형. 데이터 모델은 프로그램에서 다룰 데이터를 정의. 데이터는 하나하나의 항목 `prop` 의 집합.               | 숙제 입력의 제목, 내용, 과목                                                 |
| `속성(Attribute)`              | 설정, 속성, 살아가면서 **_언제든 바뀌는 것들_**                                                                                                                                            | Attribute가 가지는 데이터 구조에는 `attr_type`, `attr_id`, `data`, `prop_id` |
| `명세서(Definition)`           | **_살아가면서 바뀌지 않는것_**, 존재에 대한 정보. 사람으로 비유하면 주민등록등본과 같은 의미를 지니고 있으며, 공통 기능이 동작하기 위한 정보일 뿐, `definition` 자체가 기능을 가지진 않음. | `bizz_definition`, `user_definition`, `menu_definition`                      |

#### 1-2. Bizz Definition 구조로 알아보는 용어의 의미

| 용어                   | 의미                                            |
| ---------------------- | ----------------------------------------------- |
| `id`                   | 업무의 의미에 따라 id를 부여                    |
| `sid`                  | 업무의 고유한 sid, DB 테이블에서 PK와 같은 역할 |
| `type`                 | 재고, 회계, 게시판 등 업무 분류를 구분          |
| `attributes`           | 업무의 속성 목록                                |
| `menus`                | 업무 관련 메뉴 목록                             |
| `objects`              | 업무에서 사용하는 object 목록                   |
| `data_model_templates` | 업무에서 사용하고 있는 데이터모델 템플릿 목록   |

#### 1-3. attribute의 주인

- 글꼴 설정, 글꼴 색상 등을 변경했다. 그렇다면 주인은 누구인가? -> 회사

- 사용자마다 테마 색이 다 다르다. 주인은 누구인가? -> 개인

| 용어        | 개념                                                                                                                                                         | 설명                                                                                                                     |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------ |
| `Owner`     | 추상적인 개념은 속성의 주인 `Owner`가 됩니다.                                                                                                                | 사용자(`User`), 업무(`Bizz`), 메뉴(`Menu`), 항목(`Prop`), 데이터 모델(`data_model`)                                      |
| `Attribute` | 속성은 구체적인 내용을 일반화하고, 추상적인 개념으로 정의한 것을 말하며, 추상적인 개념이 담지 못하는 서로 다른 구체적인 특징들은 속성으로 만들어 관리합니다. | Attribute가 가지는 데이터 구조에는 속성 종류(`attr_type`), 속성의 id(`attr_id`), 속성 내용(`data`), 항목의 id(`prop_id`) |

#### 1-4. Definition의 주인

| 소유 대상   | Definition |
| ----------- | ---------- |
| 업무        | bizz       |
| 메뉴        | menu       |
| 데이터 모델 | data_model |
| 항목        | prop       |

<br>

#### 1-5. Prop 정의

##### A. 개요

| 구분     | 내용                                                |
| -------- | --------------------------------------------------- |
| **정의** | 속성의 주체와 의미를 기반으로 한 데이터 추상화 방식 |
| **목적** | 시스템 내 데이터의 효율적 관리                      |

<br>

#### B. 속성 간 관계와 추상화

##### - Refer Type의 역할

| 항목          | 설명                              | 예시                               |
| ------------- | --------------------------------- | ---------------------------------- |
| **기본 개념** | 속성 간 유사점 기반 추상화 수행   | -                                  |
| **공통 처리** | 동일 refer_type 간 공통 로직 적용 | 공지사항/숙제의 `title`, `content` |

##### - Owner 기반 고유 속성

| 항목          | 설명                         | 예시                       |
| ------------- | ---------------------------- | -------------------------- |
| **처리 방식** | 주체별 속성 처리 방식 차별화 | -                          |
| **고유 속성** | owner별 특수 속성 정의       | 공지사항의 `notice_period` |

##### - Prop와 Attribute의 관계

| 구성 요소   | 역할               | 예시                   |
| ----------- | ------------------ | ---------------------- |
| **prop_id** | 속성의 소유자 지정 | 제목                   |
| **attr_id** | 속성의 세부 정의   | 글자수 제한, 필수 여부 |

<br>

#### C. sid의 개념과 용도

| 항목     | 내용                                     |
| -------- | ---------------------------------------- |
| **구성** | 1~9, a~w의 무작위 15자                   |
| **용도** | 시스템 내 속성의 고유 식별               |
| **특징** | - 데이터 충돌 방지<br>- 추적 가능성 제공 |

<br>

### 2. 어제 내용 복습

**1\. 요구사항**

\- 소스/테이블 1개 만으로 n개 업무를 구현시키고 싶다.

**2\. 요구사항에 대한 문제(고민)**

\- 뭐라도 다를텐데 로직 1개로 어떻게 그 다음을 구현할 것인가?

**3\. 사례**

\- 자리 수 체크일때, 동일한 제목이지만, 공지사항은 10자리, 숙제는 20자리를 기준으로 체크해야 한다.

**4\. 방법**

\- 업무마다 다른 상황을 서류로 작성해주면 기능(로직)은 서류를 바탕으로 다르게 동작하겠다.

<br>

### 기능 명세

- 공지사항 제목 10자리 초과 시 저장 불가
- 숙제 제목 20자리 초과 시 저장 불가
- 숙제의 제목이 입력되지 않으면 과목명으로 대체 (자동 채우기)
- 공지사항의 공지 기한은 필수 입력(필수 체크)

### 요구 사항

- 제목 전용, 내용 전용 이런 식으로 하나의 기능에 종속적이면 안된다.
- 자리수 체크 소스는 1개로 모든 기능을 대체해야 한다.
- 공지사항의 제목은 자리수 10자리, 숙제의 제목은 자리수 20자리로 체크
- 자리수체크는 입력항목의 length가 자리수 속성값보다 크면 저장을 할 수 없다.
- 저장을 할 수 있으면 true를 return, 저장을 할 수 없다면 false return.

<br>

| 용어                  | 정의            | 설명                                                                                 |
| --------------------- | --------------- | ------------------------------------------------------------------------------------ |
| bizz definition       | bizz            | 나를 호출한 업무가 무엇인지 알아야 한다. 공지사항인지, 숙제인지 타입체크가 필요하다. |
| data_model definition | prop            | 나를 호출한 항목이 무엇인지 알아야 한다.                                             |
| prop attr             | attribute value | 자리수 속성값을 알아야 한다. (몇자리로 설정했는지. 몇자리로 체크해야 되는지)         |
| data_model data       | data            | 항목의 값(데이터)                                                                    |

<br>

```ts
자리수 체크() {
var prop = 업무.data_model_definition.props[제목];
var 데이터 = data_model.getValueByReferType(prop.refer_type);

    if(length(데이터) > 자리수 속성값) {
        return false;
    }
    return true;
}
```

<br>

![alt text](/3주차/Day5_금/ref/01-03_김도형.png)

<br>

### 3. Refer Type

- 이카초등학교 1학년 1반 이라고 하는 업무, 메뉴, 데이터모델에는 학생이라는 prop이 존재한다. (학생들=props)

- 데이터 모델에 존재하는 refer_type은 절대 중복되지 않는다.

- refer_type이 존재하지 않는 데이터 모델도 없다.

  <br>

이 데이터모델에는 역할을 담당하는 refer_type이 하나씩 존재합니다. 예를 들어, 1학년에 100개의 반이 존재하고, 반장에게 시험지를 걷으라고 명령을 하려면 반장 이름을 모두 외워야할까요? 그렇지 않습니다. **반장** 이라는 `refer_type`만 알면 100개 반의 반장 이름을 외울 필요 없이, "반장아, 시험지를 걷어줘" 라고 명령하면 됩니다.

#### 1반 : data_model_definition

| prop.id | name   | refer_type |
| ------- | ------ | ---------- |
| 1       | 홍길동 | 반장       |
| 2       | 김나영 | 청소반장   |
| 3       | 김철수 | 학생       |

#### 2반 : data_model_definition

| prop.id | name   | refer_type |
| ------- | ------ | ---------- |
| 1       | 홍길동 | 반장       |
| 2       | 김나영 | 청소반장   |
| 3       | 김철수 | 부반장     |

<br>

### 4. 그 외 수업 내용

**1. 전표 테이블의 기본이 되는 구조**

전표 시스템의 가장 기본이 되는 구조는 세 가지 핵심 식별자로 이루어집니다. `tenant_sid`, `record_sid`, `data_sid`. 이 구조는 모든 전표의 기초가 되며, 특히 처음 두 필드는 `PK`로서 데이터의 고유성을 보장합니다.

**2. 데이터 구조의 계층화**

Definition은 시스템의 기초가 되는 명세서입니다. 주민등록등본과 같이 변하지 않는 기본 정보를 담고 있으며, 그 자체로는 기능을 가지지 않지만 모든 공통 기능의 기반이 됩니다. Data Model Template은 실제 데이터를 담는 그릇의 템플릿으로, 재고싱글, 재고멀티 등 데이터의 기본 형태를 정의합니다. 이는 Data Model Definition을 통해 각 메뉴 타입별로 세분화됩니다. Object는 데이터 모델 중 실제 업무에 필요한 항목들을 특정하는 역할을 합니다. 예를 들어 판매입력 master, 판매입력 detail 등으로 구체화됩니다. Table Model은 데이터베이스와 직접적으로 연결되는 계층으로, DB 테이블과 정확히 일치해야 합니다.

**3. Validator와 Slip Validator**

- validator : 필수 자리 수

- slip validator : 안전 재고 체크

`안전 재고 체크`란 내가 지금 무엇을 파는지, 몇 개를 파는지, 어떤 창고에 있던 물건을 파는지, 몇 개를 남겨야 안심되는 지, 현재 창고에 몇개가 남아있는 지를 파악해야 합니다다. validator는 prop 단위의 data만 알아도 됩니다. slip validator는 데이터 모델 전체의 값을 알아야 동작하는 로직입니다.

**4. 주요한 공통**

ERP 시스템을 개발하면서 가장 큰 깨달음은 `새로 만드는 것`보다 `이미 있는 것을 이해하고 활용하는 것`이 더 중요하다는 점이었습니다. 시스템의 공통 기능들은 마치 레고 블록과 같아서, 이들을 잘 조합하면 새로운 기능을 효율적으로 구현할 수 있습니다.

`가장 기본이 되는 값` 관련 기능부터 살펴보면, 페이지가 로드될 때 자동으로 설정되는 초기값, 사용자의 특정 행동에 반응하여 자동으로 입력되는 자동입력, 그리고 저장 시점에 자동으로 변경되는 값들이 있습니다. 예를 들어, 신규 판매 입력 화면을 열면 창고 정보가 자동으로 설정되고, 거래처를 선택하면 담당자 정보가 자동으로 채워지는 것이 이러한 기능들의 대표적인 예시입니다.

`변경업무`는 사용자의 편의성을 크게 높여주는 기능입니다. 제목을 따로 입력하지 않아도 자동으로 생성되거나, 복잡한 계산이 필요한 금액을 손쉽게 입력할 수 있는 도구를 제공하는 등, 사용자의 작업 효율을 높이는데 중점을 둡니다.

`조건부 속성`은 UI를 더욱 똑똑하게 만듭니다. 특정 조건에 따라 화면 요소를 보여주거나 숨기고, 값을 자동으로 변경하는 등 사용자의 맥락에 맞는 인터페이스를 제공합니다. 예를 들어, 매출전표에서 카드매출이나 세금계산서를 선택했을 때 관련 필드들이 자동으로 표시되는 것이 이런 기능의 좋은 예입니다.
유효성 검사는 시스템의 신뢰성을 보장하는 핵심 기능입니다. 단순한 필수값과 자릿수 체크부터 복잡한 거래 유효성 검증까지, 체계적인 검증 시스템이 구축되어 있습니다.

마지막으로 `파생 기능`은 서로 다른 업무들을 유기적으로 연결해줍니다. 판매 기록이 생성되면 자동으로 이력이 남고, 연관된 업무들이 자동으로 연동되는 것처럼, 시스템 전체가 하나의 유기체처럼 작동하게 만드는 중요한 기능입니다.

이러한 공통 기능들을 개발하면서 깨달은 가장 중요한 점은, 이들이 단순한 코드 조각이 아니라 시스템의 근간을 이루는 중요한 구성 요소라는 것입니다. 새로운 기능을 개발할 때마다 이러한 공통 요소들을 먼저 검토하고, 표준화된 방식으로 접근하는 것이 장기적으로 시스템의 안정성과 유지보수성을 높이는 길이라는 것을 배웠습니다.

<br>

### 5. 5.0 프레임워크의 방향성

5.0 프레임워크의 개발은 막대한 비용과 시간이 투입되는 대규모 프로젝트입니다. 예를 들어, 20명의 개발자가 3년 동안 투입된다고 가정하면 수십억의 비용이 발생합니다. 그럼에도 이러한 투자를 하는 이유는 장기적인 개발 비용 절감에 있습니다. 이를 위해 프레임워크는 두 가지 핵심 전략을 채택했습니다.

#### 1. 통합

유사한 기능을 하는 여러 테이블을 하나로 통합하고, 공통된 쿼리를 사용함으로써 DB 통신 비용을 줄입니다. 예를 들어, 판매, 구매, 견적의 상/하단 테이블을 재고자유형 싱글/멀티로 통합하여 100개의 테이블을 5개로 줄일 수 있습니다.

#### 2. 일반화

고객이 직접 설정할 수 있는 구조를 만들어, 하드코딩 대신 definition과 attribute를 통해 유연하게 시스템을 운영할 수 있게 합니다. 이는 회사별 설정을 속성 테이블로 통합하는 것으로 구현됩니다.
특히 중요한 것은 definition을 통한 접근입니다. definition은 변경하지 않는 기준 정보로서, 이를 바탕으로 공통 기능들이 작동합니다. 우리는 '삐뚤빼뚤한 네모'(definition)를 있는 그대로 두고, 이를 처리하는 '반듯한 네모'(공통 기능)를 만드는 방식으로 개발을 진행합니다.

이러한 개발 방식을 이해하고 효과적으로 활용하기 위해서는 공통된 용어의 사용이 필수적입니다. 업무(Bizz), 메뉴, SID, definition 등의 용어는 개발자들 간의 소통에서 필수불가결한 요소입니다.
결론적으로, 프레임워크 5.0의 목표는 단순한 기능 구현이 아닌, 장기적인 관점에서의 개발 효율성 향상에 있습니다.

<br>

---

## 2. 동기에게 도움 받은 내용 (필수)

현철님께서 따뜻한 점심 식사를 제안하셔서 든든하게 먹고 왔습니다.

강민님과 강의 내용을 듣고, 토론을 진행하였습니다. sequenc_no와 data_no이 필요한 이유가 무엇인지에 대해 서로 얘기하면서 5.0 프레임워크에 대해 조금씩 알아가는 시간을 가졌습니다.

---

## 3. 개발 기술적으로 성장한 점 (선택)

아래의 3가지 주제 중 하나를 선택하여 작성합니다.

### 1. 교육 과정 상 배운 내용이 아닌 개인적 호기심을 해결하기 위해 추가 공부한 내용

- JS 문법을 익히기 위한 코딩 테스트 문제 풀기

문제 : (프로그래머스 - 소수 찾기)[https://school.programmers.co.kr/learn/courses/30/lessons/12921]

```javascript
function solution(n) {
  const prime = new Array(n + 1).fill(true);
  prime[0] = prime[1] = false;

  for (let i = 2; i * i <= n; i++) {
    if (prime[i]) {
      for (let j = i * i; j <= n; j += i) {
        prime[j] = false;
      }
    }
  }

  return prime.filter(Boolean).length;
}
```

### 2. 오늘 직면했던 문제 (개발 환경, 구현)와 해결 방법

- record_sid를 따로 사용하는 이유

처음 ERP 시스템의 테이블 구조를 살펴보면서, `record_sid`의 존재 이유에 대해 의문이 들었습니다. 재고자유형싱글의 상단 테이블과 재고자유형멀티 하단 테이블에서 이미 전표고유키(`data_sid`)가 있는데, 왜 라인 고유키(`record_sid`)를 추가로 사용하는지 이해하기 어려웠습니다. 단순히 전표고유키로 데이터를 조회하고 필요한 컬럼을 추출하는 것이 더 효율적이지 않을까 생각했기 때문입니다. 이러한 의문에 대해 부문장님께서는 "테이블 구조의 통일성을 통해 개발 과정의 고민과 비용을 줄이기 위한 전략적 선택"이라고 설명해주셨습니다. 처음에는 단순히 유지보수성과 개발 비용 절감을 위한 부가적인 요소로만 이해했습니다.

하지만 더 깊이 고민해보니, `record_sid`의 존재는 실제 시스템 성능에도 중요한 영향을 미친다는 것을 깨달았습니다. `record_sid`는 `prop`에서 유일한 키로 작동하기 때문에, `data_sid`로 전체 데이터를 조회한 후 다시 필요한 값을 필터링하는 복잡한 과정을 거치지 않아도 됩니다. 즉, `record_sid`만으로도 원하는 데이터에 직접 접근이 가능해, 데이터 접근의 효율성을 높여주는 것입니다. 이를 통해 `record_sid`가 단순한 구조적 통일성을 넘어, 실제 시스템의 성능 최적화에도 기여하는 중요한 요소라는 것을 이해하게 되었습니다.

### 3. 위 두 주제 중 미처 해결 못한 과제. 앞으로 공부해볼 내용.

지난 이틀 동안 `5.0 프레임워크`의 핵심 개념과 목표에 대해 깊이 있는 학습 시간을 가졌습니다. 개발 비용 절감과 효율성 향상이라는 프레임워크의 핵심 목표, 그리고 이를 실현하기 위한 통합과 일반화 전략에 대해 배우면서 프레임워크의 설계 철학을 이해할 수 있었습니다.

특히, `definition`과 `attribute`를 통한 추상화, 공통 기능의 재사용, 데이터 모델의 계층화 등 프레임워크의 핵심 구조에 대해 이해하는 데 많은 도움이 되었습니다. 하지만 아직 실제 코드 작성과 기능 개발 경험이 없어 이론적 이해에 그치고 있다는 아쉬움이 있습니다. `definition`과 `attribute`가 실제로 어떻게 구현되는지, 공통 기능들을 어떻게 활용해야 하는지 등 실전적인 부분에서는 여전히 많은 궁금증이 남아있습니다.

다음 주부터는 실제 코드를 작성하면서 이러한 이론적 지식을 실전에 적용해볼 예정입니다. `Definition`과 `Attribute`의 실제 구현 방식을 익히고, 공통 기능들을 직접 활용해보면서 프레임워크에 대한 이해를 더욱 깊게 할 수 있을 것으로 기대됩니다. 또한 데이터 모델과 Object의 관계를 직접 코드로 구현해보고, 유효성 검사와 파생 기능의 실제 적용 사례도 만들어보고 싶습니다.

---

## 4. 소프트 스킬면에서 성장한 점 (선택)

- 질문과 경청의 자세

처음에는 너무 기초적인 질문을 하는 것이 아닌가 하는 걱정에 질문을 망설였습니다. 하지만 부문장님께서 "이러한 의문이 드는 것은 당연하다"라고 말씀해주신 것처럼, 의문점을 가지고 질문하는 것 자체가 성장의 과정임을 깨달았습니다. `record_sid`의 필요성에 대한 의문을 제기했을 때처럼, 기초적인 질문이라도 깊이 있는 통찰로 이어질 수 있다는 것을 배웠습니다.

- 개발자의 관점 확장

단순히 코드를 작성하는 것을 넘어, 왜 이런 구조가 필요한지에 대한 본질적인 고민의 중요성을 배웠습니다. 프레임워크의 목표가 단순한 기능 구현이 아닌 장기적인 개발 효율성 향상에 있다는 점을 이해하면서, 개발자로서 더 넓은 시야를 가져야 한다는 것을 깨달았습니다.

- 문서화의 중요성

교육 과정에서 접한 체계적인 문서들을 통해, 지식 공유와 문서화의 중요성을 실감했습니다. 특히 용어 정리와 같은 기본적인 문서조차 팀 전체의 소통 효율성을 크게 높일 수 있다는 점을 배웠습니다. 이를 통해 앞으로는 제가 배운 내용들도 더 체계적으로 정리하고 공유해야겠다는 다짐을 하게 되었습니다.
