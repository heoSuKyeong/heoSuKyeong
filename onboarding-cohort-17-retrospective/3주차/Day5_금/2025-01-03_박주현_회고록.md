# Daily Retrospective

**작성자**: [박주현]  
**작성일시**: [2025-01-02]

# 1. 오늘 배운 내용

## 1️⃣ 5.0 에서 테이블 구조

### (1) 테이블 구조 통일화

5.0 테이블은 PK 로 회사코드 + 레코드ID를 사용합니다.(tenant_sid + record_sid) 레코드 ID 를 사용하는 이유는 각 행들을 구분지을 PK 값이 애매하기에 인조식별자를 만든 것입니다.

하나의 전표를 게시판이라 쉽게 풀어 나타내면 아래와 같습니다.
전표의 상단은 각각이 하나의 요소만 갖는 싱글로 표현하고, 그리드로 표현되는 복수의 요소가 들어가는 하단은 멀티로 구분 짓습니다.

<img src="../ref/박주현 2025-01-03 회고록 이미지2.png"/>

멀티 레코드들은 어느 전표의 멀티 데이터인지 알기위해 data_sid를 FK 로 갖습니다. 싱글 테이블에선 data_sid 로도 충분히 PK 표현할 수 있을 것이라 생각됩니다.
이것은 매우 맞지만, 데이터 테이블 통일성과 이로인한 코드 재사용성을 위해 싱글 테이블에도 record_id 를 갖고 tenant_sid + record_sid를 PK 로 사용합니다.

이런 점은 각각의 트레이드 오프가 있습니다.

> 👍 장점
>
> 데이터 테이블의 구조가 통일화 되기 때문에 메소드에서 각각의 pk 뽑아 다룰 필요 없이 하나의 메소드로 하나의 공통된 pk를 뽑아 로직을 작성할 수 있습니다. 즉 코드 작성을 안하고 기존 코드를 재사용함으로 코드재사용성이 오르고, 개발 비용이 절감됩니다.

> 👎 단점
>
> 테이블에 불필요한 데이터 값을 갖게 됩니다. 이는 데이터가 많아질 때 많은 디스크 공간을 차지하게 됩니다. 정규화 관점에서 바라본다면 좋은 설계는 아닐 수 있습니다.

5.0의 목표이자 철학은 "개발의 비용을 줄이기"입니다. 이걸 실현할 방법으로 통일화를 시키는 것입니다. 구조를 통일화 시키면 정해진 형식에 맞춰 로직을 다룰 수 있게 됩니다. 기능 특화적인 로직이 아니라 하나의 공통된 로직을 재사용해서 개발 비용을 줄이고 코드의 양을 줄일 수 있습니다. 따라서 단점이 있음에도 이런 테이블 형식을 채택하였습니다.

### (2) 싱글과 멀티의 테이블 분리

어제 댓글과 대댓글처럼 하나의 싱글 레코드에서 하단 컬럼을 갖고, 그 컬럼 데이터로 여러 멀티 데이터를 json 형식으로 만들어 넣을 수 있습니다. 하지만 하지만 지금 테이블 구조를 그렇게 하지 않고 있습니다. 컬럼에 멀티 데이터를 json 형식으로 갖는 건 다음과 같은 장단점이 있습니다.

> 👍 장점
>
> 멀티 데이터가 한 컬럼내에 들어가므로 멀티 테이블의 필요 자체가 사라집니다. 이는 디스크 공간을 사용을 크게 줄일 수 있습니다. 연관관계 필요없이 하나의 레코드로 있기에 조회시 필요로 하는 값이 적어집니다. 각각이 다른 필드를 추가하고 없앨 수 있으므로 데이터 스키마 확장성이 높습니다.

> 👎 단점
>
> 하단 멀티 데이터를 조회할 수 없습니다. 싱글 데이터에 종속적이므로 멀티 데이터를 다루기 위핸 싱글 데이터를 통해 조회해야합니다. 한 레코드에 내용이 큰 컬럼이 있다면 데이터 삽입시 성능 문제가 발생할 수 있습니다.

이카운트에선 하단 멀티 데이터도 다른 전표(판매, 견적 등등) 에서 데이터로 사용합니다. 그래서 하나 하나 데이터가 레코드 구조로 있는 것이 더 유용합니다. 데이터를 검색하여 찾을 수 있어야하므로 pk 를 갖는 레코드로서 존재해야합니다. 이런 이유로 판매 상/하단, 구매 상/하단, 견적 상/하단 등으로 나뉘던 테이블이 재고자유형싱글/멀티, 회계자유형싱글/멀티 테이블로 통일화 되어 변경되었습니다.

이는 소스코드에서도 마찬가지입니다. 저장 기능을 예시로 보면 판매저장 -> 상단/하단저장, 구매저장 -> 상단/하단저장, 견적저장 -> 상단/하단저장으로 여러 케이스로 나뉘던 소스들이 재고자유형싱글/멀티저장, 회계자유형싱글/멀티저장으로 통일화됐습니다.

## 2️⃣ 요청의 흐름

클라이언트에서 API 요청을 보내게 되면 다음과 같은 흐름으로 작동합니다.

<img src="../ref/박주현 2025-01-03 회고록 이미지3.png"/>

Action 은 요청의 진입점으로 EntryPoint 입니다. Main Program 은 흐름을 제어하는 곳으로 컨트롤 센터와 비슷한 느낌입니다. 프로그램은 각각의 역할에 맞는 기능을 합니다. 기능을 기준으로 Modifier, Validator, Slip validator 라고 부릅니다.

```
* Modifier
Modifier은 기본값이나 자동으로 채워줘야하는 값들을 채워주는 작업을 합니다.
밸리데이션을 하기 위해선 일단 기초값으로 다 채워지고 나서 그 값을 기준으로 밸리데이션 하기 때문에 Modifier 가 선행되어야 합니다.
```

```
* Validator
Validator은 입력받은 값(즉 클라이언트에서 넘어온 data_model의 데이터) 가 올바른 값인지 체크하는 작업을 합니다.
글자수 체크, 필수 체크 등 여러 작업들이 여기에 해당합니다.
```

```
* Slip validator
Slip validator 또한 유효성 체크 작업을 합니다.
Slip validator은 data_model의 데이터의 값이 올바른지 유효성 검사하는 것보단 이 작업 자체가 이루어질 수 있는지 유효성 체크를 한다는 것과 비슷합니다.


대표적인 예시로 안전 재고 체크가 있습니다.
재고의 수량을 감소시키는 작업을 하려고 할 때 이 작업을 진행하면 안전 재고 컷트라인을 넘는다면 행위를 블락하거나 특수한 처리를 하게 될 것입니다.
(Slip validator은 현재 5.0 개발에서 수정이 예고 되어 있어 Validator에 편입될 수도 있습니다.)
```

어떤 데이터를 수정하기 위해선 2가지가 필요합니다. "어떤 데이터를 수정할 것인지", "어떤 값으로 수정할 것인지" 전자는 기능에 대한 Action 에서 어떤 bizz에 어떤 prop의 Attribute 인지 구할 수 있습니다. 후자는 클라이언트에서 폼데이터로 넘어올 것입니다. 이 전자와 후자의 data_model 들을 DMC로 감싸 각각의 Program의 파라미터에 매개변수로 넣어줄 수 있습니다.

DMC는 data_model container 클라이언트에서 넘어온 data_model 과 어떤 항목을 수정할 것인지 data_model definition 을 셋트로 담는 그릇같은 것입니다. 편하게 수정 대상과 수정 값이라고 명명하겠습니다. 각 Program 들은 DMC 에서 수정 대상과 수정값을 뽑아 각각에 맞는 Modifier와 밸리데이션을 진행합니다. 그리고 마지막에 DB 에 결과가 반영되기 전에 D 테이블과 1대1로 매칭될 수 있는 table_model 로 가공된 후 esql을 통해 DB에 결과가 영구적으로 반영됩니다.

---

# 2. 동기에게 도움 받은 내용

수경님께서 숙취해소스틱을 나눠주셔서 간보호를 챙길 수 있었습니다. 성재님께서 점심시간 같이 식사하실때 반찬 셋팅을 다 해주셨습니다. 현철님께 서비스팀이 어떻게 서비스 기획하는지 이야기를 들었습니다.

---

# 3. 개발 기술적으로 성장한 점

## 3-1. 교육 과정 상 배운 내용이 아닌 개인적 호기심을 해결하기 위해 추가 공부한 내용

Slip validator 가 무엇인지 부문장님께 여쭤보면서 안전재고 검사를 예시로 들어 주셨습니다. 내용에 대한 이해를 하고 나니 1가지 궁금증이 생겼습니다.

> 🤔 궁금증
>
> 재고처리를 동시에 하게 되면 동시성 문제가 발생하겠는데?

동시성 문제(Concurrency Issue)는 여러 사용자가 동시에 동일한 데이터베이스에 접근하여 읽기/쓰기 작업을 수행할 때, 데이터의 일관성(Consistency) 또는 정확성(Accuracy)이 깨지는 문제를 의미합니다.

<img src="../ref/박주현 2025-01-03 회고록 이미지.png"/>

위 사진을 예시로 들면 재고 소모를 2와 3을 진행해서 데이터는 5가 남아야하는데, 10을 조회하고 3을 소모한 값인 7이 반영되어 데이터 정합성 문제가 일어나게 됩니다.

부문장님께선 실제로 동시성 처리를 위해 "버전 체크" 작업을 한다고 말씀해주셨습니다. 동시에 전표를 켜놓고 한 쪽에서 수정을 하고 다른 쪽에서도 다른 값으로 수정을 하려고 하면, 해당 기능이 블락이 되며 다시 조회 후 수정하라고 나타납니다.

"버전 체크" DB 공부할 때 많이 들은 개념이며, 이카운트 5.0의 버전 체크도 해당 개념과 비슷하게 동작할 것이라 추측했습니다.

동시성을 제어하기 위해선 여러 방법이 있지만, 락을 안 쓰고 이카운트의 버전 체크와 비슷한 방법은 2가지를 생각했습니다.

### 1. 애플리케이션 단에서 제어 방법인 낙관적 락

```
📍 개념

낙관적 락은 데이터 갱신 시점에 충돌 여부를 검증하여 동시성 문제를 해결합니다.
락을 미리 걸지 않고, 데이터 수정 시점에서 다른 트랜잭션이 해당 데이터를 변경했는지 확인합니다.

📍 작동 원리

데이터에 버전 필드(version) 또는 타임스탬프(timestamp)를 추가해, 데이터 갱신 시점에 버전이 동일한지 확인합니다.
갱신 시 충돌이 발생하면 예외를 발생시키고, 갱신을 중단합니다.

📍 특징

트랜잭션 충돌이 드물 것으로 가정(낙관적)하고, 동시성을 제어합니다.
트랜잭션 동안 락을 걸지 않으므로, 읽기 성능에 유리합니다.
갱신 시점에만 충돌을 체크하므로 충돌 검증에 추가 비용이 발생합니다.
```

### 2. DB 단에서 제어 방법인 MVCC(다중 버전 일관성 컨트롤)

```
📍 개념

MVCC는 데이터베이스의 동시성 문제를 해결하기 위한 메커니즘으로, 트랜잭션의 읽기와 쓰기 작업을 분리합니다.
각 트랜잭션이 데이터를 읽을 때, 특정 시점의 데이터 스냅샷을 사용하므로 읽기 작업이 쓰기 작업과 충돌하지 않습니다.

📍 작동 원리

데이터를 갱신할 때, 기존 데이터를 즉시 덮어쓰지 않고 새로운 버전을 생성합니다.
각 트랜잭션은 자신이 시작한 시점의 데이터 버전을 읽습니다.
쓰기 충돌이 발생할 경우, 충돌한 트랜잭션이 실패하거나 롤백됩니다.

📍 특징

읽기 작업과 쓰기 작업을 비차단 방식으로 처리하여 동시성을 높입니다.
트랜잭션이 커밋되지 않은 변경 사항은 다른 트랜잭션에서 보이지 않습니다.
일부 쓰기 충돌은 트랜잭션 종료 시점에 감지됩니다.
```

위와 같은 비슷한 방식을 채택하여 기능을 구현했을 것이라 추측했습니다. 버전을 체크하기 위해선 해당 전표가 수정이 되었는지 판가름할 수 있는 지표가 있어야합니다. 이 지표를 통해 수정이 됐음을 추측하고 동시성 처리를 방어할 수 있습니다.

그럼 전표의 수정을 판가름 할 수 있는 지표가 무엇인지 생각해 보았습니다. 그 중 히스토리인 "이력"을 생각해 냈습니다. 실제로 버전 체크 기능에서 이력을 통해 작동하는지는 모르겠지만, 버전을 사용한다면 다음과 같이 "버전 체크" 구현할 수 있습니다.

1. 전표 조회시 가장 최근의 이력 record_sid 값을 같이 조회합니다.
2. 쓰기 작업을 하고 실행하려할 때 다시 한 번 전표 조회시 가장 최근의 이력 record_sid 값을 같이 조회하여 처음 조회시 얻은 record_sid 과 같은지 비교합니다.

   2-1. record_sid가 다르다면 내가 조회하고 난 뒤 누군가 쓰기 작업을 하여 이력이 생긴 것입니다. 이를 통해 해당 작업을 블락하고 다시 조회 후 작업을 하게 할 수 있습니다.

   2-2. record_sid 가 같다면 조회 후 아무런 쓰기 연산이 없다는 것입니다. 따라서 서버에 요청을 정상적으로 보내 쓰기연산을 실행할 수 있습니다.

이 내용을 적다보니 추가적인 궁금증이 생겼습니다.

> 🤔 궁금증
>
> 동시성 문제가 발생하여 버전 체크 후 해당 쓰기 연산을 블락하고 다시 조회 후 작업을 하게 된다. 그렇다면 작업을 다시 하게 될텐데, 만약 엄청 많은 쓰기작업을 하고 실행한 것이라면 그 내용들이 날아가고 다시 작성하는 일이 발생하는데, 이런 사용자 경험은 어떻게 개션했을까?
>
> 다시 조회할시 첫 조회의 스냅샷을 남겨 놓고, 작업은 그대로 내둔 채 수정된 내용만 표시해줄까? 이렇게 되면 사용자 경험을 높인 채 동시성 문제를 컨트롤 할 수 있을 거 같은데?

해당 작업을 테스트 해보고 싶었지만, 80000번에 작업을 할 순없고, 제가 테스트 코드는 없기에 아쉽게도 못해봤습니다. 🥹

---

# 4. 소프트 스킬면에서 성장한 점

DB 관련된 내용이 나오다보니 5.0 개념이 어제보다 조금 더 쉽게 다가왔습니다. 맨 앞자리라 상수 부문장님께서 저에게 엄청 질문을 많이 하시는데, 오늘은 정답률이 높아서 나름 뿌듯했습니다.

---

# 5. 제안하고 싶은 내용

확실히 도식화 된 그림이 있으니 이해가 쉬웠습니다. 여러 개념들도 알맞은 예시가 있다면 그림과 도식으로 표현하면 다음 신입개발자의 이해를 도울 수 있을 거 같습니다.
