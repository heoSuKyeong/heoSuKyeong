# Daily Retrospective

**작성자**: [김도형]  
**작성일시**: [2024-12-30]

## 1. 오늘 배운 내용 (필수)

\- zeus05ba 도메인과 ECOUNT 서버 구조

5.0 프레임워크 환경 설정을 하면서 테스트 서버인 zeus05ba와 서버에 대해 배웠습니다. zeus05ba는 이카운트 개발자들이 개발을 하고 테스트를 할 수 있는 환경입니다. http get 방식의 단점은 URL에 모든 파라미터가 노출되어 보안에 취약합니다. 하지만 이카운트 도메인에서는 보안 팀에서 암호화를 적용하여 파라미터 정보가 노출되지 않습니다. zeus05ba 뒤에 -dev를 입력하면 실제 파라미터 정보를 확인할 수 있게 됩니다. zeus05ba는 3개의 물리적인 서버로 구성되어 있고, 각 서버는 1개의 DB를 바라보고 있는 형태입니다.

위 구조를 추측해보았을 때, zeus05ba는 일반 사용자용으로 암호화된 파라미터를 제공하고, zeus05ba-dev는 개발자용으로 파라미터의 정보를 확인 가능하도록 개발한 것 같습니다. 이러한 구조의 장점과 단점을 생각해보았습니다.

**장점**

개발자는 -dev 환경에서 파라미터를 직접 확인하며 디버깅이 가능하고, 실제 환경에서 동일한 구성으로 테스트가 가능할 것으로 보입니다. 3대의 서버로 로드 밸런싱이 가능하여 부하를 분산할 수 있고, 한 서버가 다운되어도 지속적인 서비스가 가능한 형태입니다. 또한, 동일 DB를 바라보므로 데이터 일관성도 유지할 수 있을 것입니다.

**단점**

3대의 서버가 1개의 DB를 공유하므로 DB 부하 집중 가능성이 있습니다. 다시 말해서, DB 장애 시 전체적인 서비스에 영향을 끼칠 수 있을 것입니다. 또한, 여러 서버 관리로 인한 운영 부담도 존재할 것입니다.

## 2. 동기에게 도움 받은 내용 (필수)

현철님께서 지출 결의서를 작성하는 방법을 알려주셨습니다.

퇴근 후 강민님과 함께 프레임워크 3.0과 5.0은 무엇을 바라보고 동작하는 지에 대해 토론하는 시간을 가졌습니다. 흥미로웠습니다.

---

## 3. 개발 기술적으로 성장한 점 (선택)

아래의 3가지 주제 중 하나를 선택하여 작성합니다.

### 1. 교육 과정 상 배운 내용이 아닌 개인적 호기심을 해결하기 위해 추가 공부한 내용

- 프로미스(Promise)

오늘은 JavaScript의 핵심 개념 중 하나인 Promise에 대해 깊이 있게 학습하고, 이를 TypeScript로 구현해보는 시간을 가졌습니다. 특히 Promise의 기본 구조와 동작 방식에 대해 이전보다 더 명확한 이해를 할 수 있었던 의미 있는 시간이었습니다. 학습을 시작하면서 가장 먼저 Promise의 executor에 대해 알아보았습니다. Promise 생성자에 전달되는 executor 함수가 자동으로 실행되며, 여기서 실제 비동기 작업이 이루어진다는 점이 인상 깊었습니다. 특히 executor가 resolve와 reject라는 두 개의 콜백 함수를 매개변수로 받는데, 이 콜백들이 자바스크립트 엔진에 의해 자동으로 제공된다는 사실을 새롭게 알게 되었습니다.

개발자는 이 콜백들의 구현에 신경 쓸 필요 없이, 비즈니스 로직에만 집중할 수 있다는 점이 Promise의 큰 장점이라고 느꼈습니다. Promise 객체의 상태 관리 방식도 매우 흥미로웠습니다. 처음에는 'pending' 상태로 시작하여, 작업이 완료되면 'fulfilled'나 'rejected' 상태로 변화한다는 점, 그리고 한 번 상태가 변화하면 더 이상 바뀌지 않는다는 특성은 비동기 작업의 안정성을 보장하는 중요한 메커니즘이라는 것을 이해할 수 있었습니다. 이론적인 개념을 학습하고, TypeScript를 사용하여 Promise를 구현해보았습니다. 제네릭 타입을 활용하여 Promise의 결과값 타입을 명시적으로 정의하고, resolve와 reject 콜백 함수의 타입을 정확하게 지정하는 과정에서 TypeScript의 타입 시스템이 주는 안정성을 직접 경험할 수 있었습니다.

```typescript
type PromiseResolveType = any;
type ErrorType = Error;

const promiseCreator = new Promise<PromiseResolveType>(
  (
    resolve: (value: PromiseResolveType) => void,
    reject: (reason: ErrorType) => void
  ) => {
    setTimeout(() => reject(new Error("에러 발생!")), 1000);
  }
);

const promise = promiseCreator
  .finally((): void => {
    console.log("준비 완료");
  })
  .then(
    (result: PromiseResolveType): void => console.log("성공"),
    (error: ErrorType): void => console.log(error)
  );
```

### 참고자료

- [프로미스(Promise)](https://ko.javascript.info/promise-basics)

- [mdn - promise](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise)

### 2. 오늘 직면했던 문제 (개발 환경, 구현)와 해결 방법

오늘은 네트워크 패킷 분석을 위해 피들러를 설정하는 과정에서 예상치 못한 문제를 마주하고 해결하는 경험을 했습니다. Chrome 브라우저에서만 피들러가 정상적으로 작동하지 않았다는 것입니다. 다른 브라우저들에서는 패킷 분석이 정상적으로 이루어졌기에, 어떠한 문제인 지 원인을 파악하지 못했습니다. 하지만 성범 책임님의 조언으로 Chrome에 설치된 확장 프로그램들을 점검해보게 되었고, 실행 중이던 VPN 확장 프로그램이 문제의 원인이라는 것을 발견할 수 있었습니다. VPN이 네트워크 트래픽을 우회시키고 있었기 때문에 피들러가 패킷을 정상적으로 캡처하지 못했던 것입니다.

이 경험을 통해 특정 브라우저에서만 발생하는 문제의 경우, 해당 브라우저의 고유한 설정이나 확장 기능을 우선적으로 확인해볼 필요가 있다는 점과 네트워크 관련 문제 해결 시 VPN이나 프록시와 같은 네트워크 우회 도구들의 영향을 항상 염두에 두어야 한다는 점을 배우게 되었습니다. 앞으로도 비슷한 문제에 직면했을 때, 오늘의 경험을 토대로 더 체계적인 문제 해결 접근이 가능할 것 같습니다. 또한 개발 도구 설정 시 기존에 설치된 도구들과의 충돌 가능성을 미리 고려하는 습관을 들여야겠다고 생각했습니다.

## 4. 소프트 스킬면에서 성장한 점 (선택)

개발 본부장님께서 올려주신 질문 잘 하는 법에 대한 글을 읽었습니다. 본부장님께서 말씀하시는 효과적인 질문의 세 가지 핵심 원칙을 파악했습니다.

1\. 고민의 총량을 미리 정해두자.

무작정 혼자 오래 고민하는 것보다, 적절한 시점에 질문하는 것이 더 효율적이다. 특히 시간이 촉박한 상황에서는 정해둔 고민 시간을 줄이고 즉시 질문을 하는 유연성이 필요하다.

2\. 상대방의 시간을 존중하라.

질문할 때는 두괄식으로 먼저 핵심을 전달하고, 그 다음에 부가적인 설명을 덧붙이는 것이 좋다. 이는 불필요한 추가 소통을 줄이고, 상대방의 업무 집중도를 해치지 않는 방법이다.

3\. 질문을 두려워하지 마라.

대신 질문하기 전에 어떤 고민을 했고, 어디까지 시도해보았으며, 어느 지점에서 막혔는지 그 맥락을 함께 전달하면 효과적이다. 완벽하게 정리되지 않았더라도, 자신의 현재 상황을 명확하게 전달하는 것이 중요하다.

이러한 질문하기 습관은 하루 아침에 형성되지 않겠지만, 계속된 반성과 개선 노력을 통해 점진적으로 발전해야 겠다고 생각하게 되었습니다. 꾸준히 노력하다 보면, 결국 개발자로서의 전반적인 성장에 큰 도움이 될 것임을 깨닫게 되었습니다.
