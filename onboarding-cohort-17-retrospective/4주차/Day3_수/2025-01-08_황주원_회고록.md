# Daily Retrospective  
**작성자**: [황주원]  
**작성일시**: [2025-01-08]  

## 1. 오늘 배운 내용 (필수)  
### 데이터 모델
데이터의 관계, 접근과 그 흐름에 필요한 처리 과정에 관한 추상화된 모형

프로그램에서 다룰 데이터를 정의하며, 데이터를 담고 있는 **DTO**라고 생각하면 된다.

[생성되는 방법] <br />
data_model_template(single) build 하면, data_model(single_list)을 생성하게 된다.

🤔 그럼 ts에서 ts 파일이 생성되는걸까?? 
- data_model 파일을 보면 ``This file is generated by "data model template" and modifying it directly is not allowed.`` 이 파일은 data model template에 의해 생성되었고 바로 수정하는 건 금지되어 있다고 작성되어 있다. template에 의해 자동 생성된다고 이해하면 될 것 같다.

[target] <br />
data model template 코드를 살펴보면 targets 부분이 있는데 어디에서 사용될지를 명세해 놓은 부분이다.

```typescript
{
    prop_id: 'record_seq_no',
    data_type: '$$sequence',
    refer_type: 'record_seq_no',
    is_mandatory: true,
    attributes: {
        Renderer: {
            display_state: false,
        },
    },
    targets: [EN_MENU_TYPE.List, EN_MENU_TYPE.Input, EN_MENU_TYPE.Upload, EN_MENU_TYPE.Trans],
},
```
#### data model vs definition
- definition 
    - 명세 > 내가 어떤 항목들을 쓸거다.
- data_model
    - 견적 업무 | 재고상단 | 재고 입력 에 사용할 데이터를 **DTO**로 지정해줘. (aka. 반찬통)
    - 데이터 타입, prop 을 정의함 
    - 이러한 DTO 중 명세한(definition) 항목들을 사용할 수 있게 된다.

### data model definition vs data model
- data model 
    - DataModelIdentifier 로 구현된 부분
    - inventory_single_input 부분에서는 inventory_single_input 로 정의된 부분을 data model이라고 부른다.
        - ``export const inventory_single_input = new DataModelIdentifier('inv_s_input');``
    - 다른 부분에서 호출할 때도 data model인 'inventory_single_input'을 호출해(import) 사용한다.
- data model definition
    - IDataModelDefinition으로 구현된 부분
    - inventory_single_input 부분에서는 inventory_single_input_Definition 로 정의된 부분을 data model definition이라고 부른다.
        ```typescript
        const inventory_single_input_Definition: IDataModelDefinition = {
            data_model_id: 'inv_s_input',
            props: [
                { prop_id: 'tenant_sid', data_type: '$$sid', refer_type: 'tenant_sid', refer_group: 'sid' },
                ...
            ]
        }
        ```

### prop_id vs refer_type
🤔 prop_id와 refer_type은 같은거 같은데 왜 분리했을까?<br />
+ 아래 코드처럼 refer_type과 prop_id는 같은데 왜 refer_type에서 가져올까 ? <br />
``const prop_ids = this.descriptor.getPropIdsByReferType(refer_type, ...optional);`` 

🅰️ 지금은 같은 값으로 사용되고 있는건 맞다. 하지만 5.0 이상의 프레임워크에서는 prop_id를 unique하지만 의미 없는 난수처리된 값으로 저장되지 않을까? 이 둘을 분리하지 않을까? 하고 있다.

```typescript
{
    prop_id: 'file_des',
    data_type: '$$txt',
    refer_type: 'file_des', // 값 동일
    targets: [EN_MENU_TYPE.List],
    attributes: {
        Renderer: {
            display_state: false,
        },
    },
},
```
### dmc, smc
- smc
    - slip, object_id를 control
    - dmc의 집합
- 아래와 같은 구조를 지님
```typescript
smc : 
	attribute:[]

	dmc: [
		quotationXmaster:
		data_model: [{}]
		attribute: []
	]
```

## 2. 동기에게 도움 받은 내용 (필수)
- 여러 동기들(승준님, 도형님, 지은님, 다은님, 성범책임님, 연아님)을 통해 소소한 궁금증에 대한 답을 이해할 수 있었습니다. 감사합니다! 
- 연아님이 귤 나눔을 해주셔서 든든한 오후를 보낼 수 있었습니다. 감사합니다!  
- 동기는 아니시지만 본부장님께서 $는 변수이고, $$는 타입이라고 알려주셨습니다. 감사합니다!

---

## 3. 개발 기술적으로 성장한 점 (선택)

### 1. 교육 과정 상 배운 내용이 아닌 개인적 호기심을 해결하기 위해 추가 공부한 내용

### 1.1 Action -> Main Program 처리 과정 
Action -> Main 프로그램을 실행하는 과정에서 ``?.attributes?.find((x) => x.attr_id == definition_attrs.info.action_program_resolver)?.data[action_mode];`` 해당 부분의 코드를 이해하지 못했습니다.

성준팀장님께 여쭤본 후 이해할 수 있었습니다. <br />
이해한 과정으로는 아래와 같습니다.

1. CreateInventoryAction.ts
    - ActionProgramResolveProgram 프로그램 실행
    ```ts
    const program = ProgramBuilder.create<
        IActionProgramResolveProgramRequestDto,
        IActionProgramResolveProgramResult
    >(IActionProgramResolveProgram, context);

    const result = program.execute(slip_dto);
    ```
2. ActionProgramResolveProgram.ts
    - input.ts에 명세되어 있는 action_program_resolver data 값을 찾은 후, 해당 프로그램(CreateInventoryProgram) 실행 <br />
    -> definition 을 이해하지 못한 상황에서 input.ts를 찾아가는 과정을 이해하지 못했었습니다.
    ```typescript
        const resolver = this.execution_context.bizz_mgr
			.getMenuDefinition(
				this.execution_context,
				this.execution_context.action.bizz_sid,
				this.execution_context.action.menu_sid || ''
			)
			?.attributes?.find((x) => x.attr_id == definition_attrs.info.action_program_resolver)?.data[action_mode];

		if (resolver) {
			const program = ProgramBuilder.create<ExecuteSetupMainRequestDto, ExecuteSetupMainResultDto>(
				resolver,
				this.execution_context
			);
			return program.execute({
				slip_data_model: slip_data_model,
				additional_info: additional_info,
				derive_info: derive_info,
				current_template: current_template,
			}) as unknown as ProgramResult;
		}
    ```
    2-1. input.ts
    - action_program_resolver를 찾아가고, create로 정의된 CreateInventoryProgram을 실행하게 됩니다.
        ```typescript
        {
			prop_id: '',
			attr_id: definition_attrs.info.action_program_resolver,
			attr_type: EN_ATTR_TYPE.Information,
			data: {
				[EN_ACTION_MODE.Create]: 'ICreateInventoryProgram',
				[EN_ACTION_MODE.Modify]: 'IModifyInventoryProgram',
				[EN_ACTION_MODE.Delete]: 'IModifyStatusInventoryProgram' /* 삭제 */,
				[EN_ACTION_MODE.UnDelete]: 'IModifyStatusInventoryProgram' /* 삭제취소 */,
				[EN_ACTION_MODE.Confirm]: 'IModifyConfirmInventoryProgram' /* 확인 */,
				[EN_ACTION_MODE.UnConfirm]: 'IModifyConfirmInventoryProgram' /* 확인취소 */,
			} as definition_attrs.info.action_program_resolver,
		},
        ```
3. CreateInventoryProgram.ts
    - ExecuteSetupMainProgram를 실행하게 됩니다. 
    ```ts
    private _executeMainSetupProgram(request: ExecuteSetupMainRequestDto): ExecuteSetupMainResultDto {
		const program = ProgramBuilder.create<ExecuteSetupMainRequestDto, ExecuteSetupMainResultDto>(
			IExecuteSetupMainProgram,
			this.execution_context
		);

		// Main 로직에서 SlipDataModelContainer 생성 시 에러, 임시 로직
		// 빈 객체일 경우 새로 생성하지 않고 그대로 사용하여 에러 발생
		// ===================================================
		request.derive_info.smc = new SlipDataModelContainer(this.execution_context, request.slip_data_model);
		// ===================================================

		return program.execute(request);
	}
    ```

아래와 같이 로직이 처리하게 되어 ExecuteSetupMainProgram이 실행됩니다.


### 2. 오늘 직면했던 문제 (개발 환경, 구현)와 해결 방법

🤔 definition에 menu, object 가 있는데 둘의 차이가 뭘까 ?

🅰️ 어렴풋이 코드로 이해한 후 해당 내용이 맞는지 동기들에게 물어보며 파악할 수 있었습니다. 

재고 I > 견적서 탭에서, <br />
견적서입력 / 견적서조회 / 견적서현황 / 미주문현황을 'menu'라고 말한다.

견적서 입력을 클릭하면, <br />
일자, 당당자 등등의 상단 / 규격, 품목코드 등의 하단이 존재한다. 해당 부분들을 object 라고 말한다.

### 3. 위 두 주제 중 미처 해결 못한 과제. 앞으로 공부해볼 내용.
- descriptor는 '업무별 명세에 대한 정보를 관리한다. master.ts  등 파일로 명세한 내용을 descriptor에서 확인할 수 있는 것' 이라고 올려주신 것을 확인했는데, definition과의 차이를 명확히 알지 못해 해당 내용을 확인해 보고자 합니다.

