# Daily Retrospective

**작성자**: [최현철]  
**작성일시**: [2024-12-23]

## 1. 오늘 배운 내용 (필수)

### 디자인패턴

1.  디자인패턴 : ~~이런식으로 짜다보니까 편하더라

2.  이카운트는 커맨트패턴을 사용

        이카운트에서 사용하는 커맨드 패턴은 조금 다름

3.  왜 쓰는지 ?

        이 위치에는 이런 로직이 있을거야 ~ 라는 규칙 > 가독성 / 유지보수 용이
        Ex. 어떻게 실행되는지 > onExcure / 무슨 설정을 이용하지 ? > onConfigure

4.  이카운트 커맨트 패턴 실행 흐름

        Execute: 커맨드 실행의 진입점. 공통 기능
        OnConfigure: 실행 전, 필요한 초기 작업 수행. 비즈니스 로직
        OnExecute: 비즈니스 로직의 실제 구현부

### DB, RDB, RDBMS

1.  DB : 데이터를 어떻게 구조화 / 체계적으로 담을 것인가

2.  RDB

3.  RDBMS : RDB 관리 시스템

        Ex. MySWQL, PostgreSQL ...

4.  SQL

    - DDL : 데이터베이스 구조 변경

          Ex. CREATE / ALTER / DROP

    - DML : 데이터 CRUD

          Ex. SELECT / INSERT / UPDATE / DELETE

    - DCL : DB 사용자 접근관리

          Ex. GRANT (권한부여) / REVOKE (권한회수)

    - TCL : 트랜잭션 관리

          Ex. COMMIT / ROLLBACK / BEGIN도?

### Transaction

1.  ACID 속성

    - 원자성 (Atomicity) : 트랜잭션 내 모든 작업이 성공 OR 실패 / 묶음단위 성공, 실패한단 말인듯

    - 일관성 (Consistency) : 트랜잭션 전후 데이터 일관성 유지

          Ex. 잔액은 음수이면 안된다 / 잔액을 음수로 바꾸는 트랜잭션은 수행되지 않음.

    - 독립성/고립성 (Isolation) : 트랜잭션 간 간섭 없음

    - 지속성 (Durability) : 트랜잭션 완료 후 데이터 영구적 보관

2.  Isolation Level - 독립적인 단위가 어디까지야?

    - 모든 트랜잭션이 같은 Isolation Level을 써야 의미있음

    - 엄격하게 할수록 성능이 이슈

          Ex. DB당 하나의 트랜잭션만 가능

3.  Serialization Anomaly : DB 트랜잭션은 직렬화가 아닌 동시 처리 (병렬?)이다. 따라서, 아래 상황이 발생할 수 있다.

    - Dirty Read : 커밋되지 않은 변경사항을 다른 트랜잭션이 미리 읽는 것 / PG에서는 불가

    - Non-repeatable Read

      - 트랜잭션1에서 로우A를 읽음

      - 트랜잭션2에서 로우A를 수정함

      - 트랜잭션1에서 로우A를 다시 읽음

      - 처음 읽었을 때랑 다른 값이 읽혔음

    - Phantom Read : 있던 로우가 사라졌다 / 없던 로우가 생겼다

      - 트랜잭션1에서 로우A를 읽음 > 있었음

      - 트랜잭션2에서 로우A를 삭제함

      - 트랜잭션1에서 로우A를 다시 읽음 > 없음

    - Write Skew (쓰기충돌) : 10에서 -1 두번했는데 결과 9일 수 있음.

## 2. 동기에게 도움 받은 내용 (필수)

1. 커맨드패턴 구현 과제에서 전원이 꺼져있을 때에도 powerOn이 동작해야하는 것에 대해 주현님께서 어떻게 해결하였는지 (함수로 분리)를 공유해주셔서 쉽게 접근할 수 있었습니다.

2. 커맨트패턴 과제 중/후에 승준/강민님께서 제가 잘 따라오고있는지 확인해주셔서 감사했습니다.

## 3. 추가적인 궁금증 (선택)

1.  프레임워크에 관해서 그림으로 정리해두고 싶은데, 나랑 비슷한 사람들이 분명 있었을 것 같다.
    소스코드를 그림으로 표현하고자하는 개념들이 있지 않을까 ?

    - 설계/구조 : UML

    - 알고리즘 : FlowChart

    - DB : ERD

          codemap, Design Patterns Diagram 등이 있지만 그냥 내방식으로 만드는게 나을듯

2.  Serialization Anomaly이 안일어나게 하려면 무슨 방안들이 있는지 ?

    - (강력) Isolation Level 조절 : 이미 배운거

    - (강력) MVCC 사용

      _\* MVCC : DBMS의 동시성을 제어하는 메커니즘_

          공부필요

    - Lock 사용 : 특정 작업 수행되는 동안 트랜잭션 접근 제한

      _\* Lock되면 트랜잭션 실패하나? 아니면 풀릴 때까지 기다리나 ?_

          대부분은 대기하고 있다가 특정 시간 이후에도 안풀리면 Timeout
          > PG는

      - LOCK 종류
        - Shared Lock : 읽기는 가능 / 쓰기는 불가능
        - Exclusive Lock : 읽기 / 쓰기 모두 불가능
        - Row-Level Lock : 특정 행만 잠금
        - Table-Level Lock : 전체 테이블 잠금

    - 동시성 제어 설계 : 앱단에서 트랜잭션 순서 설계

---

## 4. 도전 과제 (선택)

1. 커맨드 패턴에서 canExcute가 어디에 위치하는게 나은가

---

## 5. 해결 방안 및 배운 점 (선택)

[재희님문의]

- 의미적으로 전원상태를 확인하는 로직인지 / 아닌지로 나눠야함

- Base에 넣게되면 모든 로직이 전원상태를 다 확인하게됨

- 의미적으로 확인이 필요한 애들만 확인하도록 하되, 중복된다면 중복을 해결하는 방안을 추가적으로 모색

---
