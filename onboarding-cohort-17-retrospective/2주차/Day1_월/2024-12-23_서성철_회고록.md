# Daily Retrospective  
**작성자**: [서성철]  
**작성일시**: [2024-12-23]  

---
## 1. 오늘 배운 내용 (필수)  

1. 커맨드 패턴의 개념

    - 행동(요청)을 객체로 캡슐화 하여 호출자와 실행자의 결합을 느슨하게 만드는 디자인 패턴
    - 주로 행동을 재사용, 취소, 로깅, 큐잉하기 위한 용도로 사용
    - 캡슐화 : 서로 연관있는 속성과 기능들을 하나의 캡슐로 만들어 데이터를 외부로부터 보호/은닉하는 것.
    - 결합도 : 호출하는 부분과 행동을 수행하는 객체 부분 사이의 의존성
        > 결합도가 강할수록 유지보수가 어려워지는 느낌
    

2. 커맨드 패턴의 구성요소

    *Command(명령)*
    - 실행할 행동을 정의하는 인터페이스 혹은 추상클래스
    - excute 메서드와 선택적으로 undo 메서드 포함
    
    *ConcreteCommand(구체 명령)*
    - Command 인터페이스 혹은 추상클래스를 구현
    - Receiver 객체의 메서드를 호출

    *Receiver(수신자)*
    - 요청을 수행하는 데 필요한 실제 작업을 구현한 클래스

    *Invoker(호출자)*
    - 사용자의 요청을 Command 객체로 변환하여, 이 객체를 저장하고 실행하는 역할


3. 이카운트 커맨드 패턴

    *Excute*
    - 커맨드 실행의 진입점. 공통기능.

    *OnConfigure*
    - 실행 전, 필요한 초기 작업 수행. 비즈니스 로직.    

    *OnExcute*
    - 비즈니스 로직의 실제 구현부 

    > onExcute 메서드에서만 로직을 구현하면 된다.    


4. 관계형 데이터베이스의 특징

    *무결성*
    - pk, fk, not null, unique등 제약 조건을 제공함
    - 트랜잭션 처리에서 ACID 속성을 보장함

    *SQL을 통한 데이터 관리*
    - 표준화된 쿼리 언어로 복잡한 데이터 처리 및 검색 가능 

    *관계성*
    - 테이블 간 관계를 정의하여 데이터 관리를 효율적으로 가능
    - 1:1 관계 : 한 행이 다른 테이블의 한 행이랑만 연결
    - 1:n 관계 : 한 행이 다른 테이블의 여려 행과 연결
    - n:m 관계 : 여러 행이 다른 테이블의 여러 행과 연결 
        > 연결 테이블 사용. (이카운트 reflect_conn_i?)

    *확장성*
    - 인덱스, 파티셔닝 등으로 데이터가 커져도 성능 유지 가능


5. 트랜잭션

    *기본문법*
    - BEGIN > COMMIT, ROLLBACK
    - MY는 START 또는 BEGIN

    *DB마다 차이점*
    - MY : 기본적으로 자동 커밋이 활성화되어있음. 이를 끄고 트랜잭션을 시작해야함
    - PG : 트랜잭션이 기본적으로 비활성화(수동 커밋 필요), 저장점 및 고급기능 지원
    - MS : 트랜잭션 이름 및 저장점으로 복잡한 트랜잭션을 세분화 할 수 있음

    *정의*
    - DB시스템에서 논리적 작업 단위를 의미
    - 하나의 작업을 완전하게 처리하기 위해 더 이상 쪼갤 수 없는 명령들의 모음 (eg.계좌이체)

    *트랜잭션의 특징 : ACID*
    - Atomicity(원자성) : 트랜잭션은 전부 실행되거나, 전부 실행되지 않아야 함.
    - Consistency(일관성) : 트랜잭션이 성공하면, 성공한 DB는 일관된 상태를 유지.
    - Isolation(격리성) : 동시에 실행되는 트랜잭션은 서로 간섭하지 않음.
    - Durability(내구성) : 트랜잭션 완료 후 변경 내용은 영구적으로 저장.


6. isolation level

    *정의*
    - 트랜잭션 상호간에 얼마나 고립되어 있는지 나타내는 수준
    - SQL표준은 4가지 수준의 트랜잭션 격리를 정의
    - 격리수준이 높을수록 데이터는 정확하나, 성능은 안좋음

    *Dirty Read*
    - commit 되지 않은 변경사항을 다른 트랜잭션이 읽는 상황
    - pg는 모든 수준에서 dirty read를 허용하지 않음

    *Non-repeatable Read*
    - 한 트랜잭션 안에서 똑같은 select 쿼리를 실행했을때, 항상 같은 결과를 가져오지 않는 현상
    - dirty read와 비슷하나, commit된 변경사항을 읽은 것이 다름
    - 예방법
        1) 트랜잭션A가 commit이나 rollback이 될 때 까지 트랜잭션B의 실행을 지연
        2) MVCC를 사용
        > MVCC : 다중 버전 동시성 제어. 원본 데이터에 대한 스냅샷을 찍어서 변경이 취소되면 원본 스냅샷을 기반으로 데이터를 복원.

    *Phantom Read*
    - 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안보였다가 하는 현상
    - 한 트랜잭션안에서 같은 조건으로 여러번 데이터를 읽을 때, 다른 insert, delete와 같은 커맨드로 인해 발생
    - 행의 존재 유무를 따지는 것이 non-repeatable과의 차이점

    *Serialization Anomaly*
    - 트랜잭션들이 동시에 일어나지 않고, 하나씩 순서대로 실행
        - DB에 따라 lock을 사용하여 대기상태에 빠지는 방법이나, 동시에 실행은 되지만 commit시 체크하는 방법을 사용한다
    - 트랜잭션의 동시 실행이 직렬(한 번에 하나씩) 실행과 일치하지 않음을 의미한다

    *정리*
    isolation level   |  Dirty Read         | Non-repeatable Read   |  Phantom Read      |  Serialization Anomaly
    ------------------|---------------------|-----------------------|--------------------|----------------------------
    Read uncommitted  |  Allowed(not in PG) | Possible              |  Possible          |  Possible
    Read committed    |  Not Possible       | Possible              |  Possible          |  Possible
    Repeatable read   |  Not Possible       | Not Possible          |  Allowed(not in PG)|  Possible
    Serializable      |  Not Possible       | Not Possible          |  Not Possible      |  Not Possible           

    이카운트에서는 Read uncommitted 수준의 isolation level을 적용한다.
    - 이카운트 특성상 조회가 중요하기 때문에 성능을 챙김
    - 데이터 무결성이 해쳐질 일이 있긴 있지만, 많지 않음.


---
## 2. 동기에게 도움 받은 내용 (필수)

1. 아연님에게 무한한 감사를 표합니다. 이상한 질문해도 다 받아주시고 다른분께 질문+구글링하면서까지 알아봐주셔요. 그리고 좋은 질문이였다고 자존감까지 채워줍니다.
2. 민준님에게 테스트케이스 작성방법에 대해 배웠습니다. 또 함수를 바로 호출하는게 아니라 함수가 호출된 이후의 값을 받아오는 방법을 알려주셨습니다.
3. 주현님이 주신 데일리코테를 할 수록 자신감이 붙습니다.
4. 성재, 수경, 다은님이랑 저녁을 먹으면서 제네릭과 커맨드 패턴에 관한 얘기를 나누었습니다.
   오늘 구현한 코드에서 return값이 다 boolean이길래 원래 커맨드패턴에서 return값은 항상 boolean인가요?라는 바보 같은 질문을 해도 좋은 질문이라며 자존감을 채워주셨습니다.


---
## 3. 추가적인 궁금증 (선택)

1. 구글링을 통해서 찾아본 커맨드 패턴을 오늘 구현한 과제에 대입해보려고 하니 잘 맞지 않는 부분이 있었다.
    - 행위를 클래스로 만들어서 캡슐화한다는 개념은 동일하나, 구체적인 구성요소에 있어서 1:1로 대응되지 않는 느낌을 받았음.
    - 커맨드패턴의 개념만 가져오고, 실제 구현은 이카운트의 실정에 맞게 변형해서 쓰는건지?

    *구글링한 커맨드 패턴을 오늘 구현한 과제에 적용하면??*
    - Command : BaseCommand
    - ConcreteCommand : RemoteControlAction, ToggleAction, VolumeAction, ChannelAction
    - Receiver : Televison
    - Invoker : TestCase로 호출하는 부분
    
    위처럼 될 거 같은데, 정확히 1:1로 대응하려면 Receiver인 Televison부분에 실제 동작하는 toggle, volume, channel부분이 들어가 있어야 할 것 같다.
    Invoker부분을 따로 구현하지 않은 것도 다르다.


2. 부모 class에선 인수로 dto를 받았는데, 자식 class에선 인수로 dto를 받지 않아도 에러가 나지 않았다. 1개의 인수가 필요한데, 0개의 인수를 가져왔습니다. 를 기대함
    - 반공변성 : 타입이 입력방향에서 자식 > 부모로 대체 가능한 경우, 부모타입이 자식타입으로 대체 될 수 있다.


    
---
## 6. 오늘 느낀 개선점이 있다면? (선택)  

- 첫물꼬를 트는 것이 매우 어렵다.
- 설명을 들을 때는 이해된 거 같은데, 실제 코드로 옮기려니 백지가 되어버림.
- 결국 많이 구현해보면서 익히는 수 밖에..

