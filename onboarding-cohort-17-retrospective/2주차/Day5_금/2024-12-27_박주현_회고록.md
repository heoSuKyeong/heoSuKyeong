# Daily Retrospective

**작성자**: [박주현]  
**작성일시**: [2024-12-27]

## 1. 오늘 배운 내용

### ⭐ git 활용법에 대해서 배웠습니다.

Git은 분산 버전 제어 시스템입니다. 프로젝트의 로컬 복제본이 완전한 버전 제어 레포지토리가 됩니다.
덕분에 오프라인, 원격으로 쉽게 버전관리를 할 수 있습니다.
개발자는 로컬로 작업을 커밋한 다음 레포지토리의 복사본을 서버의 복사본과 동기화 하는 방식으로 버전을 공유할 수 있습니다.

깃의 기능으로는 아래와 같은 기능이 있습니다.

- 분산 버전 관리
- 변경사항 추적
- 브랜치
- 원격 저장소 지원
- 이력 관리
- 병합 및 충돌 해결
- 태그

#### git repository - 깃으로 관리되는 프로젝트 저장소

프로젝트의 모든 파일, 폴더,버전 정보, 이력등을 저장할 수 있습니다. git repository에는

local repository

remote repository

두가지가 있는데 local은 개발자가 작업하는 디바이스 저장소입니다.
중앙저장소의 개념으로 디바이스에 있던 내용을 동기화 시켜서 협업이 가능합니다.

#### 버전 관리 시스템

버전 관리 시스템은 파일 변화를 시간에 따라 기록했다가 나중에 특정 시점의 버전을 다시 꺼내올 수 있습니다.

#### $ git init

git 저장소를 초기화 하고 새로운 로컬 저장소 생성합니다.

git 객체를 만듭니다.

#### $ git status

- git 저장소의 상태 확인
- 현재 작업중인 파일의 변경사항이나 커밋되지 않은 변경 내역 확인
- Working tree status
- Staging area status(커밋을 수행하기 전에 변경된 파일을 모아둘 임시 저장)

#### $ git add 파일명

파일을 stage 영역에 추가

#### $ git add .

작업 디렉토리 전체의 변경된 파일 추가

#### $ git commit

*변경 내용을 저장하고 커밋
*변경된 내용에 대한 스냅샷을 생성하고 스냅샷에 대한 메세지를 작성

- -m 커밋 메시지를 작성하는 옵션

#### 깃 브랜치

코드 변경사항을 병렬적으로 개발할 수 있는 기능을 제공합니다.
새로운 브랜치를 생성하여 기존 소스 코드와는 별개로 작업을 진행할 수 있습니다.
브랜치 간에는 서로 영향을 주지 않는다.
여러 개발자가 동시에 작업할 때 충돌방지할 수 있습니다.

#### 커밋 취소

#### reset

HEAD를 특정 커밋으로 이동합니다.
히스토리를 변경하는 작업이므로 공유된 브랜치에서 사용 시 주의가 필요합니다.
이동 후 변경 사항이 깃 히스토리에서 사라집니다. 옵션에 따라 변경 사항을 제어할 수 있습니다.

```
--hard

변경 사항을 완전히 제거합니다.
```

```
--soft

커밋된 변경사항을 staged 상태로 유지합니다.
현재 staging area 와 working directory는 그대로 유지됩니다.

커밋 메시지를 변경하거나, 여러 커밋을 하나로 합칠 때 유용합니다.
```

```
--mixed

커밋된 변경사항을 unstaged 상태로 유지합니다.
현재 staging area는 초기화되지만 working directory는 유지됩니다.
변경 사항을 다시 준비하려는 경우 유용합니다.
```

#### revert

히스토리를 유지하면서 기존 커밋을 취소하는 새로운 커밋을 생성합니다.
히스토리를 유지하므로 공유 브랜치에서 사용해도 안전합니다.
취소를 위한 커밋이 추가되므로 히스토리가 복잡해진다는 단점이 있습니다.
우리 회사에서 사용되는 브랜치에서는(배포 브랜치 등) revert를 사용하여 커밋을 취소합니다.

### ⭐Ecount 의 브랜치 전략

프로젝트에서 브랜치 전략으로는 GitFlow 전략과 Github 전략을 사용해 봤습니다. 특히나 배민, 토스 등 빅테크 기업들이 사용하는 브랜치 전략을 벤치마킹하여 GitFlow 전략을 사용해 봤는데, 이에 대한 경험이 이카운트의 브랜치 전략을 이해하는 데에 도움이 됐습니다.

feat/이슈번호 브랜치 ➡️ develop 브랜치 ➡️ release 브랜치 ➡️ master 브랜치

feat 브랜치에선 본인의 기능 개발을 하고 로컬에서 api 테스트가 통과해야지만 develop 브랜치에 PR을 보낼 수 있습니다.

develop 브랜치는 테스트 서버와 연동된 브랜치 입니다. pr이 머지되면 cicd 파이프라인을 통해 테스트 서버에 변경사항이 배포됩니다.

release 브랜치는 차기 버전을 위해 기능을 모아두는 브랜치 입니다. stage 서버와 연동됩니다.

master 브랜치는 prod 서버와 연동됩니다. 실제 운영 서버입니다.

hotfix 브랜치는 급한 변경사항을 반영하는 브랜치입니다.

프로젝트를 진행하며 테스트 서버와 운영서버 정도를 이용해 보았고, pm 팀과 QA 를 진행해본 경험이 있습니다. 이카운트에서도 QC 팀과 테스트 서버에서 기능 테스트를 하고 Stage 서버에서 전체 테스트를 진행 한다고 배웠습니다.

<img src="../ref/박주현 2024-12-27 회고록 이미지.jpg"/>
이카운트는 테스트 서버와 스테이징 및 운영 서버의 리모트 레포지토리를 분리 시켜두었습니다.

하나의 레포지토리에서 브랜치로 분기시키지 않고, 휴먼에러를 최대한 막기 위해 원격 레포를 분리시켰습니다.

전체적인 흐름은 GitFlow 전략과 매우 흡사하지만, PR 를 통해 브랜치를 Merge 하지 않고 이원화 원격 레포지토리를 사용한다는 점에서 차이점이 있었습니다.

재희 선임님께서 오늘 수업동안 신신당부하신 말씀이 있는데, 바로 다음과 같습니다.

```
ecount 레포지토리엔 push 하지말자.(엄.근.진)
```

---

## 2. 동기에게 도움 받은 내용

다은님이 맛있는 차를 사주셨습니다. 키보드 구매를 고민하는 저를 위해 지은님께서 자신의 키보드를 사용하게 해주셨습니다. 건호님과 간단한 자바스크립트 내장함수에 대해 이야기 나누며 배웠습니다.

---

## 3. 개발 기술적으로 성장한 점

### 3-2. 오늘 직면했던 문제 (개발 환경, 구현)와 해결 방법

오늘은 타입스크립트로 코테 문제를 풀었습니다. 자바에선 풍부한 라이브러리 제공으로 문자열 가공이 쉽지만, 자바스크립트는 그렇지 않았습니다.

문자열을 가공하게 되면 제일 쉬운 방법으로 + 연산자를 사용하는 방법이 있습니다.
자바에서 String 클래스는 불변 객체이기 때문에 + 연산자를 사용하여 문자를 결합하면 수정이 되는 것이 아닌 다른 객체를 만들고 덮어씌우는 형태입니다. 그래서 힙 메모리를 많이 잡아 먹기 때문에 문자열 수정이 잦다면 가변 객체를 사용해야합니다.

문자열을 다루는 가변 객체로는 자바에서 StringBuilder 와 StringBuffer 가 있습니다. 각각의 객체를 사용하여 문자열 연산을 할수있고 하나의 객체로 가공이 가능합니다. 둘의 차이점은 동기화의 차이입니다.

StringBuilder 은 동기화 처리가 되어 있지 않으므로 멀티 스레딩 환경에선 동시성 문제를 일으킬 수 있습니다.
StringBuffer는 동기화 처리가 되어 있어 멀티 스레딩 환경에서도 스레드세이프합니다.

두 객체 모두 내부에선 배열을 사용하여 문자열을 처리하게 됩니다. 자바스크립트에선 StringBuilder 같은 클래스가 없어서 원초적인 방법과 같이 문자열배열로 처리가 가능합니다.

```
StringBuilder sb = new StringBuilder();
sb.append("123");
sb.append("456");
```

위와 같이 문자열을 가공하려 할때 자바스크립트를 이용하면 다음과 같은 줄 알았습니다.

```
const sb: string[] = [];
sb.join("123");
sb.join("456");
```

하지만 이는 내장 함수를 잘못 사용한 것이었습니다. 배열에 담고 마지막에 toString() 해주듯이 join()를 써야했습니다.

```
const sb: string[] = [];
sb.push("123");
sb.push("456");
sb.join(""); // 자바에서 sb.toString()과 기능적으로 유사
```

join 함수를 쓰게 되면 배열의 각 요소에 마라미터로 받은 문자를 곳곳에 포함하여 문자열을 만듭니다. 위에선 빈 문자열을 받기 때문에 결국 하나의 완성된 문자열을 갖게되는 걸 배웠습니다.

### 3-3. 미처 해결 못한 과제. 앞으로 공부해볼 내용.

git을 통해 이카운트 애플리케이션을 배포하면서 그에대한 인프라와 서버 환경에 대해 의문점이 생겼습니다.
이카운트는 AWS 를 사용하여 서비스를 제공하고 있습니다.

AWS 에서 가상 클라우드 서버를 활용한다면 EC2 또는 Elastic Beanstalk 을 활용할 것입니다. 그리고 이 클라우드 서버엔 AMI 로 오픈 소스인 리눅스 계열에 레드햇, 우분투, Amazon linux 등등을 활요할 것입니다.(과금을 한다면 다음 운영체제...)

실제 이카운트 개발자들은 window os에서 개발을 하고 서비스가 제공되는 클라우드 환경은 linux os 체제입니다.
이는 테스트시 다른 환경변수와 lib, bin 에 의해 테스트에 어려움을 겪을 수 있습니다.
이런 os의 차이와 환경의 차이를 극복하게 해주는 것이 컨테이너 솔루션이고 대표적으로 도커가 있습니다.

그래서 재희 선임님께 이카운트 내에서도 이런 환경 차이에 대한 비효율, 시간 절감을 위해 도커를 활용하는지 여쭤봤지만, 아직 사용하지 않고 사용 계획중에 있다는 답변을 받았습니다.

여기서 2가지 의문점이 생겼습니다. 도커를 활용하지 않는다면, Vmware 같은 하이퍼바이저 솔루션을 활용한다는 말씀일까? 아니면 컨테이너나 가상화 기술을 사용하지 않는다는 말씀일까?

후자라면 그럼 환경 차이에서도 오는 설정 이슈와 그 설정을 맞추고, 테스트의 문제점을 os 레벨에서 찾고, 여러 os 환경을 공부해야하는 인적, 시간적 리소스는 어떻게 극복하는 것인지 궁금했습니다.

추후에 도커를 도입한다면 aws에서 제공하는 ECS 또는 EKS 를 활용할지 아니면 EC2같은 서버에서 IaC 로 도커, k8s 환경을 셋팅해서 다룰지 궁금했습니다.

비즈니스 로직을 개발하는 백엔드 개발자로서 인프라와 네트워크, DB에 관심이 많지만 뽀족한 직무 특성상 다룰 수 없다는 점이 아쉬웠습니다. 5.0 교육을 들어가면 재희 선임님께서 프레임워크 아키텍처에 대해선 교육 받을 수 있지만, 아마도 서버 아키텍처는 배울 수 없을 거란 말을 들었습니다.

거시적 관점에서 이카운트의 솔루션(인프라) 아키텍처 교육도 있었으면 좋겠다는 생각을 했습니다.(어차피 자세한건 주니어라서 모르니 맛보기정도...)

---

## 4. 소프트 스킬면에서 성장한 점

아침밥으로 항상 유부초밥을 싸오는데 오늘은 멸치 볶음을 섞어서 유부초밥을 만들었습니다. 주원님과 아연님께서 훨씬 맛있다고 칭찬해주시면서 4.85점을 받을 수 있었습니다.

마니또로 농담을 하며 동기들과 더 재밌게 지낼 수 있었습니다.

다은님과 수경,지은님과 함께 점심시간에 밖에 나가 차를 사왔습니다. 선배님이 사주셔서 너무 좋았습니다^^ 많이 얻어 먹어서 다음번에 산책 겸 사드려야겠습니다.

1월 2일 5.0 교육이 심화되기 전에 동기들 끼리 회식하자는 말이 나왔습니다. 다들 싫은 눈치도 없고 그렇다고 막 좋아하는 눈치도 없었지만, 모두 모여서 함께 저녁을 먹었으면 좋겠습니다.😊

---

## 5. 제안하고 싶은 내용

깃을 활용하며 실제로 리모트 레포를 두가지를 연동하고 하나의 리모드 레포에 여러명이서 커밋을 푸시하며 실습하는 것이 좋았습니다.
