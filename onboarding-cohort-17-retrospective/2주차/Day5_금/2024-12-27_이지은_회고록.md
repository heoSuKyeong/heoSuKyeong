# Daily Retrospective

**작성자**: [이지은]  
**작성일시**: [2024-12-27]

## 1. 오늘 배운 내용 (필수)

### GIT

#### GIT이란?

-   GIT은 분산 버전 제어 시스템이다. 즉, 프로젝트의 로컬 복제본이 완전한 버전 제어 리포지토리가 된다.
-   오프라인이거나 원격이더라도 버전 관리를 쉽게 할 수 있다.
-   개발자는 로컬로 작업을 커밋한 다음 레포지토리의 복사본을 서버의 복사본과 동기화하는 방식으로 버전을 공유할 수 있다.

#### 버전 관리 시스템

버전 관리 시스템은 파일 변화를 시간에 따라 기록했다가 나중에 특정 시점의 버전을 다시 꺼내올 수 있는 시스템이다.

-   각 파일 및 프로젝트를 이전 상태로 되돌릴 수 있다.
-   시간에 따른 변경사항을 비교할 수 있다.
-   이슈가 발생했을 때 누가, 언제 일으켰는지 추적이 가능하다.
-   파일을 잃어버리거나 잘못 수정한 경우, 쉽게 복구가 가능하다.

#### 버전 관리 시스템의 종류

1. 로컬 버전 관리 시스템
    - 서버 없이 로컬 컴퓨터 내에서 버전을 관리한다.
    - 여럿이 공유하기 어렵다.
2. 중앙 집중식 버전 관리 시스템
    - 누가 무엇을 하고 있는지 알기 쉽다.
    - 모든 클라이언트의 로컬 데이터베이스를 관리하지 않고 중앙 서버 시스템 하나만 관리하므로 관리가 수월하다.
    - 중앙 서버에 문제가 생기면 프로젝트의 모든 히스토리를 잃는다.
3. 분산 버전 관리 시스템 (<- GIT)
    - 클라이언트는 히스토리를 포함한 저장소를 전부 복제한다.
        - 서버에 문제가 생긴다면 이 복제물로 다시 작업을 할 수 있다.
    - 대부분의 분산 버전 관리 시스템에는 리모트 저장소가 존재하며, 리모트 저장소가 많을 수도 있다.

#### 파일의 상태

1. Working Directory
    - `Untracked` : 스냅샷, Staging Area에 포함되지 않은 파일
    - `Tracked` : 스냅샷에 포함되었던 파일
2. Staging Area
    - Tracked 파일이 Staging Area에 포함되면 Staged 상태가 된다.
    - `Staged` : Staging Area에 포함된 상태
3. .git directory
    - Moditied 파일을 commit한 후에는 파일 상태가 Staged에서 Unmodified가 된다.
    - `Modified`/`Unmodified` : 수정 여부 상태

#### GIT 포인터

-   각 commit들은 hash 값을 이용해서 고유한 commit id를 갖는다.
-   commit id를 사용해 커밋을 특정지어 원하는 버전으로 이동하거나, 복구하는 등 버전을 관리할 수 있다.

#### HEAD

-   Git은 `HEAD`라는 특수한 포인터를 사용해 현재 작업 중인 커밋을 가리킨다.
-   `git checkout [commit_id]` 명령어를 사용하면 `HEAD`가 가리킬 commit을 변경할 수 있다.

#### 브랜치

-   브랜치는 특정 커밋을 가리키는 이름표와 같은 역할을 한다.
-   복잡한 commit id가 아닌 브랜치를 통해 쉽게 버전을 넘나들 수 있고, 커밋을 기억해놓을 수 있기 때문에 브랜치 별로 독립적인 버전을 가질 수 있게 된다.
-   checkout 명령어로 HEAD가 가리킬 값을 특정 커밋 id가 아닌 브랜치를 가리키게 하면 해당 브랜치를 이용해서 작업할 수 있다.

#### commit 취소

1. reset
    - HEAD를 특정 커밋으로 이동시킨다.
    - 히스토리를 변경하는 작업이므로 공유된 브랜치에서 사용 시 주의가 필요하다.
    - 이동 후 변경 사항이 깃 히스토리에서 사라진다.
    - 옵션에 따라 변경 사항을 제어할 수 있다.

-   `--hard`: 변경 사항을 완전히 제거한다.
-   `--soft`
    -   커밋된 변경사항을 staged 상태로 유지한다.
    -   현재 staging area와 working directory는 그대로 유지된다.
    -   커밋 메시지를 변경하거나, 여러 커밋을 하나로 합칠 때 유용하다.
-   `--mixed`
    -   커밋된 변경사항을 unstaged 상태로 유지한다.
    -   현재 staging area는 초기화되지만 working directory는 유지된다.
    -   변경 사항을 다시 준비하려는 경우 유용하다.

2.  revert

    -   히스토리를 유지하면서 기존 커밋을 취소하는 새로운 커밋을 생성한다.
    -   히스토리를 유지하므로 공유 브랜치에서 사용해도 안전하다.
    -   취소를 위한 커밋이 추가되므로 히스토리가 복잡해진다는 단점이 있다.

=> 이카운트에서 사용되는 브랜치에서는(배포 브랜치 등) revert를 사용하여 커밋을 취소한다!

#### 브랜치 병합

이 세 가지 방식의 결과물은 동일하지만 히스토리에 남는 이력에 차이가 있다.

1. merge
    - 히스토리를 보존하며, 병합 커밋을 생성하여 두 브랜치의 병합 작업을 기록한다.
    - 새로운 병합 커밋이 생기므로 히스토리가 복잡해지는 단점이 있다.
2. rebase
    - 한 브랜치의 커밋을 다른 브랜치의 커밋 뒤에 재배치한다.
        - 재배치하는 과정에서 재배치하려는 커밋은 변경사항은 동일하지만 새 커밋으로 생성된다. (-> commit id가 달라진다.)
        - 따라서 공유 브랜치에 병합하기 전에 다른 개발자와 공유된 커밋이라면 충돌 위험이 있다.
    - 병합 커밋 없이 히스토리를 직선적으로 정리하기 때문에 깔끔하게 보인다.
3. cherry-pick
    - 특정 커밋 하나를 선택하여 현재 브랜치에 적용한다.
    - rebase와 마찬가지로 커밋을 재배치하므로 새 커밋으로 생성된다.
        - rebase처럼 공유 브랜치에 병합하기 전에 다른 개발자와 공유된 커밋이라면 충돌 위험이 있다.

#### 병합 충돌

-   두 커밋을 병합할 때 서로 같은 부분을 수정했다면 git은 어떤 버전을 적용해야 할지 모른다.
-   사용자는 충돌이 발생한 부분을 수정해서 `--continue` 옵션으로 병합을 재개해야 한다.

#### 리모트(원격) 저장소

-   Git은 분산 버전 관리 시스템으로써 리모트 저장소를 사용할 수 있다.
-   리모트 저장소는 `.git` repository를 업로드, 다운로드 할 수 있는 중앙 저장소이다.
-   로컬 저장소와 달리, 여러 개발자가 같은 프로젝트를 공유하고 협업하기 위해 사용된다.
-   대표적으로 GitHub, GitLab이 등이 있다.
-   리모트 저장소에는 로컬 저장소와 달리 Working Directory, Staging Area가 없으며 커밋된 스냅샷, 브랜치 정보, HEAD 정보와 같은 메타 데이터들이 저장된다.
-   하나의 `.git` repository는 여러 개의 리모트 저장소를 가질 수 있다.
    -   이카운트에서는 두 개의 리모트 저장소를 연결하여 개발용과 배포용으로 나누어 운영하고 있다.

#### GIT 명령어

```
git init

git config --global user.name [이름]
git config --global user.email [이메일]

git add [파일명] # Staged 상태로 변경
git reset [파일명] # Unstaged 상태로 변경
git status # 현재 상태 조회
git commit # Staging Area에 있는 데이터를 local repository에 저장

git checkout [커밋 id] # HEAD가 가리키는 커밋 변경
git log [--oneline] # 깃 log 조회 (--oneline 옵션: log를 간략화 해서 조회)
git reflog # HEAD의 이동 히스토리 조회

git branch [-d] 브랜치명 # 브랜치 생성 (-d 옵션: 경우 브랜치 삭제)
git checkout 브랜치명 # HEAD가 가리키는 브랜치 변경
git log [--all, --graph, --oneline] # (--all 옵션: 모든 브랜치 조회, --graph 옵션: 그래프 모양으로 표시)
git reflog


git revert 커밋id/브랜치명 # 해당 커밋을 이전상태로 되돌리되 변경된 이력을 커밋
git reset [(--hard, --soft, --mixed)] 커밋id/브랜치명 # HEAD를 해당 커밋으로 이동

git merge 커밋id/브랜치명
git merge [--continue, --abort]

git rebase 커밋id/브랜치명
git rebase [--continue, --abort]

git cherry-pick 커밋id/브랜치명
git cherry-pick [--continue, --abort]

git remote add <원격 저장소 명> <원격 저장소 url> # 원격 저장소 추가하기
git remote -v # 저장된 원격 저장소 확인
git push <원격 저장소 명> <브랜치 명> # 원격 저장소에 업로드하기
git fetch <원격 저장소 명> <브랜치 명> # 원격 저장소에서 다운로드하기
git pull <원격 저장소 명> <브랜치 명> # pull = fetch + merge
```

#### `HEAD -> master`와 `HEAD, master`의 차이점

1. `HEAD -> master`

    - 현재 브랜치가 master이고, HEAD는 master 브랜치의 커밋을 추적하고 있다.

2. `HEAD, master`
    - HEAD와 master 브랜치가 동일한 커밋을 가리키고 있지만, HEAD가 특정 브랜치를 가리키고 있지 않다.
    - 이런 경우를 Detached HEAD 상태라고 한다.
        - Detached HEAD는 특정 브랜치가 아닌 특정 커밋 해시를 체크아웃했거나, 브랜치를 임시로 벗어난 상태에서 발생한다.

#### pull과 fetch의 차이점

```
pull = fetch + merge
```

## 2. 동기에게 도움 받은 내용 (필수)

**수경님**: 아연님과 라면을 먹기로 해서 라면을 끓이러 갔다온 사이에 같이 앉으라고 자리를 바꿔놔주셨습니다. 저번에도 배려해주셨는데 감사합니다.

---

## 3. 개발 기술적으로 성장한 점 (선택)

### 1. 교육 과정 상 배운 내용이 아닌 개인적 호기심을 해결하기 위해 추가 공부한 내용

--

### 2. 오늘 직면했던 문제 (개발 환경, 구현)와 해결 방법

입사 전 풀었던 코딩테스트를 타입스크립트로 다시 풀어보는 시간을 가졌다.
이때 자바로 풀었던 코드를 다시 생각하면서 풀다가 어떤 자료형을 써야할지 헷갈리는 부분이 있었다.
그래서 gpt한테 이 부분을 어떤 코드로 수정하는게 좋냐 물어보자 Record 타입이 나왔다.
이에 대해 공부해보자..

#### Record 타입

```ts
Record<Key, Value>;
```

-   Record Type은 TypeScript의 유틸리티 타입 중 하나로, 키(K)와 값(V)의 타입을 지정해 객체를 정의하는 데 사용된다.
    -   Key: 객체의 키로 사용될 타입, 일반적으로 문자열 리터럴 또는 유니온 타입을 사용한다.
    -   Value: 각 키에 매핑될 값의 타입
-   객체의 키를 특정 값으로 제한하고, 키마다 값의 타입을 명시적으로 정의할 수 있다.
-   컴파일 타임에 객체의 구조를 엄격히 확인할 수 있어 안전한 코드를 작성할 수 있다.

코딩테스트 문제에서 요구하는 것은 로그를 **[INFO], [WARN], [ERROR]**와 같은 특정 타입으로 그룹화하는 것이었다. 이때 각 로그 타입은 미리 정의된 세 가지 중 하나여야 한다. 이와 같은 상황에서 Record 타입을 사용하는 이유는 다음과 같다.

-   타입 안전성: `Record<string, CompressedLog[]>`를 사용하면 키가 문자열로 제한되고, 값이 `CompressedLog[]` 타입으로 명확하게 지정된다.
-   정해진 키 값: 문제에서 요구하는 로그 타입은 세 가지로 제한된다. "[INFO]", "[WARN]", "[ERROR]"만 유효하며, 이러한 제한된 키값을 처리하는 데 Record가 적합하다. 해당 문제에서 Map을 사용하면 키로 모든 string을 사용할 수 있기 때문에, 이러한 정해진 키값을 명시적으로 제한하는 기능이 부족하다.

-   간단한 구조와 코드: Record는 객체처럼 동작하지만 타입이 엄격하게 지정되기 때문에, 코드에서 Map보다 간단하게 구현할 수 있다. 각 로그 타입에 대해 키가 정해져 있기 때문에, Record를 사용하는 것이 더 직관적이고 관리하기 쉽다.

### 3. 위 두 주제 중 미처 해결 못한 과제. 앞으로 공부해볼 내용.

> [타입스크립트 핸드북 - Utility Types](https://www.typescriptlang.org/ko/docs/handbook/utility-types.html)

-   Record 타입을 검색하면서 처음 보는 타입들이 많았다. 타입스크립트는 일반적인 타입 변환을 쉽게 하기 위해서 몇 가지 유틸리티 타입을 제공한다고 한다. 타입마다 코드를 구현해보고 사용법을 빠르게 익혀야겠다.

---

## 4. 소프트 스킬면에서 성장한 점 (선택)

재희님이 보내주신 본부장님 글을 읽고 질문 방식에 대해 배울 수 있었다.

1. 고민의 총량을 정해두자.

    - 얼마나 고민할지 나만의 기준을 정하자.
    - 하지만 급한 상황에서는 바로 바로 질문하자.

2. 상대방의 시간을 뺏지 말자.

    - 말하고자 하는 중요한 요지를 가장 첫 부분에 제시하고 그 이후에 부차적인 내용들을 나열하자.
    - 어떠한 것이 궁금한지 또는 결론을 먼저 명확하게 이야기한 후에 관련 내용들을 뒤에 덧붙이자.

    => 두괄식으로 이야기하자!

3. 질문을 두려워하지 말자.
    - 내가 질문하기 전까지 어떠한 고민과 시도를 했고, 어디까지 생각이 도달했으며, 어디에서 막혔는지 맥락을 이야기하면 훨씬 좋은 질문이 된다.
    - 꼭 정리되지 않아도 된다.
    - 이해가 가지 않는다면 이해가 될 때까지 질문하는게 답이다.
    - 질문 습관이 하루 아침에 바뀌지는 않지만, 계속 반성하고 고민하면 좋은 질문을 할 수 있다!

---

## 5. 제안하고 싶은 내용

---
