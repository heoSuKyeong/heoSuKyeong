# Daily Retrospective  
**작성자**: [김민준]  
**작성일시**: [2025-01-21]  

## 1. 오늘 배운 내용 (필수)  

**과제2**

### 1 

```txt
bizz_type: 재고
bizz_id: 견적
menu_type: 입력
```

재고-견적업무를 통한 입력 메뉴를 구현하였습니다.
재고-판매업무를 통한 입력 메뉴를 구현하려고 하니 재고-견적업무의 품목 유효성 체크가 
견적과 다르게 동작해야 된다는걸 확인했습니다.
5.0 소스에서 동일 refer_type의 서로 다른 유효성 체크 요구사항을 어떤 방식으로 처리해야되는지 설명하시오.

- 5.0에서는 각각 업무에 대한 bizz_definition과 menu_defintion이 따로 정의되어 있습니다. 만약 bizz_type이 재고이고 bizz_id가 견적(quotation)과 판매(purchases)라면 각 quotation_menu_definition과 purchases_menu_definition이 따로 나뉘어 있을 것 입니다. 저희가 앞서 배웠던 attribute가 어떻게 처리될까 생각해보면 ExecuteSetupMain 프로그램의 각 Resolver가 attribute 타입에 따라 처리되는 것을 알 수 있었습니다. 결국 질문에 대한 답은 "'{bizz_id}/menu/input.ts' 파일에 EN_ATTR_TYPE.Validator인 Attribute를 추가해야한다 입니다." 또한 default validator를 쓰지 않고 사용자 지정 validator를 정의하기 위해 D:\ecxsolution\ecount.nextv5\ecount.solution\src\02.ecount.infrastructure\ecount.infra.attribute\src\@shared_infra_attribute\validator 디렉토리 아래에 Validators.ts에서 정의한 규칙에 따라 파일 이름을 정해서 생성하면 어떤 validator를 사용할지 지정할 수 있습니다. validator도 generator_selector 처럼 validator를 우선순위에 따라 선택하는 로직이 있습니다.


### 2
아연님 답변이 모범 답안으로 뽑혔는데. setup에서 rendenrer_attrs.fn을 반환하고 이 값을 ui.tsx에서 처리하는 것이 바람직하다는 아연님과 성재님의 의견을 통해 들을 수 있었습니다. 

### 3
모범 답변
GetInventoryInputDataProgram을 살펴 보면 refer_type_attr_generator를 호출해 Attribute를 동적으로 구성할 수 있는 부분이 있습니다. 제 생각에는 InputDataProgram에서 이를 구성해야할 것 같습니다. 왜냐하면 Setup은 동적인 처리를 하지 않는 로직입니다. 그러므로 Get{bizz_id}InputData.ts에서 처리를 해주는데 render_attrs.fn과 render_attrs.hide_fn이 있습니다. 삭제인지 삭제 취소인지에 따라 Generator로 해당 타입의 Attribute를 넣어서 ui에 렌더링할 정보를 내려주면 될 것 같습니다. 
- 2번 답변보다 3번 답변에 어울린다는 피드백을 들었습니다.

### 4
내 생각
- 4번은 질문 자체를 잘 이해하지 못했던 것 같습니다.

모범 답변
- 해당 파일들 내부에서 target_props를 통해 사용할 항목들을 object에서 직접 정의하고 있습니다.


### 5
내 생각
- bizz_type과 resolver는 이미 정의되었다고 생각해서 명세하거나 구현할 필요 없다고 생각했습니다.

모범 답변
- 위의 생각에서 dac까지 추가해야된다고 합니다.

### 6
내 생각
- definition을 이용하기 때문에 공통 모듈을 만들어도 각각의 ui를 만들어낼 수 있다.

모범 답변
- quotation_list, sales_list 둘다 같은 setup, data_model을 사용하기 때문에 inventory_list.tsx로 구현할 수 있다.

### 7
내 생각
- 생성, 삭제 작업에는 필요하지만 조회에서는 필요 없는 기능이 존재합니다. modifier, initializer, derive_slip 등 필요없는 resolver를 빼고 각 작업에 대한 필요한  resolver를 사용하기 위해 따로 나뉘어 있는 것으로 알고 있습니다. 그리고 resolver가 실행되는 순서도 바뀔 수 있기 때문에 이를 고려하여 따로 분리된 것으로 알고 있습니다.

### 8
내 생각
- prop_id는 가변한 값입니다. 업무 로직마다 프로퍼티의 값의 이름이 다를 수 있습니다. 하지만 같은 데이터베이스를 쓰기때문에 결국 데이터베이스에서 인식할 수 있는 값은 같아야합니다. refer_type은 prop_id가 데이터베이스에 접근하기 위해 참조하는 값이고 prop_id는 실제 업무에서 사용되는 프로퍼티 이름입니다. 

모범 답변
- refer_type은 업무에 구속되지않는 해당 항목이 가지고 있는 의미로써, 업무에 종속되지 않음.

### 9
내 생각
- 파일에 직접 설정하는 방식과 generator에 대한 방식에 대한 장단점을 작성함

모범 답변
- 제너레이터를 통해서 생성하는 경우 업무상관없이 해당 레퍼타입이면 속성이 생성되므로, 업무상관없이 적용가능

### 10
내 생각
- 9번과 비슷한 생각으로 작성했습니다.

모범 답변
- 추가할 속성이 조건과 상황에 따라 변할 가능성이 적으면서, 동적으로 처리될 필요가 없을 경우라면 데이터 모델 템플릿에 추가하는 방식이 적합할 것입니다. 반면에 조건과 상황에 따라 속성이 있어야될 때도 있고, 없어야될 때도 있으며, 그 상황이 언제 변할지 모호하거나 동적으로 처리가 될 필요가 있다면 Generator를 사용한 방식이 적합하다고 생각합니다.

## 2. 동기에게 도움 받은 내용 (필수)

- **수경님**이 쌀국수를 사주셨어요. 정말 맛있게 먹었습니다 ㅎㅎ. 그리고 data api 구현에서 해메고 있을 때 버그를 찾는데 도움을 주셨어요.
- **현철님, 도형님**과 같이 쌀국수를 먹었는데 많은 이야기를 해주셔서 좋았습니다.
- **아연님, 성재님**이 2번 문제에 대해서 논의하고 계셨는데 옆에서 들으면서 제가 가진 의문점을 해결할 수 있었습니다.
- **성철님**이 nol4에 대한 것을 알려주시고 그에 대한 자료까지 찾아서 주셨어요!!
- **주현님**이 5.0에 대해 정리한 사진 자료를 공유해주셔서 다시 공부할 수 있는 기회가 되었던 것 같습니다.

## 3. 개발 기술적으로 성장한 점 (선택)
아래의 3가지 주제 중 하나를 선택하여 작성합니다.

### 1. 교육 과정 상 배운 내용이 아닌 개인적 호기심을 해결하기 위해 추가 공부한 내용

**이카운트에서는 왜 http/2를 사용하지 않을까?**

배경
- 현재 이카운트 홈페이지의 개발자 도구 network를 봤을 때 http/1.1를 사용하는 것을 확인했습니다. http/2.0의 다중화, 헤더 압축 기법의 변화로 2.0을 사용하는 곳도 많은 것 같습니다. 그럼에도 불구하고 http/1.1을 사용하는 이유가 무엇일지 생각해보았습니다.

제가 추론한 점
1. 고객사에서 구형 브라우저를 쓰는 경우가 많아 호환성 문제로 도입하기 어렵다.
2. 성능 측정을 해봤더니 생각보다 성능이 개선되지 않았다.
3. 이카운트에서 HTTP를 직접 구현(추측)하기 때문에 변경하기에는 어려운점이 많다.

질문
1. 이카운트에서 http/2.0이 아닌 http/1.1을 선택한 이유가 궁금합니다.
- `현우 팀장님`
    1. 고객 호환성 문제로 도입하지 않았던 이유가 맞습니다. 이카운트 고객 중 익스플로어 사용 비율이 꽤나 높았습니다.
익스플로어도 Window 10 환경 이상은 HTTP2 지원이 됐지만, 고객 중 이전 버전 OS 이용자도 상당수였습니다.
(이 시기 이카운트에서는 익스플로어 이슈로 JS 코드도 ES5 로 작성했습니다.)
    2. 이카운트가 익스플로어를 공식적으로 지원하지 않기로 결정된 것이 22년 초입니다.
    3. 별개로 사내에서 개발자 도구로 네트워크 통신을 까보면 HTTP 1.1 로만 확인이 됩니다.
이유는 사내망으로 네트워크 연결 시, 보안 프록시 서버를 이용하기 때문입니다.
외부 서버 <--> 프록시 서버 <--> 개인PC 로 통신되는데,
외부서버와 프록시서버는 HTTP3 로도 통신되지만, 프록시 서버와 개인 PC 는 1.1 로 통신됩니다.
5.0 개발이 시작되면서 HTTP2 전환 작업이 우선순위가 후순위로 밀려 진행되지 못한 상태입니다.
2. 내부 core에서 오픈소스를 사용하지 않고 HTTP 요청이 들어올 때 직접 요청 정보를 파싱해서 사용하는지 궁금합니다.
- `현우 팀장님`
    - .net 프레임워크에서 제공되는 HTTP 소스를 base 로 저희 필요에 맞게 가공하여 사용합니다. 필요에 따라 요청 header 및 body 를 직접 parsing 하기도 합니다. (ex. 3.0 <--> 5.0 통신) 
3. 웹서버는 보통 http와 tcp를 기반으로 동작하는 것으로 알고 있습니다. 그래서 네트워크에 대한 깊은 이해가 필요하다고 생각하는데 실제 개발함에 있어서 어느정도의 네트워크 이해도가 필요할지 궁금합니다. 현우 팀장님 질문 있습니다.
    - 일반적인 개발 업무(비즈니스 로직)에서는 네트워크를 잘 몰라도 실무 진행이 가능합니다. 다만, 잡의 특성 및 부문에 따라 네트워크 이해가 필요한 경우가 있을 수 있습니다. (메신저, 메일서버). 늘 강조했듯이, 시급함은 떨어지지만 중요도는 높으므로 차츰 공부를 해나가시면 될 것 같습니다.

추가 질문

"필요에 따라 요청 header 및 body 를 직접 parsing 하기도 합니다. (ex. 3.0 <--> 5.0 통신)"

팀장님 답변해주신 것에 대해서 의문점이 있습니다.

질문
- http 요청의 경우 3.0과 5.0 사이의 통신 중에 header와 body를 parsing 하신다고 답변 주셨는데 어떤 이유로 이 부분에 대해서만 직접 파싱하는지 궁금합니다.
    - `현우 팀장님`: 배포 시, ba1 ---> lx_ba1 (nol4 o), ba2 --> lx_ba2 (nol4 x)nol4 플래그가 서버마다 다르게 켜진 상황에서는 3.0과 5.0 은 같이 플래그가 켜진 서버끼리만 소통을 해야 하거든요.


**ts에서 c# 코드를 사용하는 이유**

배경
- Action을 호출하는 과정에서 `$executeAction`이라는 메서드를 보았고 디버깅을 했을 때 구현체를 볼 수 없는 문제가 있었습니다. 

질문
- ts 코드로 Action을 실행시켜도 될텐데 `$executeAction`이라는 c# 코드로 Action을 호출하는 이유가 궁금합니다.
    - `성준 팀장님`: 저도 내부 로직을 보지는 못했지만, 예상하기에는 웹서버 요청을 수신해주는  로직과 연관이 되어서 그럴것 같다고 추측하고 있습니다.

**3번 질문에 대한 이해**

배경
- 오늘 성준 팀장님이 "민준님이 작성한 2번답이 더 3번의 답변과 일치해 보입니다."라고 말씀해주셨는데 제가 Generator에 대해서 공부한 바에 의하면 'refer_type_geneartor'라는 것은 IReferTypeAttrGenerator 타입의 실제 Generator가 어디서 호출되는지에 대한 질문으로 알아들었던 것 같습니다. 그래서 generator의 경우 ReferTypeAttrGeneratorProgram에서 호출되므로 3번 답은 앞선 답변이라고 생각했는데. 

질문
1. 성준님이 답이 2번 답변이 3번 질문의 답변과 일치한다고 하셔서 혹시 ReferTypeAttrGeneratorProgram이 호출되는 시점(Get{bizz_id}InputDataProgram)을 의미하시는 건지 궁금합니다.
2. 제 2번 답변에서 (Get{bizz_id}InputDataProgram)에서 attribute를 동적으로 처리해야한다고 답변을 했었는데 아연님 답변(setup 에서 fn을 반환) 해주는 것과 비교하여 실제 개발에서는 어떤 방식을 사용해야되는지 궁금합니다.
- setup에서 fn 타입의 attr 반환하여 ui에서 분기처리
- data api에서 status_type에 따라 fn, hide_fn을 분기 처리하여 동적으로 처리하는 것
3. 제가 오늘 작성한 과제2 답변 중에 이해가 미흡했던 답변이 있다면 피드백 해주실 수 있는지 궁금합니다.

답변 (`성준 팀장님`)
1. 맞습니다. data를 재조회하는 과정에 대한 설명을 참고하라는 의미였습니다.
    - 제가 질문을 잘못이해했구나.. 
2. setup에서 해당 정보를 가공한다면 어느정보를 가공했는지 파악이 어려워서 
ui에서 분기처리가 더 나아 보입니다.
    - data api에서 처리한다고 답변했는데 다시 생각해보니 ui에서 하는 것이 파악이 더 쉬운 것 같습니다.
3. 제가 지금 조금 바빠서 여유생기면 피드백 드릴께요!

### 2. 오늘 직면했던 문제 (개발 환경, 구현)와 해결 방법

**mergeSetup이 되지 않는 이유**
- load_setup에서 setup 객체가 merge되지 않아서 확인해보니 data api에서 값을 반환받을 때 `Isetup` 타입의 객체가 넘어와야하는데 `wrapping<Isetup>` 형태로 값이 넘어와서 생기는 문제 였습니다.
```ts
// load_setup.ts
mergeSetup(setup, result.value);
```

### 3. 위 두 주제 중 미처 해결 못한 과제. 앞으로 공부해볼 내용.

현우 팀장님께서 3.0-5.0 사이에서는 직접 header를 파싱해야 되는 경우가 있다고 하셔서. 
- nol4 처럼 배포 상태인지 아닌지를 구분하는 단어를 배웠습니다.
- 아직 배포 관련된 내용은 잘 이해하지 못한 것 같습니다. -> 자료를 바탕으로 공부 필요!

오늘 과제2를 하면서 아직 이해못한 부분이 있다는 생각이 들었습니다. (2, 4, 9번) 피드백을 들으면서 다시 `object`나 ui의 역할에 대해서 다시 한번 곱씹어 볼 필요가 있지 않을까 생각이 들었습니다.
## 4. 소프트 스킬면에서 성장한 점  (선택)  

- 오늘 성철님에게 `generator`를 설명하면서 최대한 천천히 이해하셨는지 확인하면서 설명하려 노력했습니다.