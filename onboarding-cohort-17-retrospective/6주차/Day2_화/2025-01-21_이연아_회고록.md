# Daily Retrospective  
**작성자**: [이연아]  
**작성일시**: [2025-01-21]  

## 1. 오늘 배운 내용 (필수)  
### 5.0 과제 이해
오늘 과제를 통해 흐름을 이해했다고 생각했지만, 놓친 부분이 많았다는 것을 깨달았습니다. 과제를 수행하며 고민하는 시간을 가졌고, 동기들의 답변을 보며 많은 도움을 받을 수 있었습니다.

### 1. 5.0 소스에서 동일 refer_type의 서로 다른 유효성 체크 요구사항을 어떤 방식으로 처리해야되는지 설명하시오.

답변 : 사용자 설정이 불가능한 속성에 대해서는 generator를 통해 항목에 따라 필요한 attribute를 생성하여 관리합니다. validator 속성을 generator로 추가하면 각 업무의 유효성 체크를 할 수 있습니다.

### 2. 동일전표를 삭제한 경우와 삭제 취소한 경우 FN 버튼의 표시여부가 달라집니다. 수정 조회 화면에서 관련 구분을 위한 로직을 현재 로직 구조로 어디에 위치시켜야 되는지와 이유를 설명하시오. (데이터를 판단해서 속성정보를 변경해야 되는 경우)

모범 답변(아연님)을 통해 답변 : `foreign_currency_input.tsx` 파일(browser)에서 `동적`으로 처리해주면 된다.</br>
=> `inventory_input.tsx`의 `_fnFilter(setup: ISetup, execution_context: IExecutionContext)` 참고

### 3. 신규 입력 화면, 수정 조회 화면 진입 시 외화코드 목록 정보를 화면에 내리기 위해서 해당 refer_type_generator의 호출 위히는 어디여야 되는지와 이유를 설명하시오.

답변 : GetForeignCurrencyInputDataProgram에서 refer_type_generator를 호출해야할 것 같습니다.

모범 답변(민준님)을 통한 답변 : `GetInventoryInputDataProgram`에서 `refer_type_attr_generator`를 호출해 속성을 `동적`으로 구성할 수 있는 부분이 있습니다. Setup은 동적인 처리를 하지 않는 로직이고, 그렇기 때문에 `InputDataProgram`에서 호출해야 합니다.

### 4. 게시판은 저장소 설정(업무 설정)이 적용되어 있습니다. 저장소 설정이 적용되지 않은 샘플 외화코드 소스에서 저장소 설정 정보의 역할을 어떻게 처리하고 있는지 작성하시오.

답변 : GetForeignCurrencyInputSetupProgram에서 설정한 정보를 GetForeignCurrencySetupAction에서 호출해서 사용하고 있습니다.

모범 답변(주원님)을 통한 답변 : 현재 외화코드에서는 업무를 설정할 때 폴더에서 관리하고 있습니다. 해당 파일들은 `data_model_template`에서 target_props를 통해 사용할 항목들을 object에 직접 정의해서 사용합니다.

### 5. 재고-견적 입력을 개발한 인원이 다음 job으로 재고-판매 입력을 개발하려고 한다. 재고-판매 입력을 담당하는 인원이 개발해야되는 번호들을 선택하고, 선택된 이유와 선택 안한 이유를 간단하게 설명하시오.

답변 :
- 개발해야하는 번호 : 속성에 대한 명세를 각자 해줘야한다고 생각합니다.
1) bizz_type 명세
2) 업무명세
3) input 명세
4) object 명세

- 위에서 명세했던 속성들을 사용하여 공통 로직으로 처리될 수 있다고 생각합니다.
5) 판매저장 유효성 체크 속성 resolver 구현
5) 판매저장 program 구현
6) 판매저장 dac 구현 (상단, 하단)

모범 답변(성재님)을 통한 답변 : 
- 선택한 번호 : 2, 3, 4, 5-2
2) 업무명세 : 재고라는 bizz_type만 같을 뿐 bizz 자체는 서로 다르다.
3) input 명세 : 사용하는 속성이 달라질 수 있다.
4) object 명세 : 저장소에 어떻게 넣을 것인지 서로 달라질 수 있다.
5) 판매저장 program 구현 : 세부 로직이 달라질 수 있다.

- 선택하지 않은 이유 : 
1) bizz_type 명세 : bizz_type은 이미 재고-견적 입력을 통해 이미 명세가 완료 되어 있을 것이다.
5) 판매저장 유효성 체크 속성 resolver 구현 : 하나만 존재해도 속성 값에 따라 다른 프로그램 매칭시켜 줄 수 있다.
6) 판매저장 dac 구현 (상단, 하단) : 테이블 통합으로 인해 따로 구현할 필요 없다.

### 6. 견적 조회의 경우 quotation_list.tsx 페이지로 구현되어 있고, 판매 조회의 경우 sale_list.tsx 페이지로 구현되어 있습니다. 견적 입력, 발주요청 입력 페이지의 경우 inventory_input.tsx로 구현되어 있습니다.
#### 6-1. 견적 조회와 판매 조회를 inventory_list.tsx로 구현할 수 있을지 설명하시오.
#### 6-2. 재고-견적입력 / 회계-매출입력을 common_input.tsx 페이지로 구현할 수 있을지 설명하시오.

답변 :
1. 같은 테이블을 사용하기 때문에 구현할 수 있을 거라고 생각합니다.
2. 재고-견적입력과 회계-매출입력을 생각했을 때, 테이블이 다르기 때문에 구현하기 어려울 것 같습니다.

모범 답변(아연님)을 통한 답변 :
1. 조회의 경우 `bizz_sid`와 `menu_type`을 견적 조회, 판매 조회에 맞춰 요청을 보내면, 각 요청에 맞는 `setup`과 `data_model`을 전달하기 때문에 가능하다.
2. 재고-견적입력 / 회계-매출입력의 경우 `bizz`가 다르기 때문에 구현하기 어렵다.

### 7. Server Layer의 ExecuteSetupMainProgram의 역할을 하는 프로그램이 여러종료가 있는 이유에 대해서 설명하시오.

답변: 현재 ExecuteSetupMainProgram의 로직은 추상화 되어있습니다. Action Mode에 따라 구현된 것은 아니지만, 프로그램 호출 순서가 고정되어 있어 각 역할에 따라 구현되어 있습니다. 호출 순서에 따른 차이에 대해서는 아직 찾아보지 못했습니다. 

### 8. prop_id와 refer_Type에 대해서 간단하게 설명하시오.

답변: 현재는 두 가지가 거의 똑같이 작성되어 있습니다. 간단하게 예시로 공지사항의 제목과 숙제의 제목이 같은 "제목"을 의미해도 prop_id는 다를 수 있습니다. 그렇기 때문에 refer_type을 통해 속성을 명확하게 정의하여 관리할 수 있습니다.

모범 답변(현철님)을 통한 답변 : 
- `prop_id`는 업무 하위에 있는 각각의 개별 항목들을 식별
- `refer_type`은 업무에 관계없이 해당 항목이 가지고 있는 의미, 업무에 종속되지 않는다.</br>
ex) 업무(판매, 견적)에 상관없이 거래처면 사용

### 9. `inventory_single.ts` 데이터 모델 템플릿에 Attribute를 추가하는 경우와 `lately_date_display_state.ts` generator를 통해서 Attribute를 추가하는 경우의 차이점에 대해서 설명하시오.

- 참고 `lately_date_display_state.ts`
```typescript
export const lately_date_display_state: IReferTypeAttrGenerator<renderer_attrs.display_state> = (
	execution_context,
	setup,
	target
) => {
	return {
		prop_id: target.prop.prop_id,
		attr_id: renderer_attrs.display_state,
		attr_type: EN_ATTR_TYPE.Renderer,
		data: false,
	};
};
```

모범 답변(현철님)을 통한 답변 : 
- 데이터 모델 템플릿에 속성을 추가하는 경우 => 해당 업무에만 적용되는 속성
- generator를 통해서 속성을 추가하는 경우 => 업무에 상관없이 적용 가능 

### 10. 9번에서 설명한 속성을 추가할 수 있는 두 가지 방식 중 어디에 소스를 추가하는게 맞다고 생각하는지 설명하시오.

모범 답변(성재님)을 통한 답변 : generator를 사용하여 속성을 추가하게 된다면, 조건과 상황에 따라 동적으로 속성을 사용하고 싶을 때 추가하겠다는 의미입니다. 따라서 추가할 속성이 동적으로 변할 가능성이 많다면 generator를 사용하는 방식이 더 맞다고 생각합니다. 반면, 변할 가능성이 적고 고정된 속성을 사용한다면 데이터 모델 템플릿을 통해 속성을 추가하는 방식이 더 적합할 것입니다.

## 2. 동기에게 도움 받은 내용 (필수)
- 지은, 다은, 수경님과 짧은 간식타임을 통해 리프레시할 수 있었습니다.
- 아연님에게 질문을 하고 대화를 나누면서 궁금했던 점을 해소할 수 있었습니다.
- 주현님이 디렉토리 구조와 전체적인 흐름를 도식화한 자료를 제공해주셨습니다. 진짜 최고!
- 아연님, 민준님, 주원님, 성재님, 현철님의 모범 답변으로 도움을 받을 수 있었습니다.

---

## 3. 개발 기술적으로 성장한 점 (선택)
### 1. 교육 과정 상 배운 내용이 아닌 개인적 호기심을 해결하기 위해 추가 공부한 내용
(추가 정리)

#### 1. ExecuteSetupMainProgram 사용
장점
- 코드 재사용이 가능하며, 속성을 활용해 소스를 일원화할 수 있어 비용 절감 효과를 얻을 수 있다.

단점
- 공통 로직 사용 시 특정 DTO 형식에 맞춰야 하며, 이로 인해 사용하지 않는 불필요한 필드가 포함될 수 있다.

#### 2. Action 직접 호출
장점
- 소스를 직관적으로 파악할 수 있다.

단점 
- 공통 로직의 장점과 반대로 소스 재생산이 늘어난다.

=> 회사의 궁극적인 목표는 비용 절감이며, 이를 위해 하나의 소스를 중심으로 효율적인 코드 관리를 지향해야 한다. 이를 실현하기 위해 공통 로직을 활용하여 중복을 최소화하고, 공통 처리 과정에서 발생하는 차이에 대해서는 효과적으로 처리할 방법을 고민해야 한다.

결론적으로 저의 생각은 1번을 사용하는 것이 좋다고 생각합니다. 직접 호출 방식(2번)은 직관적이고, 이미 클래스명에 역할이 부여되어 있어 사용하기에 깔끔한 장점이 있습니다. 하지만 회사의 궁극적인 목표가 비용 절감이라는 점을 고려하면, MainProgram(1번)을 활용해 하나의 소스를 중심으로 관리하는 것이 더 적합하다고 생각합니다. 
특히, MainProgram에서 각 역할을 resolver로 부여하여 큰 구조 내에서 구현이 이루어진다면, 하나하나 수정해야 하는 작업이 줄어들고 공통화라는 큰 틀에도 부합합니다. 이러한 방식이 효율적일 뿐 아니라, 코드 관리 측면에서도 중복을 최소화할 수 있어 장기적으로 봤을 때 더 좋다고 생각합니다.


### 3. 위 두 주제 중 미처 해결 못한 과제. 앞으로 공부해볼 내용.
과제를 수행하는 중에 몰랐던 부분이 있었지만, 동기들의 답변과 질문을 통해 해결할 수 있었습니다. 다만, 앞으로는 동기들의 도움 없이도 스스로 방법과 이유를 찾아내고, 그 이유를 동기들에게 설명할 수 있을 때까지 더 노력해야겠다고 다짐했습니다. 그럼에도 불구하고 오늘 과제를 통해 생각을 정리하고 고민할 수 있는 유익한 시간을 보낼 수 있었습니다. 