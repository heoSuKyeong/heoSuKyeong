# Daily Retrospective  
**작성자**: [황주원]  
**작성일시**: [2025-01-21]  

## 1. 오늘 배운 내용 (필수)  
[과제 내용 정리]
### 1. 동일 refer_type의 서로 다른 유효성 체크
generator를 사용하여 해당 업무에 필요한 유효성 속성을 생성하여 체크합니다.

### 2. FN 버튼의 유무 체크는 어디에 위치시켜야 될까?
브라우저단에서 FN 속성 값을 가져올 수 있습니다. <br />
FN 표시 유무가 우선 UI 처리이기 때문에 브라우저단에서 처리해야하지 않을까 하고 예상해봅니다.

```typescript
const data_dt_no_fn = dmc.getAttrByAttrId(renderer_attrs.fn, data_dt_no_prop_id as string);
```

### 3. 외화코드 목록을 보여주기 위해 refer_type_geneartor의 호출위치는 어디여야 될까?
InputDataProgram 에서 구성해야 될 것 같습니다. setup은 동적인 처리를 하지 않는 로직이므로 Data API 부분에서 처리해 주어야 합니다. 

Get{bizz_id}InputData.ts 에서 refer_type_attr_program 을 호출하여 UI에 렌더링할 정보를 내려주면 될 것 같습니다.

### 4. 업무설정이 적용되지 않은 소스에서 어떻게 처리하고 있을까?
Object에서 target_props 를 통해 사용할 항목들을 처리하고 있습니다.

### 5. 재고-견적 입력 개발인원이 재고-판매 입력을 담당할 때, 개발할 범위는?

[개발 필요]
- 업무명세
	- bizz type은 같지만, bizz 자체는 다르기 때문에 구현이 필요합니다.
- input 명세 & object 명세
	- 필요한 속성이나 데이터 호출 부분이 다를 수 있습니다.
- 판매저장 program 구현

[개발 필요 X]
- bizz_type 명세
	- bizz_type에 대한 정의는 '재고'-견적을 개발할 때 명세합니다.
- 판매저장 유효성 체크 속성 resolver 구현
	- resolver는 속성 값에 따라 다르게 프로그램 실행시킬 수 있습니다.
- 판매저장 dac 구현 (상단, 하단)
	- 동일한 테이블에 저장하는 로직이기 때문에 통합하여 사용 가능합니다.

### 6. 견적조회와 판매조회를 inventory_list.tsx로 구현할 수 있을까?
bizz_sid와 menu_type을 견적조회, 판매조회에 맞춰 요청보내면 각 요청에 맞는 setup과 data_model을 전달할 것이기 때문에 가능합니다.

#### 6-1. 재고-견적입력 | 회계-매출입력은 가능할까?
아연님의 답변으로는 bizz가 달라 현재 있는 Program들을 고치지 않는 이상 어려울 것 같다. 라고 하셨는데, 현재 있는 프로그램을 고친다면 가능할 것이라 생각합니다.

### 7. Server Layer의 ExecuteSetupMainProgram의 역할을 하는 프로그램이 여러 종류가 있는 이유는?
현재의 소스로는 ExecuteSetupMainProgram 내부 프로그램들의 호출 순서는 변할 수 없습니다.

속성의 실행 순서가 바뀌는 경우는 Main 프로그램을 따로 만드는 방법밖에 없어서 여러 종류가 있다고 알고 있습니다.

### 8. prop_id와 refer_Type에 대해서 간단하게 설명하시오.
refer_type은 **업무에 구속되지 않는** 해당 항목이 가지고 있는 의미로써, 업무에 종속되지 않습니다.


### 9. 데이터 모델 템플릿에 Attribute 추가 | generator를 통한 Attribute 추가
데이터 모델 템플릿에 적용하는 경우 해당 업무에만 적용되는 속성

제너레이터를 통해서 생성하는 경우 업무상관없이 해당 레퍼타입이면 속성이 생성되므로, 업무상관없이 적용가능

### 10. 두 방식 중 어디에 추가하는 것이 맞다고 생각하는지 ?
조건에 따라 변동 가능성이 없는 경우에는 데이터 모델 템플릿에, <br />
조건과 상황에 따라 동적으로 처리될 가능성이 있는 경우에는 Generator 방식이 적합하다고 생각합니다.

또한, data model template의 경우 data_model 명세에 대해 관리하는 역할이므로, <br />
속성 정보는 generator를 통해 관리합니다.

## 2. 동기에게 도움 받은 내용 (필수)
- 동기들의 답변을 보고 비교해 보며 더 빠르게 이해할 수 있었습니다. 감사합니다.

---

## 3. 개발 기술적으로 성장한 점 (선택)
### 1. 교육 과정 상 배운 내용이 아닌 개인적 호기심을 해결하기 위해 추가 공부한 내용
### ExecuteSetupMainProgram
서버든 브라우저든 둘의 역할을 정의해보자면, <br />
'가진 속성에 따라 어떠한 프로그램을 호출할지 알려주는' 역할입니다. 

어떤 속성을 가지고 있는지 몰라도 속성이 있다면 프로그램을 호출하게 됩니다. 

### UserAction > ExecuteSetupMainProgram(브라우저) 호출했을 때 <br />
장점으로는, 공통적인 로직별로 일반화가 가능합니다. 그래서 코드상 수정해야 할 부분이 있으면 수정에 수월합니다. 

단점으로는, 수행 로직을 파악하기 어렵습니다. 모든 과정을 추상화하고 있기 때문에 어떤 Action 을 호출할 것인지 이해하기 어렵습니다. <br />
또한, 각각의 책임이 너무 큽니다. ExecuteSetup 프로그램에서는 하나의 책임을 가지고 있는 것이 아닌 수많은 로직들이 구현되어 있어 불필요한 필드들이 있을 수도 있다는 것입니다.

그렇다면 5.0에서 바라는 것은 ExecuteSetupMainProgram을 호출하는 것인데, 그 이유는 뭘까?  <br />
5.0은 '공통화'와 '추상화'가 주 목적이기 때문에 몇 가지의 단점이 존재하지만 프로그램을 호출하는 이유입니다.

### 서버 Action 직접 호출
장점으로는, 실행해야 할 서버 Action이 직관적이라는 것입니다. 
단점으로는, 코드가 길어진다는 것입니다. 직접 데이터를 매핑하는 부분이 있어 많은 오류를 발생시킬 수 있습니다. 

이카운트가 아닌 곳에서 구현한다고 했을 때 <br />
'공통화', '추상화' 가 주 목적이 아닌 단순성과 직관성을 저는 조금 더 선호합니다. <br />
DTO나 프로그램에서 각각의 책임이 분명한 것을 선호하는데, 추상화를 하게 되면 선택적 속성으로 구현된 부분 등의 이유로 <br />
후자인 서버 Action 직접 호출 방식을 사용할 것 같습니다. 
<br />

🤔 Dac 은 추상화가 가능할까?

🅰️ action_mode 에 따라 commonDac을 호출하면 가능할 수 있습니다. <br />
저장 프로시저를 호출하는 방법도 있습니다.

-> A라는 성준 팀장님의 답변을 받았습니다. 팀장님의 방향이 아닌 전체 추상화를 고민했었는데, 그 과정에서 '추상화의 범위', '추상화의 장단점'을 다시 한 번 생각해 볼 수 있었습니다.


### 3. 위 두 주제 중 미처 해결 못한 과제. 앞으로 공부해볼 내용.
- action_mode의 범위가 아직 잘 감이 안 잡힙니다. DB를 기준이라고 하기에는 실행할 것들의 정의의 의미도 함께 들어가고 있는 것 같아 조금 더 공부 할 필요가 있습니다.

## 4. 소프트 스킬면에서 성장한 점 
아침 일찍 출근해 수경님과 ExecutSetupMainProgram을 공부해 봤습니다. 서로 의견을 시간을 두고 얘기해 보며 프로그램에 대해 더 이해할 수 있었습니다.

주어진 과제에서 동기들의 답변을 제가 도출한 답과 비교해 보며 이렇게 생각할 수도 있구나를 느낄 수 있었습니다. 
