# Daily Retrospective

**작성자**: 허수경

**작성일시**: 2025-01-21

## 1. 오늘 배운 내용 (필수)

### 5.0의 이해 문제

- 오후 시간 동안 `5.0의 이해 문제` 주제로 과제를 풀었습니다.

#### 1.

```
bizz_type: 재고
bizz_id: 견적
menu_type: 입력

재고-견적업무를 통한 입력 메뉴를 구현하였습니다.
재고-판매업무를 통한 입력 메뉴를 구현하려고 하니 재고-견적업무의 품목 유효성 체크가 견적과 다르게 동작해야 된다는걸 확인했습니다.
5.0 소스에서 동일 refer_type의 서로 다른 유효성 체크 요구사항을 어떤 방식으로 처리해야되는지 설명하시오.
```

**(나의 답변)**
재고-판매 업무를 위한 validator 파일을 생성합니다. validator 파일을 찾아가는 방식이 여러 가지 존재하므로, 동일한 refer_type과 input을 갖고 있더라도, attr_id와 bizz_id 등을 활용하여 독립적으로 유효성 검사를 수행할 수 있다고 생각합니다.

#### 2.

```
FN 버튼의 표시여부가 특정 데이터에 따라 판단되어야 된다.
삭제된 전표를 조회한 경우는 FN버튼이 표시 되지 않습니다.

동일전표를 삭제한경우와 삭제취소한 경우, 수정 조회 화면입니다.
이카운트의 기능은 삭제된 전표도 조회할 수 있는 기능이 존재합니다.

관련 구분을 위한 로직을 현재 로직 구조로 어디에 위치시켜야 되는지와 이유를 설명하시오.
(데이터를 판단해서 속성정보를 변경해야 되는 경우)


(참고)
삭제한 경우 일자항목의 FN 버튼이 표시되지 않습니다.
```

**(아연님의 답변)** setup을 prop_id: 'xxx$xxx', attr_id: renderer_attrs.fn, 처럼 작성한다.

**(이해한 점)** 추가적으로, 아연님의 답변은 data와 setup의 정보를 모두 알수있는 ui 시점에서 `fn`의 여부를 파악 할 수 있다는 의미이다. UI에서 Setup/Data 정보를 들고 action_mode에 따라 버튼을 필터링하는 것과 유사하게 생각하면 된다.

3.

```
견적입력에서 사용되는 외화코드의 경우, 외화코드 목록을 조회해 오는 로직을
refer_type_generator를 통해 구현되어 있습니다.

신규 입력 화면, 수정조회 화면 진입시 외화코드 목록 정보를 화면에 내리기 위헤서,
해당 refer_type_geneartor의 호출위치는 어디여야 되는지와 이유를 설명하시오.

(참고)
foreign_currency_render_items_Input.ts
D:\ECXSolution\ecount.nextv5\ecount.solution\src\03.ecount.usecase\ecount.usecase.common\src\server\attr_generator\refer_type\render_items\foreign_currency_render_items_Input.ts
```

**(민준님의 답변)** GetInventoryInputDataProgram을 살펴 보면 refer_type_attr_generator를 호출해 Attribute를 동적으로 구성할 수 있는 부분이 있습니다. 제 생각에는 InputDataProgram에서 이를 구성해야할 것 같습니다. 왜냐하면 Setup은 동적인 처리를 하지 않는 로직입니다. 그러므로 Get{bizz_id}InputData.ts에서 처리를 해주는데 render_attrs.fn과 render_attrs.hide_fn이 있습니다. 삭제인지 삭제 취소인지에 따라 Generator로 해당 타입의 Attribute를 넣어서 ui에 렌더링할 정보를 내려주면 될 것 같습니다.

**(나의 답변)** `ReferTypeAttrGenertatorProgram`에서 호출합니다. 해당 파일에서는 AttrList의 refer_type_attr_map을 통해 항목에 설정할 속성을 가져오고 해당 속성을 기준으로 generator 파일을 찾습니다.(generator_selector)

4.

```
게시판은 저장소 설정 (업무설정)이 적용되어 있습니다.
현재 저장소 설정 (업무설정)이 적용되지 않은 샘플 외화코드 소스에서
저장소 설정 (업무설정) 정보의 역할을 어떻게 처리하고 있는지 작성하시오.
```

**(주원님의 답변)** 업무(bizz) 설정을 할 때, 폴더에서 관리하고 있습니다. 해당 파일들 내부에서 target_props 를 통해 사용할 항목들을 object에서 직접 정의하고 있습니다.

**(나의 답변)** 샘플 외화코드 소스에서는 setup 파일 정보를 통해 처리하고 있습니다. setup 파일 속 attr_type을 render 로 표시하여 보여주고 있습니다.

**(이해한 점)** 저장소 설정은 object에서 담당하고 있으며 또한 `target_props`를 통해 사용할 항목들을 설정할 수 있습니다.

5.

```
재고-견적 입력을 개발한 인원이 다음 job으로 재고-판매 입력을 개발하려고 한다.
재고-판매입력을 담당하는 인원이 개발해야되는 번호들을 선택하고,  선택된 이유와 선택안한 이유를 간단하게 설명하시오.

1) bizz_type 명세
2) 업무명세
3) input 명세
4) object 명세
5) 판매저장 유효성 체크 속성 resolver 구현
5) 판매저장 program 구현
6) 판매저장 dac 구현 (상단, 하단)
```

**(성재님의 답변)**

1. bizz_type 명세 (x) : 재고-견적 입력을 개발하면서 이미 명세가 완료된 상태일 것입니다.
2. 업무명세 (o): 재고라는 bizz_type은 같지만 bizz 자체는 서로 다릅니다. 따라서 명세해주어야 합니다.
3. input 명세 (o): 둘다 입력이라는 의미는 동일하지만, 사용할 속성이 달라질 수 있습니다. 파생 정보가 달라질 수도있고 등등의 이유입니다.
4. object 명세 (o): 저장소에 어떻게 넣을 것인지 등등이 서로 달라질 수 있기 때문입니다.
5. 판매저장 유효성 체크 속성 resolver 구현 (x): 유효성 체크 속성 resolver의 경우 resolver는 동일한 하나만 존재해도 속성값에 따라 다른 프로그램을 매칭시켜줄 수 있습니다.
6. 판매저장 program 구현 (o): 판매를 저장할 때 세부 로직이 달라질 수 있기 때문에 선택했습니다.
7. 판매저장 dac 구현 (상단, 하단) (x): 테이블 통합이 됐기에 판매저장 dac의 구현과정은 필요하지 않습니다.

6)

```
견적조회의 경우 quotation_list.tsx 페이지로 구현되어 있고,
판매조회의 경우 sale_list.tsx 페이지로 구현되어 있습니다.

견적입력, 발주요청입력 페이지의 경우 inventory_input.tsx로 구현되어 있습니다.

견적조회와 판매조회를 inventory_list.tsx로 구현할수 있을지 설명하시오.
추가로, 재고-견적입력 / 회계-매출입력을 common_input.tsx 페이지로 구현할 수 있을지 설명하시오.
(소스관점으로 설명하지마시고,  5.0 개념 관점으로 설명해주세요.  참고된 소스를 보면서 시간을 잡아먹지 말라는 의미입니다.)
```

**(아연님의 답변)** 견적조회와 판매조회를 inventory_list.tsx로 구현가능하다.

```
@page_impl({
    identifier: IInventoryInputPage,
    setup: IGetInventorySetupProgram,
    data_model: IGetInventoryDataModelProgram,
    render_page_progress_on_initial_header: true,
})
```

bizz_sid와 menu_type을 견적조회, 판매조회에 맞춰 요청보내면 각 요청에 맞는 setup과 data_model을 전달할 것이기 때문에 가능하다.
재고-견적입력/회계-매출입력의 경우 bizz가 달라 현재 있는 Program들을 고치지 않는 이상 어려울 것 같다.

---

## 2. 동기에게 도움 받은 내용 (필수)

- 주원님과 일찍 출근하여 오전 업무 전에 ExecuteSetupMainProgram에 대해 정리하는 시간을 가졌습니다. 서로 의견을 나누며 공부한 덕분에 프로그램에 대한 이해를 더 깊게 할 수 있었습니다.
- 다은님께서 자바스크립트 용어집을 공유해주셨습니다.
- 아연님 덕분에 성철님께 커피를 얻어먹을 수 있었습니다. 두 분께서 따뜻한 분위기를 만들어주셔서 정말 감사합니다.
- 다은님, 지은님, 연아님과 대화를 나누며 사기를 북돋을 수 있었습니다.
- 민준님께서 회사에서 HTTP 1.1을 사용하는 이유를 현우 팀장님께 여쭤보고 답변을 공유해주셨습니다. 지식을 나눠주셔 감사합니다.
- 아연님께서 ExecuteSetupMainProgram의 단점에 대해 새로운 시각을 제시해주셨습니다. 추가로 질문을 드렸을 때 친절히 답변해주셔서 감사했습니다.
- 주현님께서 5.0 프레임워크에 대한 도식도를 공유해주셨습니다. 덕분에 프레임워크 구조를 더 직관적으로 이해할 수 있게되었습니다.

---

## 3. 개발 기술적으로 성장한 점 (선택)

### 1. 교육 과정 상 배운 내용이 아닌 개인적 호기심을 해결하기 위해 추가 공부한 내용

### `ExecuteSetupMainProgram`의 이해

- 어제 성준팀장님과 개인 면담을 통해 해당 프로그램의 이해가 부족하다는 것을 알았습니다. 그래서 동기들의 답변과 엄지희 선임님의 지식 공유글을 보고 이해할 수 있었습니다.

**ExecuteSetupMainProgram 개념과 역할**

- ExecuteSetupMainProgram은 업무의 속성을 기반으로 적합한 resolver 프로그램을 실행시키는 역할을 담당합니다.
  5.0 프레임워크 목적은 공통화이기에 서로 다른 업무 특성을 처리하기 위해, attribute와 definition이라는 개념을 활용하여 속성을 조립하고 이를 기반으로 resolver 프로그램을 실행합니다.
  구체적으로, dmc가 보유한 속성을 기준으로 미리 정의된 resolver 프로그램이 실행되며, 이 과정에서 비즈니스 로직이 처리됩니다. 재고 저장 업무와 매출 저장 업무가 각각의 비즈니스 로직을 요구하더라도, 속성을 기준으로 적합한 resolver 프로그램이 실행되기 때문에 공통화가 가능해집니다.

**ExecuteSetupMainProgram의 장점**

- 추가적으로 제가 생각한 장점은 비즈니스 로직의 역할 분리와 명확성입니다.
  UserAction에서 ExecuteSetupMainProgram을 실행함으로써, 프로그램별 세부 실행을 해당 프로그램에게 위임할 수 있습니다. 역할 분리를 명확히 하고, 각 resolver가 담당하는 업무 로직의 책임을 명확히 구분하여 집중시킬 수 있다고 생각합니다.

**ExecuteSetupMainProgram의 단점**

- 아연님의 답변을 통해 새로운 시각을 가질 수 있었습니다. 아연님이 제시한 단점은 다음과 같습니다:
  - 클래스명에서 이미 역할이 부여되었음에도 어떤 Action을 호출하는지 바로 알 수 없다.
  - 특정 DTO에 맞추는 과정에서 불필요한 필드가 늘어나 Action의 역할에 혼란을 줄 수 있다.
    - 현재 옵션널을 통해 타입을 받는데 이 때문에 DTO에 과다한 역할이 몰린다.

**resolver 프로그램의 안정성**

- 공부를 이어가며 궁금했던 점은, 비즈니스 로직을 호출하는 resolver 프로그램이 중요한 허브 역할을 하는 만큼, 이 프로그램의 안정성을 어떻게 보장하는지에 대한 부분이었습니다.
  이에 대해 성준 팀장님께서는 **안정성이 깨질 위험이 적다**고 답변해 주셨습니다.
- 이유는 초기 로직 구현 이후 변경되는 케이스가 거의 없으며, 테스트와 테스트 프로그램의 과정을 통해 철저히 검증되기 때문이라고 설명하셨습니다.

### 3. 위 두 주제 중 미처 해결 못한 과제. 앞으로 공부해볼 내용.

- 주현님께서 5.0 프레임워크 전체 흐름도를 공유해주셨습니다. 이를통해 전체적인 흐름을 다시 복습하고자합니다.
- Action과 Program이 넘기는 DTO들에 대해 이해가 부족한 것 같습니다. 가끔 DTO에 대해 타입이 맞지않아 에러가 나는데 저 혼자 해결을 못하고 민준님께서 도와주셨습니다. 혼자서 해결할 수 있도록 성장하고 싶습니다.

---

## 4. 소프트 스킬면에서 성장한 점 (선택)

과제를 통해 제 이해도를 점검할 수 있어 좋았습니다. 평가를 앞두고 진행한 과제여서 부담감이 컸지만, 이를 통해 제가 부족한 부분을 파악할 수 있었습니다. 또한, 동기들이 잘 이해하고 있는 점을 확인하고, 해당 부분에 대해 질문을 통해 배우며 제 이해를 확장할 수 있었습니다. 다만, 갑작스럽게 진행된 과제에 긴장하여 제 생각을 충분히 정리하지 못한 점은 아쉬움으로 남습니다. 앞으로는 저의 생각을 명확히 풀어낼 수 있도록 보완해 나가겠습니다.
